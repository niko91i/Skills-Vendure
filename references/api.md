# Vendure - Api

**Pages:** 800

---

## CustomDetailComponentLocationId

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-detail-components/custom-detail-component-location-id

**Contents:**
- CustomDetailComponentLocationId
- CustomDetailComponentLocationId‚Äã

The valid locations for embedding a CustomDetailComponent.

**Examples:**

Example 1 (ts):
```ts
type CustomDetailComponentLocationId = | 'administrator-profile'    | 'administrator-detail'    | 'channel-detail'    | 'collection-detail'    | 'country-detail'    | 'customer-detail'    | 'customer-group-detail'    | 'draft-order-detail'    | 'facet-detail'    | 'global-settings-detail'    | 'order-detail'    | 'payment-method-detail'    | 'product-detail'    | 'product-variant-detail'    | 'promotion-detail'    | 'seller-detail'    | 'shipping-method-detail'    | 'stock-location-detail'    | 'tax-category-detail'    | 'tax-rate-detail'    | 'zone-detail'
```

---

## OrderProcess

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-process/

**Contents:**
- OrderProcess
- OrderProcess‚Äã
  - transitions‚Äã
  - onTransitionStart‚Äã
  - onTransitionEnd‚Äã
  - onTransitionError‚Äã
- DefaultOrderProcessOptions‚Äã
  - checkModificationPayments‚Äã
  - checkAdditionalPaymentsAmount‚Äã
  - checkAllVariantsExist‚Äã

An OrderProcess is used to define the way the order process works as in: what states an Order can be in, and how it may transition from one state to another. Using the onTransitionStart() hook, an OrderProcess can perform checks before allowing a state transition to occur, and the onTransitionEnd() hook allows logic to be executed after a state change.

For detailed description of the interface members, see the StateMachineConfig docs.

This is configured via the orderOptions.process property of your VendureConfig.

Options which can be passed to the configureDefaultOrderProcess function to configure an instance of the default OrderProcess. By default, all options are set to true.

Prevents an Order from transitioning out of the Modifying state if the Order price has changed and there is no Payment or Refund associated with the Modification.

Prevents an Order from transitioning out of the ArrangingAdditionalPayment state if the Order's Payments do not cover the full amount of totalWithTax.

Prevents the transition from AddingItems to any other state (apart from Cancelled) if and of the ProductVariants no longer exists due to deletion.

Prevents transition to the ArrangingPayment state if the active Order has no lines.

Prevents transition to the ArrangingPayment state if the active Order has no customer associated with it.

Prevents transition to the ArrangingPayment state if the active Order has no shipping method set.

Prevents transition to the ArrangingPayment state if there is insufficient saleable stock to cover the contents of the Order.

Prevents transition to the PaymentAuthorized or PaymentSettled states if the order totalWithTax amount is not covered by Payment(s) in the corresponding states.

Prevents transition to the Cancelled state unless all OrderItems are already cancelled.

Prevents transition to the Shipped, PartiallyShipped, Delivered & PartiallyDelivered states unless there are corresponding Fulfillments in the correct states to allow this. E.g. Shipped only if all items in the Order are part of a Fulfillment which itself is in the Shipped state.

Used to configure a customized instance of the default OrderProcess that ships with Vendure. Using this function allows you to turn off certain checks and constraints that are enabled by default.

The DefaultOrderProcessOptions type defines all available options. If you require even more customization, you can create your own implementation of the OrderProcess interface.

This is the built-in default OrderProcess that ships with Vendure. A customized version of this process can be created using the `configureDefaultOrderProcess` function, which allows you to pass in an object to enable/disable certain checks.

The default implementation manages order state transitions and includes validation checks such as verification that modifications have associated payments, confirmation that payment amounts cover order totals, validation of product variant existence, requirements for customer, shipping method, and stock availability before payment arrangement, and fulfillment state verification before shipping/delivery transitions.

**Examples:**

Example 1 (ts):
```ts
interface OrderProcess<State extends keyof CustomOrderStates | string> extends InjectableStrategy {    transitions?: Transitions<State, State | OrderState> & Partial<Transitions<OrderState | State>>;    onTransitionStart?: OnTransitionStartFn<State | OrderState, OrderTransitionData>;    onTransitionEnd?: OnTransitionEndFn<State | OrderState, OrderTransitionData>;    onTransitionError?: OnTransitionErrorFn<State | OrderState>;}
```

Example 2 (ts):
```ts
interface DefaultOrderProcessOptions {    checkModificationPayments?: boolean;    checkAdditionalPaymentsAmount?: boolean;    checkAllVariantsExist?: boolean;    arrangingPaymentRequiresContents?: boolean;    arrangingPaymentRequiresCustomer?: boolean;    arrangingPaymentRequiresShipping?: boolean;    arrangingPaymentRequiresStock?: boolean;    checkPaymentsCoverTotal?: boolean;    checkAllItemsBeforeCancel?: boolean;    checkFulfillmentStates?: boolean;}
```

Example 3 (ts):
```ts
import { configureDefaultOrderProcess, VendureConfig } from '@vendure/core';const myCustomOrderProcess = configureDefaultOrderProcess({  // Disable the constraint that requires  // Orders to have a shipping method assigned  // before payment.  arrangingPaymentRequiresShipping: false,});export const config: VendureConfig = {  orderOptions: {    process: [myCustomOrderProcess],  },};
```

Example 4 (ts):
```ts
function configureDefaultOrderProcess(options: DefaultOrderProcessOptions): void
```

---

## BlockingEventHandlerOptions

**URL:** https://docs.vendure.io/reference/typescript-api/events/blocking-event-handler-options

**Contents:**
- BlockingEventHandlerOptions
- BlockingEventHandlerOptions‚Äã
  - event‚Äã
  - handler‚Äã
  - id‚Äã
  - before‚Äã
  - after‚Äã

Options for registering a blocking event handler.

The event type to which the handler should listen. Can be a single event type or an array of event types.

The handler function which will be executed when the event is published. If the handler returns a Promise, the event publishing code will wait for the Promise to resolve before continuing. Any errors thrown by the handler will cause the event publishing code to fail.

A unique identifier for the handler. This can then be used to specify the order in which handlers should be executed using the before and after options in other handlers.

The ID of another handler which this handler should execute before.

The ID of another handler which this handler should execute after.

**Examples:**

Example 1 (ts):
```ts
type BlockingEventHandlerOptions<T extends VendureEvent> = {    event: Type<T> | Array<Type<T>>;    handler: (event: T) => void | Promise<void>;    id: string;    before?: string;    after?: string;}
```

---

## AddActionBarDropdownMenuItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/add-action-bar-dropdown-menu-item

**Contents:**
- AddActionBarDropdownMenuItem
- addActionBarDropdownMenuItem‚Äã
  - config‚Äã

Adds a dropdown menu item to the ActionBar at the top right of each list or detail view. The locationId can be determined by pressing ctrl + u when running the Admin UI in dev mode.

**Examples:**

Example 1 (ts):
```ts
import { addActionBarDropdownMenuItem } from '@vendure/admin-ui/core';export default [    addActionBarDropdownMenuItem({        id: 'print-invoice',        label: 'Print Invoice',        locationId: 'order-detail',        routerLink: ['/extensions/invoicing'],    }),];
```

Example 2 (ts):
```ts
function addActionBarDropdownMenuItem(config: ActionBarDropdownMenuItem): void
```

---

## OrderInterceptor

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-interceptor/

**Contents:**
- OrderInterceptor
- OrderInterceptor‚Äã
- Example: Min/max order quantity‚Äã
  - willAddItemToOrder‚Äã
  - willAdjustOrderLine‚Äã
  - willRemoveItemFromOrder‚Äã

An OrderInterceptor is a class which can be used to intercept and modify the behavior of order-related operations.

It does this by providing methods which are called whenever the contents of an order are about to get changed. These methods are able to prevent the operation from proceeding by returning a string error message.

Examples of use-cases for an OrderInterceptor include:

This is configured via the orderOptions.orderInterceptors property of your VendureConfig.

OrderInterceptors are executed when the following mutations are called:

Additionally, if you are working directly with the OrderService, the following methods will trigger any registered OrderInterceptors:

When an OrderInterceptor is registered, it will be called in the order in which it was registered. If an interceptor method resolves to a string, the operation will be prevented and the string will be used as the error message.

When multiple interceptors are registered, the first interceptor to resolve to a string will prevent the operation from proceeding.

Errors returned by OrderInterceptors are surfaced to the GraphQL API as an OrderInterceptorError and can be queried like this:

In the above example, the error message returned by the OrderInterceptor would be available in the interceptorError field.

Let's say we want to allow ProductVariants to specify the minimum or maximum amount which may be added to an order. We can define custom fields to store this information and then use this custom field value to prevent an order line from being added to the order if the quantity is below the minimum.

Called when a new item is about to be added to the order, as in the addItemToOrder mutation or the addItemToOrder() / addItemsToOrder() method of the OrderService.

Called when an existing order line is about to be adjusted, as in the adjustOrderLine mutation or the adjustOrderLine() / adjustOrderLines() method of the OrderService.

Called when an item is about to be removed from the order, as in the removeItemFromOrder mutation or the removeItemFromOrder() / removeItemsFromOrder() method of the OrderService.

**Examples:**

Example 1 (graphql):
```graphql
mutation AddItemToOrder($productVariantId: ID!, $quantity: Int!) {  addItemToOrder(productVariantId: $productVariantId, quantity: $quantity) {    ... on Order {      id      code      # ... other Order fields    }    ... on ErrorResult {      errorCode      message    }    ... on OrderInterceptorError {      interceptorError    }  }}
```

Example 2 (ts):
```ts
import {  EntityHydrator,  Injector,  LanguageCode,  Order,  OrderInterceptor,  ProductVariant,  RequestContext,  TranslatorService,  VendurePlugin,  WillAddItemToOrderInput,  WillAdjustOrderLineInput,} from '@vendure/core';declare module '@vendure/core/dist/entity/custom-entity-fields' {  interface CustomProductVariantFields {    minOrderQuantity?: number;    maxOrderQuantity?: number;  }}// This OrderInterceptor enforces minimum and maximum order quantities on ProductVariants.export class MinMaxOrderInterceptor implements OrderInterceptor { private entityHydrator: EntityHydrator; private tra
...
```

Example 3 (ts):
```ts
interface OrderInterceptor extends InjectableStrategy {    willAddItemToOrder?(        ctx: RequestContext,        order: Order,        input: WillAddItemToOrderInput,    ): Promise<void | string> | void | string;    willAdjustOrderLine?(        ctx: RequestContext,        order: Order,        input: WillAdjustOrderLineInput,    ): Promise<void | string> | void | string;    willRemoveItemFromOrder?(        ctx: RequestContext,        order: Order,        orderLine: OrderLine,    ): Promise<void | string> | void | string;}
```

---

## StripePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/payments-plugin/stripe-plugin/

**Contents:**
- StripePlugin
- StripePlugin‚Äã
- Requirements‚Äã
- Setup‚Äã
- Storefront usage‚Äã
- Local development‚Äã
  - options‚Äã
  - init‚Äã
- StripePluginOptions‚Äã
  - storeCustomersInStripe‚Äã

Plugin to enable payments through Stripe via the Payment Intents API.

You will need to create a Stripe account and get your secret key in the dashboard.

Create a webhook endpoint in the Stripe dashboard (Developers -> Webhooks, "Add an endpoint") which listens to the payment_intent.succeeded and payment_intent.payment_failed events. The URL should be https://my-server.com/payments/stripe, where my-server.com is the host of your Vendure server. Note: for local development, you'll need to use the Stripe CLI to test your webhook locally. See the local development section below.

Get the signing secret for the newly created webhook.

Install the Payments plugin and the Stripe Node library:

yarn add @vendure/payments-plugin stripe

npm install @vendure/payments-plugin stripe

The plugin is designed to work with the Custom payment flow. In this flow, Stripe provides libraries which handle the payment UI and confirmation for you. You can install it in your storefront project with:

If you are using React, you should also consider installing @stripe/react-stripe-js, which is a wrapper around Stripe Elements.

The high-level workflow is:

A full working storefront example of the Stripe integration can be found in the Remix Starter repo

Initialize the Stripe payment plugin

Configuration options for the Stripe payments plugin.

If set to true, a Customer object will be created in Stripe - if it doesn't already exist - for authenticated users, which prevents payment methods attached to other Customers to be used with the same PaymentIntent. This is done by adding a custom field to the Customer entity to store the Stripe customer ID, so switching this on will require a database migration / synchronization.

Attach extra metadata to Stripe payment intent creation call.

Note: If the paymentIntentCreateParams is also used and returns a metadata key, then the values returned by both functions will be merged.

Provide additional parameters to the Stripe payment intent creation. By default, the plugin will already pass the amount, currency, customer and automatic_payment_methods: { enabled: true } parameters.

For example, if you want to provide a description for the payment intent, you can do so like this:

Provide additional options to the Stripe payment intent creation. By default, the plugin will already pass the idempotencyKey parameter.

For example, if you want to provide a stripeAccount for the payment intent, you can do so like this:

Provide additional parameters to the Stripe customer creation. By default, the plugin will already pass the `email` and `name` parameters. This allows you to add additional fields such as address information to the Stripe customer object.

For example, if you want to provide address details for the customer, you can do so like this:

```typescript
import { EntityHydrator, VendureConfig } from '@vendure/core';
import { StripePlugin } from '@vendure/payments-plugin/package/stripe';

export const config: VendureConfig = {
  plugins: [
    StripePlugin.init({
      storeCustomersInStripe: true,
      customerCreateParams: async (injector, ctx, order) => {
        const entityHydrator = injector.get(EntityHydrator);
        const customer = order.customer;
        await entityHydrator.hydrate(ctx, customer, { relations: ['addresses'] });
        const defaultBillingAddress = customer.addresses.find(a => a.defaultBillingAddress) ?? customer.addresses[0];
        return {
          address: {
            line1: defaultBillingAddress.streetLine1 || order.shippingAddress?.streetLine1,
            postal_code: defaultBillingAddress.postalCode || order.shippingAddress?.postalCode,
            city: defaultBillingAddress.city || order.shippingAddress?.city,
            state: defaultBillingAddress.province || order.shippingAddress?.province,
            country: defaultBillingAddress.country.code || order.shippingAddress?.countryCode,
          },
        };
      }
    }),
  ],
};
```

**Examples:**

Example 1 (ts):
```ts
import { StripePlugin } from '@vendure/payments-plugin/package/stripe';// ...plugins: [  StripePlugin.init({    // This prevents different customers from using the same PaymentIntent    storeCustomersInStripe: true,  }),]
```

Example 2 (shell):
```shell
yarn add @stripe/stripe-js# ornpm install @stripe/stripe-js
```

Example 3 (ts):
```ts
import { Elements } from '@stripe/react-stripe-js';import { loadStripe, Stripe } from '@stripe/stripe-js';import { CheckoutForm } from './CheckoutForm';const stripePromise = getStripe('pk_test_....wr83u');type StripePaymentsProps = {  clientSecret: string;  orderCode: string;}export function StripePayments({ clientSecret, orderCode }: StripePaymentsProps) {  const options = {    // passing the client secret obtained from the server    clientSecret,  }  return (    <Elements stripe={stripePromise} options={options}>      <CheckoutForm orderCode={orderCode} />    </Elements>  );}
```

Example 4 (ts):
```ts
// CheckoutForm.tsximport { useStripe, useElements, PaymentElement } from '@stripe/react-stripe-js';import { FormEvent } from 'react';export const CheckoutForm = ({ orderCode }: { orderCode: string }) => {  const stripe = useStripe();  const elements = useElements();  const handleSubmit = async (event: FormEvent) => {    // We don't want to let default form submission happen here,    // which would refresh the page.    event.preventDefault();    if (!stripe || !elements) {      // Stripe.js has not yet loaded.      // Make sure to disable form submission until Stripe.js has loaded.      return
...
```

---

## TimeAgoPipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/time-ago-pipe

**Contents:**
- TimeAgoPipe
- TimeAgoPipe‚Äã
  - constructor‚Äã
  - transform‚Äã

Converts a date into the format "3 minutes ago", "5 hours ago" etc.

**Examples:**

Example 1 (html):
```html
{{ order.orderPlacedAt | timeAgo }}
```

Example 2 (ts):
```ts
class TimeAgoPipe implements PipeTransform {    constructor(i18nService: I18nService)    transform(value: string | Date, nowVal?: string | Date) => string;}
```

---

## GenerateMigration

**URL:** https://docs.vendure.io/reference/typescript-api/migration/generate-migration

**Contents:**
- GenerateMigration
- generateMigration‚Äã
  - userConfig‚Äã
  - options‚Äã

Generates a new migration file based on any schema changes (e.g. adding or removing CustomFields). See TypeORM migration docs for more information about the underlying migration mechanism.

**Examples:**

Example 1 (ts):
```ts
function generateMigration(userConfig: Partial<VendureConfig>, options: MigrationOptions): Promise<string | undefined>
```

---

## Job

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job

**Contents:**
- Job
- Job‚Äã
  - id‚Äã
  - queueName‚Äã
  - retries‚Äã
  - createdAt‚Äã
  - name‚Äã
  - data‚Äã
  - state‚Äã
  - progress‚Äã

A Job represents a piece of work to be run in the background, i.e. outside the request-response cycle. It is intended to be used for long-running work triggered by API requests. Jobs should now generally be directly instantiated. Rather, the JobQueue add() method should be used to create and add a new Job to a queue.

Calling this signifies that the job work has started. This method should be called in the JobQueueStrategy next() method.

Sets the progress (0 - 100) of the job.

Calling this method signifies that the job succeeded. The result will be stored in the Job.result property.

Calling this method signifies that the job failed.

Sets a RUNNING job back to PENDING. Should be used when the JobQueue is being destroyed before the job has been completed.

Used to register event handler for job events

An event raised by a Job.

The signature of the event handler expected by the Job.on() method.

**Examples:**

Example 1 (ts):
```ts
class Job<T extends JobData<T> = any> {    readonly id: number | string | null;    readonly queueName: string;    readonly retries: number;    readonly createdAt: Date;    name: string    data: T    state: JobState    progress: number    result: any    error: any    isSettled: boolean    startedAt: Date | undefined    settledAt: Date | undefined    duration: number    attempts: number    constructor(config: JobConfig<T>)    start() => ;    setProgress(percent: number) => ;    complete(result?: any) => ;    fail(err?: any) => ;    cancel() => ;    defer() => ;    on(eventType: JobEventType, lis
...
```

Example 2 (ts):
```ts
type JobEventType = 'progress'
```

Example 3 (ts):
```ts
type JobEventListener<T extends JobData<T>> = (job: Job<T>) => void
```

---

## UiExtensionCompilerOptions

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/ui-extension-compiler-options

**Contents:**
- UiExtensionCompilerOptions
- UiExtensionCompilerOptions‚Äã
  - outputPath‚Äã
  - extensions‚Äã
  - ngCompilerPath‚Äã
  - devMode‚Äã
  - baseHref‚Äã
  - watchPort‚Äã
  - command‚Äã
  - additionalProcessArguments‚Äã

Options to configure how the Admin UI should be compiled.

The directory into which the sources for the extended Admin UI will be copied.

An array of objects which configure Angular modules and/or translations with which to extend the Admin UI.

Allows you to manually specify the path to the Angular CLI compiler script. This can be useful in scenarios where for some reason the built-in start/build scripts are unable to locate the ng command.

This option should not usually be required.

Set to true in order to compile the Admin UI in development mode (using the Angular CLI ng serve command). When in dev mode, any changes to UI extension files will be watched and trigger a rebuild of the Admin UI with live reloading.

Allows the baseHref of the compiled Admin UI app to be set. This determines the prefix of the app, for example with the default value of '/admin/', the Admin UI app will be configured to be served from http://<host>/admin/.

Note: if you are using this in conjunction with the AdminUiPlugin then you should also set the route option to match this value.

In watch mode, allows the port of the dev server to be specified. Defaults to the Angular CLI default of 4200.

Internally, the Angular CLI will be invoked as an npm script. By default, the compiler will use Yarn to run the script if it is detected, otherwise it will use npm. This setting allows you to explicitly set which command to use, including pnpm, rather than relying on the default behavior.

Additional command-line arguments which will get passed to the ng build command (or ng serve if devMode = true).

['--disable-host-check'] // to disable host check

**Examples:**

Example 1 (ts):
```ts
interface UiExtensionCompilerOptions {    outputPath: string;    extensions: Extension[];    ngCompilerPath?: string | undefined;    devMode?: boolean;    baseHref?: string;    watchPort?: number;    command?: UiExtensionBuildCommand;    additionalProcessArguments?: UiExtensionCompilerProcessArgument[];}
```

Example 2 (ts):
```ts
compileUiExtensions({    ngCompilerPath: path.join(__dirname, '../../node_modules/@angular/cli/bin/ng.js'),    outputPath: path.join(__dirname, '../admin-ui'),    extensions: [      // ...    ],})
```

Example 3 (ts):
```ts
AdminUiPlugin.init({  route: 'my-route',  port: 5001,  app: compileUiExtensions({    baseHref: '/my-route/',    outputPath: path.join(__dirname, './custom-admin-ui'),    extensions: [],    devMode: true,  }),}),
```

---

## InitialData

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/initial-data

**Contents:**
- InitialData
- InitialData‚Äã
  - defaultLanguage‚Äã
  - defaultZone‚Äã
  - roles‚Äã
  - countries‚Äã
  - taxRates‚Äã
  - shippingMethods‚Äã
  - paymentMethods‚Äã
  - collections‚Äã

An object defining initial settings for a new Vendure installation.

**Examples:**

Example 1 (ts):
```ts
interface InitialData {    defaultLanguage: LanguageCode;    defaultZone: string;    roles?: RoleDefinition[];    countries: CountryDefinition[];    taxRates: Array<{ name: string; percentage: number }>;    shippingMethods: Array<{ name: string; price: number; taxRate?: number }>;    paymentMethods: Array<{ name: string; handler: ConfigurableOperationInput }>;    collections: CollectionDefinition[];}
```

---

## DefaultRefundProcess

**URL:** https://docs.vendure.io/reference/typescript-api/payment/default-refund-process

**Contents:**
- DefaultRefundProcess
- defaultRefundProcess‚Äã

The default RefundProcess.

---

## HealthCheckRegistryService

**URL:** https://docs.vendure.io/reference/typescript-api/health-check/health-check-registry-service

**Contents:**
- HealthCheckRegistryService
- HealthCheckRegistryService‚Äã
  - registerIndicatorFunction‚Äã

This service is used to register health indicator functions to be included in the health check. Health checks can be used by automated services such as Kubernetes to determine the state of applications it is running. They are also useful for administrators to get an overview of the health of all the parts of the Vendure stack.

It wraps the Nestjs Terminus module, so see those docs for information on creating custom health checks.

Plugins which rely on external services (web services, databases etc.) can make use of this service to add a check for that dependency to the Vendure health check.

Since v1.6.0, the preferred way to implement a custom health check is by creating a new HealthCheckStrategy and then passing it to the systemOptions.healthChecks array. See the HealthCheckStrategy docs for an example configuration.

The alternative way to register a health check is by injecting this service directly into your plugin module. To use it in your plugin, you'll need to import the PluginCommonModule:

Registers one or more HealthIndicatorFunctions (see Nestjs docs) to be added to the health check endpoint. The indicator will also appear in the Admin UI's "system status" view.

**Examples:**

Example 1 (ts):
```ts
import { HealthCheckRegistryService, PluginCommonModule, VendurePlugin } from '@vendure/core';import { TerminusModule } from '@nestjs/terminus';@VendurePlugin({  imports: [PluginCommonModule, TerminusModule],})export class MyPlugin {  constructor(    private registry: HealthCheckRegistryService    private httpIndicator: HttpHealthIndicator  ) {    registry.registerIndicatorFunction(      () => this.httpIndicator.pingCheck('vendure-docs', 'https://www.vendure.io/docs/'),    )  }}
```

Example 2 (ts):
```ts
class HealthCheckRegistryService {    registerIndicatorFunction(fn: HealthIndicatorFunction | HealthIndicatorFunction[]) => ;}
```

---

## Importer

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/importer

**Contents:**
- Importer
- Importer‚Äã
  - parseAndImport‚Äã
  - importProducts‚Äã
  - getFacetValueIds‚Äã
  - processCustomFieldValues‚Äã

Parses and imports Products using the CSV import format.

Internally it is using the ImportParser to parse the CSV file, and then the FastImporterService and the AssetImporter to actually create the resulting entities in the Vendure database.

Parses the contents of the product import CSV file and imports the resulting Product & ProductVariants, as well as any associated Assets, Facets & FacetValues.

The ctxOrLanguageCode argument is used to specify the languageCode to be used when creating the Products.

Imports the products specified in the rows object. Return an array of error messages.

**Examples:**

Example 1 (ts):
```ts
class Importer {    parseAndImport(input: string | Stream, ctxOrLanguageCode: RequestContext | LanguageCode, reportProgress: boolean = false) => Observable<ImportProgress>;    importProducts(ctx: RequestContext, rows: ParsedProductWithVariants[], onProgress: OnProgressFn) => Promise<string[]>;    getFacetValueIds(ctx: RequestContext, facets: ParsedFacet[], languageCode: LanguageCode) => Promise<ID[]>;    processCustomFieldValues(customFields: { [field: string]: string }, config: CustomFieldConfig[]) => ;}
```

---

## Calculated

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/calculated

**Contents:**
- Calculated
- Calculated‚Äã
  - queryInstruction‚Äã
- CalculatedColumnQueryInstruction‚Äã
  - relations‚Äã
  - query‚Äã
  - expression‚Äã

Used to define calculated entity getters. The decorator simply attaches an array of "calculated" property names to the entity's prototype. This array is then used by the CalculatedPropertySubscriberto transfer the getter function from the prototype to the entity instance.

Optional metadata used to tell the ListQueryBuilder & Relations decorator how to deal with calculated columns when sorting, filtering and deriving required relations from GraphQL operations.

If the calculated property depends on one or more relations being present on the entity (e.g. an Order entity calculating the totalQuantity by adding up the quantities of each OrderLine), then those relations should be defined here.

**Examples:**

Example 1 (ts):
```ts
function Calculated(queryInstruction?: CalculatedColumnQueryInstruction): MethodDecorator
```

Example 2 (ts):
```ts
interface CalculatedColumnQueryInstruction {    relations?: string[];    query?: (qb: SelectQueryBuilder<any>) => void;    expression?: string;}
```

---

## Email Utils

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-utils

**Contents:**
- Email Utils
- transformOrderLineAssetUrls‚Äã
  - ctx‚Äã
  - order‚Äã
  - injector‚Äã
- shippingLinesWithMethod‚Äã
  - order‚Äã

Applies the configured AssetStorageStrategy.toAbsoluteUrl() function to each of the OrderLine's featuredAsset.preview properties, so that they can be correctly displayed in the email template. This is required since that step usually happens at the API in middleware, which is not applicable in this context. So we need to do it manually.

Note: Mutates the Order object

Ensures that the ShippingLines have a shippingMethod so that we can use the shippingMethod.name property in the email template.

**Examples:**

Example 1 (ts):
```ts
function transformOrderLineAssetUrls(ctx: RequestContext, order: Order, injector: Injector): Order
```

Example 2 (ts):
```ts
function shippingLinesWithMethod(order: Order): ShippingLine[]
```

---

## StellatePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/stellate-plugin/

**Contents:**
- StellatePlugin
- StellatePlugin‚Äã
- Pre-requisites‚Äã
- Installation‚Äã
- Configuration‚Äã
- Storefront setup‚Äã
- Custom PurgeRules‚Äã
- DevMode & Debug Logging‚Äã
  - options‚Äã
  - init‚Äã

A plugin to integrate the Stellate GraphQL caching service with your Vendure server. The main purpose of this plugin is to ensure that cached data gets correctly purged in response to events inside Vendure. For example, changes to a Product's description should purge any associated record for that Product in Stellate's cache.

You will first need to set up a free Stellate account.

You will also need to generate an API token for the Stellate Purging API. For instructions on how to generate the token, see the Stellate Purging API docs.

The plugin is configured via the StellatePlugin.init() method. This method accepts an options object which defines the Stellate service name and API token, as well as an array of PurgeRules which define how the plugin will respond to Vendure events in order to trigger calls to the Stellate Purging API.

In your Stellate dashboard, you can use the following configuration example as a sensible default for a Vendure application:

In your storefront, you should point your GraphQL client to the Stellate GraphQL API endpoint, which is https://<service-name>.stellate.sh.

Wherever you are using the search query (typically in product listing & search pages), you should also add the cacheIdentifier field to the query. This will ensure that the Stellate cache is correctly purged when a Product or Collection is updated.

The configuration above only accounts for caching of some of the built-in Vendure entity types. If you have custom entity types, you may well want to add them to the Stellate cache. In this case, you'll also need a way to purge those entities from the cache when they are updated. This is where the PurgeRule comes in.

Let's imagine that you have built a simple CMS plugin for Vendure which exposes an Article entity in your Shop API, and you have added this to your Stellate configuration:

You can then add a custom PurgeRule to the StellatePlugin configuration:

In development, you can set devMode: true, which will prevent any calls being made to the Stellate Purging API.

If you want to log the calls that would be made to the Stellate Purge API when in devMode, you can set debugLogging: true. Note that debugLogging generates a lot of debug-level logging, so it is recommended to only enable this when needed.

**Examples:**

Example 1 (text):
```text
npm install @vendure/stellate-plugin
```

Example 2 (ts):
```ts
import { StellatePlugin, defaultPurgeRules } from '@vendure/stellate-plugin';import { VendureConfig } from '@vendure/core';export const config: VendureConfig = {   // ...   plugins: [       StellatePlugin.init({           // The Stellate service name, i.e. `<serviceName>.stellate.sh`           serviceName: 'my-service',           // The API token for the Stellate Purging API. See the "pre-requisites" section above.           apiToken: process.env.STELLATE_PURGE_API_TOKEN,           devMode: !isProd || process.env.STELLATE_DEBUG_MODE ? true : false,           debugLogging: process.env.STELLATE_
...
```

Example 3 (ts):
```ts
import { Config } from "stellate";const config: Config = {  config: {    name: "my-vendure-server",    originUrl: "https://my-vendure-server.com/shop-api",    ignoreOriginCacheControl: true,    passThroughOnly: false,    scopes: {      SESSION_BOUND: "header:authorization|cookie:session",    },    headers: {      "access-control-expose-headers": "vendure-auth-token",    },    rootTypeNames: {      query: "Query",      mutation: "Mutation",    },    keyFields: {      types: {        SearchResult: ["productId"],        SearchResponseCacheIdentifier: ["collectionSlug"],      },    },    rules: [ 
...
```

Example 4 (ts):
```ts
import { graphql } from '../generated/gql';export const searchProductsDocument = graphql(`    query SearchProducts($input: SearchInput!) {        search(input: $input) {            cacheIdentifier {                collectionSlug            }            items {               # ...            }        }    }}`);
```

---

## Tax

**URL:** https://docs.vendure.io/reference/typescript-api/tax/

**Contents:**
- Tax
- üìÑÔ∏è AddressBasedTaxZoneStrategy
- üìÑÔ∏è DefaultTaxLineCalculationStrategy
- üìÑÔ∏è DefaultTaxZoneStrategy
- üìÑÔ∏è TaxLineCalculationStrategy
- üìÑÔ∏è TaxOptions
- üìÑÔ∏è TaxZoneStrategy

AddressBasedTaxZoneStrategy

DefaultTaxLineCalculationStrategy

DefaultTaxZoneStrategy

TaxLineCalculationStrategy

---

## DefaultSearchPluginInitOptions

**URL:** https://docs.vendure.io/reference/typescript-api/default-search-plugin/default-search-plugin-init-options

**Contents:**
- DefaultSearchPluginInitOptions
- DefaultSearchPluginInitOptions‚Äã
  - indexStockStatus‚Äã
  - bufferUpdates‚Äã
  - searchStrategy‚Äã

Options which configure the behaviour of the DefaultSearchPlugin

If set to true, the stock status of a ProductVariant (inStock: Boolean) will be exposed in the search query results. Enabling this option on an existing Vendure installation will require a DB migration/synchronization.

If set to true, updates to Products, ProductVariants and Collections will not immediately trigger an update to the search index. Instead, all these changes will be buffered and will only be run via a call to the runPendingSearchIndexUpdates mutation in the Admin API.

This is very useful for installations with a large number of ProductVariants and/or Collections, as the buffering allows better control over when these expensive jobs are run, and also performs optimizations to minimize the amount of work that needs to be performed by the worker.

Set a custom search strategy that implements SearchStrategy or extends an existing search strategy such as MysqlSearchStrategy, PostgresSearchStrategy or SqliteSearchStrategy.

**Examples:**

Example 1 (ts):
```ts
interface DefaultSearchPluginInitOptions {    indexStockStatus?: boolean;    bufferUpdates?: boolean;    searchStrategy?: SearchStrategy;}
```

Example 2 (ts):
```ts
export class MySearchStrategy implements SearchStrategy {    private readonly minTermLength = 2;    private connection: TransactionalConnection;    private options: DefaultSearchPluginInitOptions;    async init(injector: Injector) {        this.connection = injector.get(TransactionalConnection);        this.options = injector.get(PLUGIN_INIT_OPTIONS);    }    async getFacetValueIds(        ctx: RequestContext,        input: SearchInput,        enabledOnly: boolean,    ): Promise<Map<ID, number>> {        // ...        return createFacetIdCountMap(facetValuesResult);    }    async getCollection
...
```

---

## DefaultOrderItemPriceCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/default-order-item-price-calculation-strategy

**Contents:**
- DefaultOrderItemPriceCalculationStrategy
- DefaultOrderItemPriceCalculationStrategy‚Äã
  - calculateUnitPrice‚Äã

The default OrderItemPriceCalculationStrategy, which simply passes through the price of the ProductVariant without performing any calculations

**Examples:**

Example 1 (ts):
```ts
class DefaultOrderItemPriceCalculationStrategy implements OrderItemPriceCalculationStrategy {    calculateUnitPrice(ctx: RequestContext, productVariant: ProductVariant) => PriceCalculationResult | Promise<PriceCalculationResult>;}
```

---

## ConfigArgs

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/config-args/

**Contents:**
- ConfigArgs
- ConfigArgs‚Äã
- Data types‚Äã
- Lists‚Äã
- UI Component‚Äã
  - [index]‚Äã

A object which defines the configurable arguments which may be passed to functions in those classes which implement the ConfigurableOperationDef interface.

Each argument has a data type, which must be one of ConfigArgType.

Setting the list property to true will make the argument into an array of the specified data type. For example, if you want to store an array of strings:

In the Admin UI, this will be rendered as an orderable list of string inputs.

The ui field allows you to specify a specific input component to be used in the Admin UI. When not set, a default input component is used appropriate to the data type.

The available components as well as their configuration options can be found in the DefaultFormConfigHash docs. Custom UI components may also be defined via an Admin UI extension using the registerFormInputComponent() function which is exported from @vendure/admin-ui/core.

**Examples:**

Example 1 (ts):
```ts
{  apiKey: { type: 'string' },  maxRetries: { type: 'int' },  logErrors: { type: 'boolean' },}
```

Example 2 (ts):
```ts
{  aliases: {    type: 'string',    list: true,  },}
```

Example 3 (ts):
```ts
{  operator: {    type: 'string',    ui: {      component: 'select-form-input',      options: [        { value: 'startsWith' },        { value: 'endsWith' },        { value: 'contains' },        { value: 'doesNotContain' },      ],    },  },  secretKey: {    type: 'string',    ui: { component: 'password-form-input' },  },}
```

Example 4 (ts):
```ts
type ConfigArgs = {    [name: string]: ConfigArgDef<ConfigArgType>;}
```

---

## Seller

**URL:** https://docs.vendure.io/reference/typescript-api/entities/seller/

**Contents:**
- Seller
- Seller‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - customFields‚Äã
  - channels‚Äã

A Seller represents the person or organization who is selling the goods on a given Channel. By default, a single-channel Vendure installation will have a single default Seller.

Extends: VendureEntity

Implements: SoftDeletable, HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Seller extends VendureEntity implements SoftDeletable, HasCustomFields {    constructor(input?: DeepPartial<Seller>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column() name: string;    @Column(type => CustomSellerFields)    customFields: CustomSellerFields;    @OneToMany(type => Channel, channel => channel.seller)    channels: Channel[];}
```

---

## ProductOptionGroup

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product-option-group/

**Contents:**
- ProductOptionGroup
- ProductOptionGroup‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - code‚Äã
  - translations‚Äã
  - options‚Äã
  - product‚Äã
  - customFields‚Äã

A grouping of one or more ProductOptions.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class ProductOptionGroup extends VendureEntity implements Translatable, HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<ProductOptionGroup>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    @Column()    code: string;    @OneToMany(type => ProductOptionGroupTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<ProductOptionGroup>>;    @OneToMany(type => ProductOption, option => option.group)    options: ProductOption[];    @Index()    @ManyToOne(type => Product, product => product.opti
...
```

---

## EmailEventHandler

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-event-handler

**Contents:**
- EmailEventHandler
- EmailEventHandler‚Äã
- Handling other languages‚Äã
- Defining a custom handler‚Äã
  - 1. Create a new handler‚Äã
  - 2. Create the email template‚Äã
  - 3. Register the handler‚Äã
  - constructor‚Äã
  - filter‚Äã
  - setRecipient‚Äã

The EmailEventHandler defines how the EmailPlugin will respond to a given event.

A handler is created by creating a new EmailEventListener and calling the .on() method to specify which event to respond to.

This example creates a handler which listens for the OrderStateTransitionEvent and if the Order has transitioned to the 'PaymentSettled' state, it will generate and send an email.

The string argument passed into the EmailEventListener constructor is used to identify the handler, and also to locate the directory of the email template files. So in the example above, there should be a directory <app root>/static/email/templates/order-confirmation which contains a Handlebars template named body.hbs.

By default, the handler will respond to all events on all channels and use the same subject ("Order confirmation for #12345" above) and body template.

Since v2.0 the .addTemplate() method has been deprecated. To serve different templates ‚Äî for example, based on the current languageCode ‚Äî implement a custom TemplateLoader and pass it to EmailPlugin.init({ templateLoader: new MyTemplateLoader() }).

The language is typically determined by the languageCode property of the event's ctx (RequestContext) object, so the loadTemplate() method can use that to locate the correct template file.

Let's say you have a plugin which defines a new event type, QuoteRequestedEvent. In your plugin you have defined a mutation which is executed when the customer requests a quote in your storefront, and in your resolver, you use the EventBus to publish a new QuoteRequestedEvent.

You now want to email the customer with their quote. Here are the steps you would take to set this up:

Next you need to make sure there is a template defined at <app root>/static/email/templates/quote-requested/body.hbs. The path segment quote-requested must match the string passed to the EmailEventListener constructor.

The template would look something like this:

You can find pre-made templates on the MJML website.

Finally, you need to register the handler with the EmailPlugin:

Defines a predicate function which is used to determine whether the event will trigger an email. Multiple filter functions may be defined.

A function which defines how the recipient email address should be extracted from the incoming event.

The recipient can be a plain email address: `'foobar@example.com'` Or with a formatted name (includes unicode support): `'–ù–æ–¥–µ –ú–∞–π–ª–µ—Ä <foobar@example.com>'` Or a comma-separated list of addresses: `'foobar@example.com, "–ù–æ–¥–µ –ú–∞–π–ª–µ—Ä" <bar@example.com>'`

**Examples:**

Example 1 (ts):
```ts
const confirmationHandler = new EmailEventListener('order-confirmation')  .on(OrderStateTransitionEvent)  .filter(event => event.toState === 'PaymentSettled')  .setRecipient(event => event.order.customer.emailAddress)  .setFrom('{{ fromAddress }}')  .setSubject(`Order confirmation for #{{ order.code }}`)  .setTemplateVars(event => ({ order: event.order }));
```

Example 2 (ts):
```ts
import { EmailPlugin, TemplateLoader } from '@vendure/email-plugin';import { readFileSync } from 'fs';import path from 'path';class CustomLanguageAwareTemplateLoader implements TemplateLoader {  constructor(private templateDir: string) {}  async loadTemplate(_injector, ctx, { type, templateName }) {    // e.g. returns the content of "body.de.hbs" or "body.en.hbs" depending on ctx.languageCode    const filePath = path.join(this.templateDir, type, `${templateName}.${ctx.languageCode}.hbs`);    return readFileSync(filePath, 'utf-8');  }}EmailPlugin.init({  templateLoader: new CustomLanguageAwareT
...
```

Example 3 (ts):
```ts
import { EmailEventListener } from `@vendure/email-plugin`;import { QuoteRequestedEvent } from `./events`;const quoteRequestedHandler = new EmailEventListener('quote-requested')  .on(QuoteRequestedEvent)  .setRecipient(event => event.customer.emailAddress)  .setSubject(`Here's the quote you requested`)  .setFrom('{{ fromAddress }}')  .setTemplateVars(event => ({ details: event.details }));
```

Example 4 (handlebars):
```handlebars
{{> header title="Here's the quote you requested" }}<mj-section background-color="#fafafa">    <mj-column>        <mj-text color="#525252">            Thank you for your interest in our products! Here's the details            of the quote you recently requested:        </mj-text>        <!-- your custom email layout goes here -->    </mj-column></mj-section>{{> footer }}
```

---

## Storefront GraphQL Code Generation

**URL:** https://docs.vendure.io/guides/storefront/codegen

**Contents:**
- Storefront GraphQL Code Generation
- Installation‚Äã
- Configuration‚Äã
- Running Codegen‚Äã
- Use the graphql() function‚Äã

Code generation means the automatic generation of TypeScript types based on your GraphQL schema and your GraphQL operations. This is a very powerful feature that allows you to write your code in a type-safe manner, without you needing to manually write any types for your API calls.

To do this, we will use Graphql Code Generator.

This guide is for adding codegen to your storefront. For a guide on adding codegen to your backend Vendure plugins or UI extensions, see the Plugin Codegen guide.

Follow the installation instructions in the GraphQL Code Generator Quick Start.

During the init step, you'll be prompted to select various options about how to configure the code generation.

The init step above will create a codegen.ts file in your project root. Add the highlighted lines:

During the init step, you will have installed a codegen script in your package.json. You can run this script to generate the TypeScript types for your GraphQL operations.

Ensure you have the Vendure server running before running the codegen script.

This will generate a src/gql directory containing the TypeScript types for your GraphQL operations.

If you have existing GraphQL queries and mutations in your application, you can now use the graphql() function exported by the src/gql/index.ts file to execute them. If you were previously using the gql tagged template function, replace it with the graphql() function.

In the above example, the type information all works out of the box because the graphql-request library from v5.0.0 has built-in support for the TypedDocumentNode type, as do the latest versions of most of the popular GraphQL client libraries, such as Apollo Client & Urql.

In the documentation examples on other pages, we do not assume the use of code generation in order to keep the examples as simple as possible.

**Examples:**

Example 1 (bash):
```bash
npm i graphqlnpm i -D typescript @graphql-codegen/clinpx graphql-code-generator initnpm install
```

Example 2 (ts):
```ts
import type { CodegenConfig } from '@graphql-codegen/cli';const config: CodegenConfig = {  overwrite: true,  schema: 'http://localhost:3000/shop-api',  documents: 'src/**/*.graphql.ts',  generates: {    'src/gql/': {      preset: 'client',      plugins: [],      config: {        scalars: {            // This tells codegen that the `Money` scalar is a number            Money: 'number',        },        namingConvention: {            // This ensures generated enums do not conflict with the built-in types.            enumValues: 'keep',        },      }    },  }};export default config;
```

Example 3 (bash):
```bash
npm run codegen
```

Example 4 (ts):
```ts
import { useQuery } from '@tanstack/react-query';import request from 'graphql-request'import { graphql } from './gql';// GET_PRODUCTS will be a `TypedDocumentNode` type,// which encodes the types of the query variables and the response data.const GET_PRODUCTS = graphql(`    query GetProducts($options: ProductListOptions) {        products(options: $options) {            items {                id                name                slug                featuredAsset {                    preview                }            }        }    }`);export default function App() {  // `data` will now be co
...
```

---

## MergeConfig

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/merge-config/

**Contents:**
- MergeConfig
- mergeConfig‚Äã
  - target‚Äã
  - source‚Äã
  - depth‚Äã

Performs a deep merge of two VendureConfig objects. Unlike Object.assign() the target object is not mutated, instead the function returns a new object which is the result of deeply merging the values of source into target.

Arrays do not get merged, they are treated as a single value that will be replaced. So if merging the plugins array, you must explicitly concatenate the array.

**Examples:**

Example 1 (ts):
```ts
const result = mergeConfig(defaultConfig, {  assetOptions: {    uploadMaxFileSize: 5000,  },  plugins: [    ...defaultConfig.plugins,    MyPlugin,  ]};
```

Example 2 (ts):
```ts
function mergeConfig<T extends VendureConfig>(target: T, source: PartialVendureConfig, depth:  = 0): T
```

---

## Directives

**URL:** https://docs.vendure.io/reference/admin-ui-api/directives/

**Contents:**
- Directives
- üìÑÔ∏è IfMultichannelDirective
- üìÑÔ∏è IfPermissionsDirective

IfMultichannelDirective

IfPermissionsDirective

---

## Extensions Api

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/

**Contents:**
- Extensions Api
- üìÑÔ∏è ActionBar
- üìÑÔ∏è Alerts
- üìÑÔ∏è DataTables
- üìÑÔ∏è DefineDashboardExtension
- üìÑÔ∏è DetailForms
- üìÑÔ∏è FormComponents
- üìÑÔ∏è HistoryEntries
- üìÑÔ∏è Login
- üìÑÔ∏è Navigation

DashboardActionBarItem

DashboardAlertDefinition

DashboardDataTableExtensionDefinition

defineDashboardExtension

DashboardDetailFormInputComponent

DashboardCustomFormComponent

DashboardHistoryEntryComponent

DashboardLoginExtensions

DashboardNavSectionDefinition

DashboardPageBlockDefinition

DashboardRouteDefinition

DashboardWidgetDefinition

---

## Province

**URL:** https://docs.vendure.io/reference/typescript-api/entities/province

**Contents:**
- Province
- Province‚Äã
  - constructor‚Äã
  - type‚Äã

A Province represents an administrative subdivision of a Country. For example, in the United States, the country would be "United States" and the province would be "California".

**Examples:**

Example 1 (ts):
```ts
class Province extends Region {    constructor(input?: DeepPartial<Province>)    readonly type: RegionType = 'province';}
```

---

## ExternalAuthenticationService

**URL:** https://docs.vendure.io/reference/typescript-api/auth/external-authentication-service

**Contents:**
- ExternalAuthenticationService
- ExternalAuthenticationService‚Äã
  - constructor‚Äã
  - findCustomerUser‚Äã
  - findAdministratorUser‚Äã
  - createCustomerAndUser‚Äã
  - createAdministratorAndUser‚Äã
  - findUser‚Äã
  - createUser‚Äã

This is a helper service which exposes methods related to looking up and creating Users based on an external AuthenticationStrategy.

Looks up a User based on their identifier from an external authentication provider, ensuring this User is associated with a Customer account.

By default, only customers in the currently-active Channel will be checked. By passing false as the checkCurrentChannelOnly argument, all channels will be checked.

Looks up a User based on their identifier from an external authentication provider, ensuring this User is associated with an Administrator account.

If a customer has been successfully authenticated by an external authentication provider, yet cannot be found using findCustomerUser, then we need to create a new User and Customer record in Vendure for that user. This method encapsulates that logic as well as additional housekeeping such as adding a record to the Customer's history.

If an administrator has been successfully authenticated by an external authentication provider, yet cannot be found using findAdministratorUser, then we need to create a new User and Administrator record in Vendure for that user.

Looks up a User based on their identifier from an external authentication provider. Creates the user if does not exist. Unlike findCustomerUser and findAdministratorUser, this method does not enforce that the User is associated with a Customer or Administrator account.

**Examples:**

Example 1 (ts):
```ts
class ExternalAuthenticationService {    constructor(connection: TransactionalConnection, roleService: RoleService, historyService: HistoryService, customerService: CustomerService, administratorService: AdministratorService, channelService: ChannelService)    findCustomerUser(ctx: RequestContext, strategy: string, externalIdentifier: string, checkCurrentChannelOnly:  = true) => Promise<User | undefined>;    findAdministratorUser(ctx: RequestContext, strategy: string, externalIdentifier: string) => Promise<User | undefined>;    createCustomerAndUser(ctx: RequestContext, config: {            st
...
```

---

## ActionBarContext

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/action-bar-context

**Contents:**
- ActionBarContext
- ActionBarContext‚Äã
  - route‚Äã
  - injector‚Äã
  - dataService‚Äã
  - notificationService‚Äã
  - entity$‚Äã

Providers & data available to the onClick & buttonState functions of an ActionBarItem, ActionBarDropdownMenuItem or NavMenuItem.

The router's ActivatedRoute object for the current route. This object contains information about the route, its parameters, and additional data associated with the route.

The Angular Injector which can be used to get instances of services and other providers available in the application.

The DataService, which provides methods for querying the server-side data.

The NotificationService, which provides methods for displaying notifications to the user.

An observable of the current entity in a detail view. In a list view the observable will not emit any values.

**Examples:**

Example 1 (ts):
```ts
interface ActionBarContext {    route: ActivatedRoute;    injector: Injector;    dataService: DataService;    notificationService: NotificationService;    entity$: Observable<Record<string, any> | undefined>;}
```

Example 2 (ts):
```ts
addActionBarDropdownMenuItem({    id: 'print-invoice',    locationId: 'order-detail',    label: 'Print Invoice',    icon: 'printer',    buttonState: context => {        return context.entity$.pipe(            map((order) => {                return order?.state === 'PaymentSettled'                    ? { disabled: false, visible: true }                    : { disabled: true, visible: true };            }),        );    },    requiresPermission: ['UpdateOrder'],}),
```

---

## HistoryService

**URL:** https://docs.vendure.io/reference/typescript-api/services/history-service/

**Contents:**
- HistoryService
- HistoryService‚Äã
- Custom History Entry Types‚Äã
  - constructor‚Äã
  - getHistoryForOrder‚Äã
  - createHistoryEntryForOrder‚Äã
  - getHistoryForCustomer‚Äã
  - createHistoryEntryForCustomer‚Äã
  - updateOrderHistoryEntry‚Äã
  - deleteOrderHistoryEntry‚Äã

Contains methods relating to HistoryEntry entities. Histories are timelines of actions related to a particular Customer or Order, recording significant events such as creation, state changes, notes, etc.

Since Vendure v1.9.0, it is possible to define custom HistoryEntry types.

Let's take an example where we have some Customers who are businesses. We want to verify their tax ID in order to allow them wholesale rates. As part of this verification, we'd like to add an entry into the Customer's history with data about the tax ID verification.

First of all we'd extend the GraphQL HistoryEntryType enum for our new type as part of a plugin

Next we need to create a TypeScript type definition file where we extend the CustomerHistoryEntryData interface. This is done via TypeScript's declaration merging and ambient modules features.

Note: it works exactly the same way if we wanted to add a custom type for Order history, except in that case we'd extend the OrderHistoryEntryData interface instead.

Now that we have our types set up, we can use the HistoryService to add a new HistoryEntry in a type-safe manner:

It is also possible to define a UI component to display custom history entry types. See the Custom History Timeline Components guide.

**Examples:**

Example 1 (ts):
```ts
import { PluginCommonModule, VendurePlugin } from '@vendure/core';import { VerificationService } from './verification.service';@VendurePlugin({  imports: [PluginCommonModule],  adminApiExtensions: {    schema: gql`      extend enum HistoryEntryType {        CUSTOMER_TAX_ID_VERIFICATION      }    `,  },  providers: [VerificationService],})export class TaxIDVerificationPlugin {}
```

Example 2 (ts):
```ts
// types.tsimport { CustomerHistoryEntryData } from '@vendure/core';export const CUSTOMER_TAX_ID_VERIFICATION = 'CUSTOMER_TAX_ID_VERIFICATION';declare module '@vendure/core' {  interface CustomerHistoryEntryData {    [CUSTOMER_TAX_ID_VERIFICATION]: {      taxId: string;      valid: boolean;      name?: string;      address?: string;    };  }}
```

Example 3 (ts):
```ts
// verification.service.tsimport { Injectable } from '@nestjs/common';import { RequestContext } from '@vendure/core';import { CUSTOMER_TAX_ID_VERIFICATION } from './types';@Injectable()export class VerificationService {  constructor(private historyService: HistoryService) {}  async verifyTaxId(ctx: RequestContext, customerId: ID, taxId: string) {    const result = await someTaxIdCheckingService(taxId);    await this.historyService.createHistoryEntryForCustomer({      customerId,      ctx,      type: CUSTOMER_TAX_ID_VERIFICATION,      data: {        taxId,        valid: result.isValid,        n
...
```

Example 4 (ts):
```ts
class HistoryService {    constructor(connection: TransactionalConnection, administratorService: AdministratorService, listQueryBuilder: ListQueryBuilder, eventBus: EventBus)    getHistoryForOrder(ctx: RequestContext, orderId: ID, publicOnly: boolean, options?: HistoryEntryListOptions) => Promise<PaginatedList<OrderHistoryEntry>>;    createHistoryEntryForOrder(args: CreateOrderHistoryEntryArgs<T>, isPublic:  = true) => Promise<OrderHistoryEntry>;    getHistoryForCustomer(ctx: RequestContext, customerId: ID, publicOnly: boolean, options?: HistoryEntryListOptions) => Promise<PaginatedList<Custom
...
```

---

## RequestContext

**URL:** https://docs.vendure.io/reference/typescript-api/request/request-context/

**Contents:**
- RequestContext
- RequestContext‚Äã
  - empty‚Äã
  - deserialize‚Äã
  - userHasPermissions‚Äã
  - serialize‚Äã
  - copy‚Äã
  - req‚Äã
  - apiType‚Äã
  - channel‚Äã

The RequestContext holds information relevant to the current request, which may be required at various points of the stack.

It is a good practice to inject the RequestContext (using the Ctx decorator) into all resolvers & REST handler, and then pass it through to the service layer.

This allows the service layer to access information about the current user, the active language, the active Channel, and so on. In addition, the TransactionalConnection relies on the presence of the RequestContext object in order to correctly handle per-request database transactions.

The RequestContext also provides mechanisms for managing the database replication mode via the setReplicationMode method and the replicationMode getter. This allows for finer control over whether database queries within the context should be executed against the master or a replica database, which can be particularly useful in distributed database environments.

Creates an "empty" RequestContext object. This is only intended to be used when a service method must be called outside the normal request-response cycle, e.g. when programmatically populating data. Usually a better alternative is to use the RequestContextService create() method, which allows more control over the resulting RequestContext object.

Creates a new RequestContext object from a serialized object created by the serialize() method.

Returns true if there is an active Session & User associated with this request, and that User has the specified permissions on the active Channel.

Serializes the RequestContext object into a JSON-compatible simple object. This is useful when you need to send a RequestContext object to another process, e.g. to pass it to the Job Queue via the JobQueueService.

Creates a shallow copy of the RequestContext instance. This means that mutations to the copy itself will not affect the original, but deep mutations (e.g. copy.channel.code = 'new') will also affect the original.

The raw Express request object.

Signals which API this request was received by, e.g. admin or shop.

The active Channel of this request.

True if the current session is authorized to access the current resolver method.

True if the current anonymous session is only authorized to operate on entities that are owned by the current session.

Translate the given i18n key

Sets the replication mode for the current RequestContext. This mode determines whether the operations within this context should interact with the master database or a replica database. This allows for finer control over database query routing in distributed database environments.

Available modes:
- `'master'`: Routes operations to the master database
- `'replica'`: Routes operations to a replica database

The replication mode can be retrieved using the `replicationMode` getter property.

**Examples:**

Example 1 (ts):
```ts
@Query()myQuery(@Ctx() ctx: RequestContext) {  return this.myService.getData(ctx);}
```

Example 2 (ts):
```ts
@Query()myMutation(@Ctx() ctx: RequestContext) {  ctx.setReplicationMode('master');  return this.myService.getData(ctx);}
```

Example 3 (ts):
```ts
class RequestContext {    empty() => RequestContext;    deserialize(ctxObject: SerializedRequestContext) => RequestContext;    userHasPermissions(permissions: Permission[]) => boolean;    serialize() => SerializedRequestContext;    copy() => RequestContext;    req: Request | undefined    apiType: ApiType    channel: Channel    channelId: ID    languageCode: LanguageCode    currencyCode: CurrencyCode    session: CachedSession | undefined    activeUserId: ID | undefined    isAuthorized: boolean    authorizedAsOwnerOnly: boolean    translate(key: string, variables?: { [k: string]: any }) => strin
...
```

---

## DefaultTaxZoneStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/tax/default-tax-zone-strategy

**Contents:**
- DefaultTaxZoneStrategy
- DefaultTaxZoneStrategy‚Äã
  - determineTaxZone‚Äã

A default method of determining Zone for tax calculations. The strategy simply returns the default tax zone of the Channel. In many cases you actually want to base the tax zone on the shipping or billing address of the Order, in which case you would use the AddressBasedTaxZoneStrategy.

**Examples:**

Example 1 (ts):
```ts
class DefaultTaxZoneStrategy implements TaxZoneStrategy {    determineTaxZone(ctx: RequestContext, zones: Zone[], channel: Channel, order?: Order) => Zone;}
```

---

## RegisterBulkAction

**URL:** https://docs.vendure.io/reference/admin-ui-api/bulk-actions/register-bulk-action

**Contents:**
- RegisterBulkAction
- registerBulkAction‚Äã
  - bulkAction‚Äã

Registers a custom BulkAction which can be invoked from the bulk action menu of any supported list view.

This allows you to provide custom functionality that can operate on any of the selected items in the list view.

In this example, imagine we have an integration with a 3rd-party text translation service. This bulk action allows us to select multiple products from the product list view, and send them for translation via a custom service which integrates with the translation service's API.

**Examples:**

Example 1 (ts):
```ts
import { ModalService, registerBulkAction, SharedModule } from '@vendure/admin-ui/core';import { ProductDataTranslationService } from './product-data-translation.service';export default [    ProductDataTranslationService,    registerBulkAction({        location: 'product-list',        label: 'Send to translation service',        icon: 'language',        onClick: ({ injector, selection }) => {            const modalService = injector.get(ModalService);            const translationService = injector.get(ProductDataTranslationService);            modalService                .dialog({             
...
```

Example 2 (ts):
```ts
function registerBulkAction(bulkAction: BulkAction): void
```

---

## TaxCategoryService

**URL:** https://docs.vendure.io/reference/typescript-api/services/tax-category-service

**Contents:**
- TaxCategoryService
- TaxCategoryService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã

Contains methods relating to TaxCategory entities.

**Examples:**

Example 1 (ts):
```ts
class TaxCategoryService {    constructor(connection: TransactionalConnection, eventBus: EventBus, listQueryBuilder: ListQueryBuilder)    findAll(ctx: RequestContext, options?: ListQueryOptions<TaxCategory>) => Promise<PaginatedList<TaxCategory>>;    findOne(ctx: RequestContext, taxCategoryId: ID) => Promise<TaxCategory | undefined>;    create(ctx: RequestContext, input: CreateTaxCategoryInput) => Promise<TaxCategory>;    update(ctx: RequestContext, input: UpdateTaxCategoryInput) => Promise<TaxCategory>;    delete(ctx: RequestContext, id: ID) => Promise<DeletionResponse>;}
```

---

## React Components

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/

**Contents:**
- React Components
- üìÑÔ∏è ActionBar
- üìÑÔ∏è Card
- üìÑÔ∏è CdsIcon
- üìÑÔ∏è FormField
- üìÑÔ∏è Link
- üìÑÔ∏è PageBlock
- üìÑÔ∏è PageDetailLayout
- üìÑÔ∏è RichTextEditor

---

## Mutations

**URL:** https://docs.vendure.io/reference/graphql-api/admin/mutations

**Contents:**
- Mutations
- addCustomersToGroup‚Äã
- addFulfillmentToOrder‚Äã
- addItemToDraftOrder‚Äã
- addManualPaymentToOrder‚Äã
- addMembersToZone‚Äã
- addNoteToCustomer‚Äã
- addNoteToOrder‚Äã
- addOptionGroupToProduct‚Äã
- adjustDraftOrderLine‚Äã

---

## Orders

**URL:** https://docs.vendure.io/reference/typescript-api/orders/

**Contents:**
- Orders
- üìÑÔ∏è ActiveOrderService
- üìÑÔ∏è ActiveOrderStrategy
- üìÑÔ∏è ChangedPriceHandlingStrategy
- üìÑÔ∏è CustomOrderStates
- üìÑÔ∏è DefaultActiveOrderStrategy
- üìÑÔ∏è DefaultGuestCheckoutStrategy
- üìÑÔ∏è DefaultOrderItemPriceCalculationStrategy
- üìÑÔ∏è DefaultOrderPlacedStrategy
- üìÑÔ∏è DefaultStockAllocationStrategy

ChangedPriceHandlingStrategy

DefaultActiveOrderStrategy

DefaultGuestCheckoutStrategy

DefaultOrderItemPriceCalculationStrategy

DefaultOrderPlacedStrategy

DefaultStockAllocationStrategy

GuestCheckoutStrategy

OrderByCodeAccessStrategy

OrderItemPriceCalculationStrategy

StockAllocationStrategy

---

## CurrencyCode

**URL:** https://docs.vendure.io/reference/typescript-api/common/currency-code

**Contents:**
- CurrencyCode
- CurrencyCode‚Äã

ISO 4217 currency code

**Examples:**

Example 1 (ts):
```ts
enum CurrencyCode {    AED = 'AED'    AFN = 'AFN'    ALL = 'ALL'    AMD = 'AMD'    ANG = 'ANG'    AOA = 'AOA'    ARS = 'ARS'    AUD = 'AUD'    AWG = 'AWG'    AZN = 'AZN'    BAM = 'BAM'    BBD = 'BBD'    BDT = 'BDT'    BGN = 'BGN'    BHD = 'BHD'    BIF = 'BIF'    BMD = 'BMD'    BND = 'BND'    BOB = 'BOB'    BRL = 'BRL'    BSD = 'BSD'    BTN = 'BTN'    BWP = 'BWP'    BYN = 'BYN'    BZD = 'BZD'    CAD = 'CAD'    CDF = 'CDF'    CHF = 'CHF'    CLP = 'CLP'    CNY = 'CNY'    COP = 'COP'    CRC = 'CRC'    CUC = 'CUC'    CUP = 'CUP'    CVE = 'CVE'    CZK = 'CZK'    DJF = 'DJF'    DKK = 'DKK'    DOP = '
...
```

---

## UseUiLanguageLoader

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-ui-language-loader

**Contents:**
- UseUiLanguageLoader
- useUiLanguageLoader‚Äã

Loads the UI translations for the given locale and activates it with the Lingui I18nProvider. Generally this is used internally when the display language is set via the user > language dialog.

**Examples:**

Example 1 (ts):
```ts
function useUiLanguageLoader(): void
```

---

## PermissionGuard

**URL:** https://docs.vendure.io/reference/dashboard/components/permission-guard

**Contents:**
- PermissionGuard
- PermissionGuard‚Äã
  - props‚Äã
- PermissionGuardProps‚Äã
  - requires‚Äã
  - children‚Äã

This component is used to protect a route from unauthorized access. It will render the children if the user has the required permissions.

The props for the PermissionGuard component.

The permission(s) required to access the children.

The children to render if the user has the required permissions.

**Examples:**

Example 1 (tsx):
```tsx
<PermissionGuard requires={['UpdateTaxCategory']}>    <Button type="submit">        <Trans>Update</Trans>    </Button></PermissionGuard>
```

Example 2 (ts):
```ts
function PermissionGuard(props: Readonly<PermissionGuardProps>): void
```

Example 3 (ts):
```ts
interface PermissionGuardProps {    requires: Permission | string | string[] | Permission[];    children: React.ReactNode;}
```

---

## Page Blocks

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/page-blocks

**Contents:**
- Page Blocks
- DashboardPageBlockDefinition‚Äã
  - id‚Äã
  - title‚Äã
  - location‚Äã
  - component‚Äã
  - shouldRender‚Äã
  - requiresPermission‚Äã
- PageBlockPosition‚Äã
  - blockId‚Äã

This allows you to insert a custom component into a specific location on any page in the dashboard.

An ID for the page block. Should be unique at least to the page in which it appears.

An optional title for the page block

The location of the page block. It specifies the pageId, and then the relative location compared to another existing block.

The component to be rendered inside the page block.

Control whether to render the page block depending on your custom logic.

This can also be used to disable any built-in blocks you do not need to display.

If you need to query aspects about the current context not immediately provided in the PageContextValue, you can also use hooks such as useChannel in this function.

If provided, the logged-in user must have one or more of the specified permissions in order for the block to render.

For more advanced control over rendering, use the shouldRender function.

The relative position of a PageBlock. This is determined by finding an existing block, and then specifying whether your custom block should come before, after, or completely replace that block.

The location of a page block in the dashboard. The location can be found by turning on "developer mode" in the dashboard user menu (bottom left corner) and then clicking the < /> icon when hovering over a page block.

**Examples:**

Example 1 (ts):
```ts
interface DashboardPageBlockDefinition {    id: string;    title?: React.ReactNode;    location: PageBlockLocation;    component?: React.FunctionComponent<{ context: PageContextValue }>;    shouldRender?: (context: PageContextValue) => boolean;    requiresPermission?: string | string[];}
```

Example 2 (ts):
```ts
type PageBlockPosition = {    blockId: string;    order: 'before' | 'after' | 'replace'}
```

Example 3 (ts):
```ts
type PageBlockLocation = {    pageId: string;    position: PageBlockPosition;    column: 'main' | 'side';}
```

---

## FulfillmentProcess

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/fulfillment-process/

**Contents:**
- FulfillmentProcess
- defaultFulfillmentProcess‚Äã
- FulfillmentProcess‚Äã
  - transitions‚Äã
  - onTransitionStart‚Äã
  - onTransitionEnd‚Äã
  - onTransitionError‚Äã

The default FulfillmentProcess. This process includes the following actions:

A FulfillmentProcess is used to define the way the fulfillment process works as in: what states a Fulfillment can be in, and how it may transition from one state to another. Using the onTransitionStart() hook, a FulfillmentProcess can perform checks before allowing a state transition to occur, and the onTransitionEnd() hook allows logic to be executed after a state change.

For detailed description of the interface members, see the StateMachineConfig docs.

**Examples:**

Example 1 (ts):
```ts
interface FulfillmentProcess<State extends keyof CustomFulfillmentStates | string> extends InjectableStrategy {    transitions?: Transitions<State, State | FulfillmentState> &        Partial<Transitions<FulfillmentState | State>>;    onTransitionStart?: OnTransitionStartFn<State | FulfillmentState, FulfillmentTransitionData>;    onTransitionEnd?: OnTransitionEndFn<State | FulfillmentState, FulfillmentTransitionData>;    onTransitionError?: OnTransitionErrorFn<State | FulfillmentState>;}
```

---

## BaseListComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/base-list-component

**Contents:**
- BaseListComponent
- BaseListComponent‚Äã
  - searchTermControl‚Äã
  - selectionManager‚Äã
  - result$‚Äã
  - items$‚Äã
  - totalItems$‚Äã
  - itemsPerPage$‚Äã
  - currentPage$‚Äã
  - destroy$‚Äã

This is a base class which implements the logic required to fetch and manipulate a list of data from a query which returns a PaginatedList type.

It is normally used in combination with the DataTable2Component.

Sets the fetch function for the list being implemented.

Accepts a list of Observables which will trigger a refresh of the list when any of them emit.

Sets the current page number in the url.

Sets the number of items per page in the url.

Re-fetch the current page of results.

**Examples:**

Example 1 (ts):
```ts
class BaseListComponent<ResultType, ItemType, VariableType extends Record<string, any> = any> implements OnInit, OnDestroy {    searchTermControl = new FormControl('');    selectionManager = new SelectionManager<any>({        multiSelect: true,        itemsAreEqual: (a, b) => a.id === b.id,        additiveMode: true,    });    result$: Observable<ResultType>;    items$: Observable<ItemType[]>;    totalItems$: Observable<number>;    itemsPerPage$: Observable<number>;    currentPage$: Observable<number>;    protected destroy$ = new Subject<void>();    protected refresh$ = new BehaviorSubject<und
...
```

---

## Job Queue Plugin

**URL:** https://docs.vendure.io/reference/core-plugins/job-queue-plugin/

**Contents:**
- Job Queue Plugin
- üìÑÔ∏è BullMQJobQueuePlugin
- üìÑÔ∏è BullMQJobQueueStrategy
- üìÑÔ∏è BullMQPluginOptions
- üìÑÔ∏è Job Queue Plugin
- üìÑÔ∏è PubSubJobQueueStrategy
- üìÑÔ∏è PubSubPlugin

BullMQJobQueueStrategy

PubSubJobQueueStrategy

---

## LocaleDatePipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/locale-date-pipe

**Contents:**
- LocaleDatePipe
- LocaleDatePipe‚Äã
  - constructor‚Äã
  - transform‚Äã

A replacement of the Angular DatePipe which makes use of the Intl API to format dates according to the selected UI language.

Extends: LocaleBasePipe

Implements: PipeTransform

**Examples:**

Example 1 (html):
```html
{{ order.orderPlacedAt | localeDate }}
```

Example 2 (ts):
```ts
class LocaleDatePipe extends LocaleBasePipe implements PipeTransform {    constructor(dataService?: DataService, changeDetectorRef?: ChangeDetectorRef)    transform(value: unknown, args: unknown[]) => unknown;}
```

---

## Region

**URL:** https://docs.vendure.io/reference/typescript-api/entities/region

**Contents:**
- Region
- Region‚Äã
  - code‚Äã
  - type‚Äã
  - name‚Äã
  - parent‚Äã
  - parentId‚Äã
  - enabled‚Äã
  - translations‚Äã
  - customFields‚Äã

A Region represents a geographical administrative unit, such as a Country, Province, State, Prefecture etc. This is an abstract class which is extended by the Country and Province entities. Regions can be grouped into Zones which are in turn used to determine applicable shipping and taxes for an Order.

Extends: VendureEntity

Implements: Translatable, HasCustomFields

A code representing the region. The code format will depend on the type of region. For example, a Country code will be a 2-letter ISO code, whereas a Province code could use a format relevant to the type of province, e.g. a US state code like "CA".

**Examples:**

Example 1 (ts):
```ts
class Region extends VendureEntity implements Translatable, HasCustomFields {    @Column() code: string;    @Column({ nullable: false, type: 'varchar' })    readonly type: RegionType;    name: LocaleString;    @Index()    @ManyToOne(type => Region, { nullable: true, onDelete: 'SET NULL' })    parent?: Region;    @EntityId({ nullable: true })    parentId?: ID;    @Column() enabled: boolean;    @OneToMany(type => RegionTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<Region>>;    @Column(type => CustomRegionFields)    customFields: CustomRegionFie
...
```

---

## DefaultVendureComplexityEstimator

**URL:** https://docs.vendure.io/reference/core-plugins/harden-plugin/default-vendure-complexity-estimator

**Contents:**
- DefaultVendureComplexityEstimator
- defaultVendureComplexityEstimator‚Äã
  - customComplexityFactors‚Äã
  - logFieldScores‚Äã

A complexity estimator which takes into account List and PaginatedList types and can be further configured by providing a customComplexityFactors object.

When selecting PaginatedList types, the "take" argument is used to estimate a complexity factor. If the "take" argument is omitted, a default factor of 1000 is applied.

**Examples:**

Example 1 (ts):
```ts
function defaultVendureComplexityEstimator(customComplexityFactors: { [path: string]: number }, logFieldScores: boolean): void
```

---

## DefaultStockAllocationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/default-stock-allocation-strategy

**Contents:**
- DefaultStockAllocationStrategy
- DefaultStockAllocationStrategy‚Äã
  - shouldAllocateStock‚Äã

Allocates stock when the Order transitions from ArrangingPayment to either PaymentAuthorized or PaymentSettled.

**Examples:**

Example 1 (ts):
```ts
class DefaultStockAllocationStrategy implements StockAllocationStrategy {    shouldAllocateStock(ctx: RequestContext, fromState: OrderState, toState: OrderState, order: Order) => boolean | Promise<boolean>;}
```

---

## InspectableJobQueueStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/inspectable-job-queue-strategy

**Contents:**
- InspectableJobQueueStrategy
- InspectableJobQueueStrategy‚Äã
  - findOne‚Äã
  - findMany‚Äã
  - findManyById‚Äã
  - removeSettledJobs‚Äã
  - cancelJob‚Äã

Defines a job queue strategy that can be inspected using the default admin ui

Returns a job by its id.

Returns a list of jobs according to the specified options.

Returns an array of jobs for the given ids.

Remove all settled jobs in the specified queues older than the given date. If no queueName is passed, all queues will be considered. If no olderThan date is passed, all jobs older than the current time will be removed.

Returns a promise of the number of jobs removed.

**Examples:**

Example 1 (ts):
```ts
interface InspectableJobQueueStrategy extends JobQueueStrategy {    findOne(id: ID): Promise<Job | undefined>;    findMany(options?: JobListOptions): Promise<PaginatedList<Job>>;    findManyById(ids: ID[]): Promise<Job[]>;    removeSettledJobs(queueNames?: string[], olderThan?: Date): Promise<number>;    cancelJob(jobId: ID): Promise<Job | undefined>;}
```

---

## AddNavMenuItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/nav-menu/add-nav-menu-item

**Contents:**
- AddNavMenuItem
- addNavMenuItem‚Äã
  - config‚Äã
  - sectionId‚Äã
  - before‚Äã

Add a menu item to an existing section specified by sectionId. The id of the section can be found by inspecting the DOM and finding the data-section-id attribute. Providing the before argument will move the item before any existing item with the specified id. If omitted (or if the name is not found) the item will be appended to the end of the section.

This should be used in the NgModule providers array of your ui extension module.

**Examples:**

Example 1 (ts):
```ts
import { addNavMenuItem } from '@vendure/admin-ui/core';export default [    addNavMenuItem({        id: 'reviews',        label: 'Product Reviews',        routerLink: ['/extensions/reviews'],        icon: 'star',    },    'marketing'),];
```

Example 2 (ts):
```ts
function addNavMenuItem(config: NavMenuItem, sectionId: string, before?: string): void
```

---

## RefundStates

**URL:** https://docs.vendure.io/reference/typescript-api/payment/refund-states

**Contents:**
- RefundStates
- RefundStates‚Äã

An interface to extend standard RefundState.

**Examples:**

Example 1 (ts):
```ts
interface RefundStates {}
```

---

## OrderStateLabelComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/order-state-label-component

**Contents:**
- OrderStateLabelComponent
- OrderStateLabelComponent‚Äã
  - state‚Äã
  - chipColorType‚Äã

Displays the state of an order in a colored chip.

**Examples:**

Example 1 (html):
```html
<vdr-order-state-label [state]="order.state"></vdr-order-state-label>
```

Example 2 (ts):
```ts
class OrderStateLabelComponent {    @Input() state: string;    chipColorType: void}
```

---

## DefaultShippingLineAssignmentStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/default-shipping-line-assignment-strategy

**Contents:**
- DefaultShippingLineAssignmentStrategy
- DefaultShippingLineAssignmentStrategy‚Äã
  - assignShippingLineToOrderLines‚Äã

This is the default ShippingLineAssignmentStrategy which simply assigns all OrderLines to the ShippingLine, and is suitable for the most common scenario of a single shipping method per Order.

**Examples:**

Example 1 (ts):
```ts
class DefaultShippingLineAssignmentStrategy implements ShippingLineAssignmentStrategy {    assignShippingLineToOrderLines(ctx: RequestContext, shippingLine: ShippingLine, order: Order) => OrderLine[] | Promise<OrderLine[]>;}
```

---

## AdminUiAppDevModeConfig

**URL:** https://docs.vendure.io/reference/typescript-api/common/admin-ui/admin-ui-app-dev-mode-config

**Contents:**
- AdminUiAppDevModeConfig
- AdminUiAppDevModeConfig‚Äã
  - sourcePath‚Äã
  - port‚Äã
  - route‚Äã
  - compile‚Äã

Information about the Admin UI app dev server.

The path to the uncompiled UI app source files. This path should contain the vendure-ui-config.json file.

The port on which the dev server is listening. Overrides the value set by AdminUiOptions.port.

Specifies the url route to the Admin UI app.

The function which will be invoked to start the app compilation process.

**Examples:**

Example 1 (ts):
```ts
interface AdminUiAppDevModeConfig {    sourcePath: string;    port: number;    route?: string;    compile: () => Promise<void>;}
```

---

## DefaultConfig

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/default-config

**Contents:**
- DefaultConfig
- defaultConfig‚Äã

The default configuration settings which are used if not explicitly overridden in the bootstrap() call.

---

## AssetImporter

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/asset-importer

**Contents:**
- AssetImporter
- AssetImporter‚Äã
  - getAssets‚Äã

This service creates new Asset entities based on string paths provided in the CSV import format. The source files are resolved by joining the value of importExportOptions.importAssetsDir with the asset path. This service is used internally by the Importer service.

Creates Asset entities for the given paths, using the assetMap cache to prevent the creation of duplicates.

**Examples:**

Example 1 (ts):
```ts
class AssetImporter {    getAssets(assetPaths: string[], ctx?: RequestContext) => Promise<{ assets: Asset[]; errors: string[] }>;}
```

---

## Components

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/

**Contents:**
- Components
- üìÑÔ∏è AssetPickerDialogComponent
- üìÑÔ∏è ChipComponent
- üìÑÔ∏è CurrencyInputComponent
- üìÑÔ∏è DataTableComponent
- üìÑÔ∏è DataTable2Component
- üìÑÔ∏è DatetimePickerComponent
- üìÑÔ∏è DropdownComponent
- üìÑÔ∏è FacetValueSelectorComponent
- üìÑÔ∏è ObjectTreeComponent

AssetPickerDialogComponent

CurrencyInputComponent

DatetimePickerComponent

FacetValueSelectorComponent

OrderStateLabelComponent

ProductVariantSelectorComponent

RichTextEditorComponent

ZoneSelectorComponent

---

## Transitions

**URL:** https://docs.vendure.io/reference/typescript-api/state-machine/transitions

**Contents:**
- Transitions
- Transitions‚Äã

A type which is used to define valid states and transitions for a state machine based on FSM.

The mergeStrategy property defines how to handle the merging of states when one set of transitions is being merged with another (as in the case of defining a OrderProcess)

**Examples:**

Example 1 (ts):
```ts
type LightColor = 'Green' | 'Amber' | 'Red';const trafficLightTransitions: Transitions<LightColor> = {  Green: {    to: ['Amber'],  },  Amber: {    to: ['Red'],  },  Red: {    to: ['Green'],  },};
```

Example 2 (ts):
```ts
type Transitions<State extends string, Target extends string = State> = {    [S in State]: {        to: Readonly<Target[]>;        mergeStrategy?: 'merge' | 'replace';    };}
```

---

## PasswordInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/password-input

**Contents:**
- PasswordInput
- PasswordFormInput‚Äã
  - props‚Äã

A component for displaying a password input.

**Examples:**

Example 1 (ts):
```ts
function PasswordFormInput(props: Readonly<DashboardFormComponentProps>): void
```

---

## ShippingEligibilityChecker

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-eligibility-checker

**Contents:**
- ShippingEligibilityChecker
- ShippingEligibilityChecker‚Äã
  - constructor‚Äã
  - init‚Äã
  - toJSON‚Äã

The ShippingEligibilityChecker class is used to check whether an order qualifies for a given ShippingMethod.

**Examples:**

Example 1 (ts):
```ts
const minOrderTotalEligibilityChecker = new ShippingEligibilityChecker({    code: 'min-order-total-eligibility-checker',    description: [{ languageCode: LanguageCode.en, value: 'Checks that the order total is above some minimum value' }],    args: {        orderMinimum: { type: 'int', ui: { component: 'currency-form-input' } },    },    check: (ctx, order, args) => {        return order.totalWithTax >= args.orderMinimum;    },});
```

Example 2 (ts):
```ts
class ShippingEligibilityChecker<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: ShippingEligibilityCheckerConfig<T>)    init(injector: Injector) => ;    toJSON() => ;}
```

---

## Promotion Condition

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/promotion-condition/

**Contents:**
- Promotion Condition
- PromotionCondition‚Äã
  - priorityValue‚Äã
  - code‚Äã
  - constructor‚Äã
  - check‚Äã
- PromotionConditionConfig‚Äã
  - code‚Äã
  - check‚Äã
  - priorityValue‚Äã

PromotionConditions are used to create Promotions. The purpose of a PromotionCondition is to check the order against a particular predicate function (the check function) and to return true if the Order satisfies the condition, or false if it does not.

Used to determine the order of application of multiple Promotions on the same Order. See the Promotion priorityScore field for more information.

This is the function which contains the conditional logic to decide whether a Promotion should apply to an Order. See CheckPromotionConditionFn.

This object is used to configure a PromotionCondition.

A function which checks whether or not a given Order satisfies the PromotionCondition.

The function should return either a boolean or and plain object type:

**Examples:**

Example 1 (ts):
```ts
class PromotionCondition<T extends ConfigArgs = ConfigArgs, C extends string = string, R extends CheckPromotionConditionResult = any> extends ConfigurableOperationDef<T> {    readonly priorityValue: number;    code: C    constructor(config: PromotionConditionConfig<T, C, R>)    check(ctx: RequestContext, order: Order, args: ConfigArg[], promotion: Promotion) => Promise<R>;}
```

Example 2 (ts):
```ts
interface PromotionConditionConfig<T extends ConfigArgs, C extends string, R extends CheckPromotionConditionResult> extends ConfigurableOperationDefOptions<T> {    code: C;    check: CheckPromotionConditionFn<T, R>;    priorityValue?: number;}
```

Example 3 (ts):
```ts
type CheckPromotionConditionFn<T extends ConfigArgs, R extends CheckPromotionConditionResult> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    promotion: Promotion,) => R | Promise<R>
```

---

## PageBlock

**URL:** https://docs.vendure.io/reference/dashboard/page-layout/page-block

**Contents:**
- PageBlock
- PageBlock‚Äã
  - props‚Äã
- PageBlockProps‚Äã
  - children‚Äã
  - column‚Äã
  - blockId‚Äã
  - title‚Äã
  - description‚Äã
  - className‚Äã

A component for displaying a block of content on a page. This should be used inside the PageLayout component. It should be provided with a column prop to determine which column it should appear in, and a blockId prop to identify the block.

Props used to configure the PageBlock component.

The content of the block.

Which column this block should appear in

The ID of the block, e.g. "gift-cards" or "related-products".

The title of the block, e.g. "Gift Cards" or "Related Products".

An optional description of the block.

An optional set of CSS classes to apply to the block.

Status: Developer Preview

A component for displaying a block of content on a page that takes up the full width of the page. This should be used inside the PageLayout component.

A component for displaying an auto-generated form for custom fields on a page. This is a special form of PageBlock that automatically generates a form corresponding to the custom fields for the given entity type.

**Examples:**

Example 1 (tsx):
```tsx
<PageBlock column="main" blockId="my-block"> <div>My Block</div></PageBlock>
```

Example 2 (ts):
```ts
function PageBlock(props: Readonly<PageBlockProps>): void
```

Example 3 (ts):
```ts
type PageBlockProps = {    children?: React.ReactNode;    column: 'main' | 'side';    blockId?: string;    title?: React.ReactNode | string;    description?: React.ReactNode | string;    className?: string;}
```

Example 4 (ts):
```ts
function FullWidthPageBlock(props: Readonly<Pick<PageBlockProps, 'children' | 'className' | 'blockId'>>): void
```

---

## ScheduledTask

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/scheduled-task

**Contents:**
- ScheduledTask
- ScheduledTask‚Äã
  - constructor‚Äã
  - id‚Äã
  - options‚Äã
  - execute‚Äã
  - configure‚Äã
- ScheduledTaskExecutionArgs‚Äã
  - injector‚Äã
  - scheduledContext‚Äã

Use this class to define a scheduled task that will be executed at a given cron schedule.

This method allows you to further configure existing scheduled tasks. For example, you may wish to change the schedule or timeout of a task, without having to define a new task.

The arguments passed to the execute method of a scheduled task.

The injector instance.

A RequestContext instance that is configured for the scheduled task.

The parameters for the scheduled task.

The configuration for a scheduled task.

The unique identifier for the scheduled task.

The description for the scheduled task.

Optional parameters that will be passed to the execute function.

The cron schedule for the scheduled task. This can be a standard cron expression or a function that returns a cron-time-generator expression.

The timeout for the scheduled task. If the task takes longer than the timeout, the task will be considered to have failed with a timeout error.

Whether the scheduled task should be prevented from running if it is already running.

The function that will be executed when the scheduled task is run.

**Examples:**

Example 1 (ts):
```ts
import { ScheduledTask } from '@vendure/core';const task = new ScheduledTask({    id: 'test-job',    schedule: cron => cron.every(2).minutes(),    execute: async ({ injector, scheduledContext, params }) => {        // some logic here    },});
```

Example 2 (ts):
```ts
class ScheduledTask<C extends Record<string, any> = Record<string, any>> {    constructor(config: ScheduledTaskConfig<C>)    id: void    options: void    execute(injector: Injector) => ;    configure(additionalConfig: Partial<Pick<ScheduledTaskConfig<C>, 'schedule' | 'timeout' | 'params'>>) => ;}
```

Example 3 (ts):
```ts
import { ScheduledTask } from '@vendure/core';const task = new ScheduledTask({    id: 'test-job',    schedule: cron => cron.every(2).minutes(),    execute: async ({ injector, scheduledContext, params }) => {        // some logic here    },});// later, you can configure the tasktask.configure({ schedule: cron => cron.every(5).minutes() });
```

Example 4 (ts):
```ts
interface ScheduledTaskExecutionArgs<C extends Record<string, any> = Record<string, any>> {    injector: Injector;    scheduledContext: RequestContext;    params: C;}
```

---

## ElasticsearchPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/elasticsearch-plugin/

**Contents:**
- ElasticsearchPlugin
- ElasticsearchPlugin‚Äã
- Installation‚Äã
- Search API Extensions‚Äã
- Example Request & Response‚Äã
  - init‚Äã

This plugin allows your product search to be powered by Elasticsearch - a powerful Open Source search engine. This is a drop-in replacement for the DefaultSearchPlugin which exposes many powerful configuration options enabling your storefront to support a wide range of use-cases such as indexing of custom properties, fine control over search index configuration, and to leverage advanced Elasticsearch features like spacial search.

**Requires Elasticsearch v7.0 < required Elasticsearch version < 7.10 ** Elasticsearch version 7.10.2 will throw error due to incompatibility with elasticsearch-js client. Check here for more info.

yarn add @elastic/elasticsearch @vendure/elasticsearch-plugin

npm install @elastic/elasticsearch @vendure/elasticsearch-plugin

Make sure to remove the DefaultSearchPlugin if it is still in the VendureConfig plugins array.

Then add the ElasticsearchPlugin, calling the .init() method with ElasticsearchOptions:

This plugin extends the default search query of the Shop API, allowing richer querying of your product data.

The SearchResponse type is extended with information about price ranges in the result set:

This SearchResponsePriceData type allows you to query data about the range of prices in the result set.

**Examples:**

Example 1 (ts):
```ts
import { ElasticsearchPlugin } from '@vendure/elasticsearch-plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    ElasticsearchPlugin.init({      host: 'http://localhost',      port: 9200,    }),  ],};
```

Example 2 (graphql):
```graphql
extend type SearchResponse {    prices: SearchResponsePriceData!}type SearchResponsePriceData {    range: PriceRange!    rangeWithTax: PriceRange!    buckets: [PriceRangeBucket!]!    bucketsWithTax: [PriceRangeBucket!]!}type PriceRangeBucket {    to: Int!    count: Int!}extend input SearchInput {    priceRange: PriceRangeInput    priceRangeWithTax: PriceRangeInput    inStock: Boolean}input PriceRangeInput {    min: Int!    max: Int!}
```

Example 3 (graphql):
```graphql
{  search (input: {    term: "table easel"    groupByProduct: true    priceRange: {      min: 500      max: 7000    }  }) {    totalItems    prices {      range {        min        max      }      buckets {        to        count      }    }    items {      productName      score      price {        ...on PriceRange {          min          max        }      }    }  }}
```

Example 4 (json):
```json
{ "data": {   "search": {     "totalItems": 9,     "prices": {       "range": {         "min": 999,         "max": 6396,       },       "buckets": [         {           "to": 1000,           "count": 1         },         {           "to": 2000,           "count": 2         },         {           "to": 3000,           "count": 3         },         {           "to": 4000,           "count": 1         },         {           "to": 5000,           "count": 1         },         {           "to": 7000,           "count": 1         }       ]     },     "items": [       {         "productName": "Loxley
...
```

---

## FormInputComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-input-components/form-input-component

**Contents:**
- FormInputComponent
- FormInputComponent‚Äã
  - isListInput‚Äã
  - readonly‚Äã
  - formControl‚Äã
  - config‚Äã

This interface should be implemented by any component being used as a custom input. For example, inputs for custom fields, or for configurable arguments.

Should be set to true if this component is designed to handle lists. If true then the formControl value will be an array of all the values in the list.

This is set by the Admin UI when consuming this component, indicating that the component should be rendered in a read-only state.

This controls the actual value of the form item. The current value is available as this.formControl.value, and an Observable stream of value changes is available as this.formControl.valueChanges. To update the value, use .setValue(val) and then .markAsDirty().

Full documentation can be found in the Angular docs.

The config property contains the full configuration object of the custom field or configurable argument.

**Examples:**

Example 1 (ts):
```ts
interface FormInputComponent<C = InputComponentConfig> {    isListInput?: boolean;    readonly: boolean;    formControl: FormControl;    config: C;}
```

---

## CookieOptions

**URL:** https://docs.vendure.io/reference/typescript-api/auth/cookie-options

**Contents:**
- CookieOptions
- CookieOptions‚Äã
  - name‚Äã
  - secret‚Äã
  - path‚Äã
  - domain‚Äã
  - sameSite‚Äã
  - secure‚Äã
  - secureProxy‚Äã
  - httpOnly‚Äã

Options for the handling of the cookies used to track sessions (only applicable if authOptions.tokenMethod is set to 'cookie'). These options are passed directly to the Express cookie-session middleware.

The name of the cookies to set. If set to a string, both cookies for the Admin API and Shop API will have the same name. If set as an object, it makes it possible to give different names to the Admin API and the Shop API cookies

The secret used for signing the session cookies for authenticated users. Only applies tokenMethod is set to 'cookie'.

In production applications, this should not be stored as a string in source control for security reasons, but may be loaded from an external file not under source control, or from an environment variable, for example.

a string indicating the path of the cookie.

a string indicating the domain of the cookie (no default).

a boolean or string indicating whether the cookie is a "same site" cookie (false by default). This can be set to 'strict', 'lax', 'none', or true (which maps to 'strict').

a boolean indicating whether the cookie is only to be sent over HTTPS (false by default for HTTP, true by default for HTTPS).

a boolean indicating whether the cookie is only to be sent over HTTPS (use this if you handle SSL not in your node process).

a boolean indicating whether the cookie is only to be sent over HTTP(S), and not made available to client JavaScript (true by default).

a boolean indicating whether the cookie is to be signed (true by default). If this is true, another cookie of the same name with the .sig suffix appended will also be sent, with a 27-byte url-safe base64 SHA1 value representing the hash of cookie-name=cookie-value against the first Keygrip key. This signature key is used to detect tampering the next time a cookie is received.

a boolean indicating whether to overwrite previously set cookies of the same name (true by default). If this is true, all cookies set during the same request with the same name (regardless of path or domain) are filtered out of the Set-Cookie header when setting this cookie.

A number representing the milliseconds from Date.now() for expiry

a Date object indicating the cookie's expiration date (expires at the end of session by default).

**Examples:**

Example 1 (ts):
```ts
interface CookieOptions {    name?: string | { shop: string; admin: string };    secret?: string;    path?: string;    domain?: string;    sameSite?: 'strict' | 'lax' | 'none' | boolean;    secure?: boolean;    secureProxy?: boolean;    httpOnly?: boolean;    signed?: boolean;    overwrite?: boolean;    maxAge?: number;    expires?: Date;}
```

---

## DefaultLogger

**URL:** https://docs.vendure.io/reference/typescript-api/logger/default-logger

**Contents:**
- DefaultLogger
- DefaultLogger‚Äã
  - constructor‚Äã
  - setDefaultContext‚Äã
  - error‚Äã
  - warn‚Äã
  - info‚Äã
  - verbose‚Äã
  - debug‚Äã

The default logger, which logs to the console (stdout) with optional timestamps. Since this logger is part of the default Vendure configuration, you do not need to specify it explicitly in your server config. You would only need to specify it if you wish to change the log level (which defaults to LogLevel.Info) or remove the timestamp.

**Examples:**

Example 1 (ts):
```ts
import { DefaultLogger, LogLevel, VendureConfig } from '@vendure/core';export config: VendureConfig = {    // ...    logger: new DefaultLogger({ level: LogLevel.Debug, timestamp: false }),}
```

Example 2 (ts):
```ts
class DefaultLogger implements VendureLogger {    constructor(options?: { level?: LogLevel; timestamp?: boolean })    setDefaultContext(defaultContext: string) => ;    error(message: string, context?: string, trace?: string | undefined) => void;    warn(message: string, context?: string) => void;    info(message: string, context?: string) => void;    verbose(message: string, context?: string) => void;    debug(message: string, context?: string) => void;}
```

---

## BaseDetailComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/base-detail-component/

**Contents:**
- BaseDetailComponent
- BaseDetailComponent‚Äã
  - entity$‚Äã
  - availableLanguages$‚Äã
  - languageCode$‚Äã
  - languageCode‚Äã
  - isNew$‚Äã
  - id‚Äã
  - detailForm‚Äã
  - destroy$‚Äã

A base class for entity detail views. It should be used in conjunction with the BaseEntityResolver.

**Examples:**

Example 1 (ts):
```ts
@Component({  selector: 'app-my-entity',  templateUrl: './my-entity.component.html',  styleUrls: ['./my-entity.component.scss'],  changeDetection: ChangeDetectionStrategy.OnPush,})export class GlobalSettingsComponent extends BaseDetailComponent<MyEntityFragment> implements OnInit {  detailForm: FormGroup;  constructor(    router: Router,    route: ActivatedRoute,    serverConfigService: ServerConfigService,    protected dataService: DataService,    private formBuilder: FormBuilder,  ) {    super(route, router, serverConfigService, dataService);    this.detailForm = this.formBuilder.group({    
...
```

Example 2 (ts):
```ts
class BaseDetailComponent<Entity extends { id: string; updatedAt?: string }> implements DeactivateAware {    entity$: Observable<Entity>;    availableLanguages$: Observable<LanguageCode[]>;    languageCode$: Observable<LanguageCode>;    languageCode: LanguageCode;    isNew$: Observable<boolean>;    id: string;    abstract detailForm: UntypedFormGroup;    protected destroy$ = new Subject<void>();    constructor(route: ActivatedRoute, router: Router, serverConfigService: ServerConfigService, dataService: DataService, permissionsService: PermissionsService)    init() => ;    setUpStreams() => ;  
...
```

---

## HasPermissionPipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/has-permission-pipe

**Contents:**
- HasPermissionPipe
- HasPermissionPipe‚Äã
  - constructor‚Äã
  - transform‚Äã
  - ngOnDestroy‚Äã

A pipe which checks the provided permission against all the permissions of the current user. Returns true if the current user has that permission.

**Examples:**

Example 1 (html):
```html
<button [disabled]="!('UpdateCatalog' | hasPermission)">Save Changes</button>
```

Example 2 (ts):
```ts
class HasPermissionPipe implements PipeTransform, OnDestroy {    constructor(permissionsService: PermissionsService, changeDetectorRef: ChangeDetectorRef)    transform(input: string | string[]) => any;    ngOnDestroy() => ;}
```

---

## SlugInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/slug-input

**Contents:**
- SlugInput
- SlugInput‚Äã
  - props‚Äã

A component for generating and displaying slugs based on a watched field. The component watches a source field for changes, debounces the input, and generates a unique slug via the Admin API. The slug is only auto-generated when it's empty. For existing slugs, a regenerate button allows manual regeneration. The input is readonly by default but can be made editable with a toggle button.

**Examples:**

Example 1 (tsx):
```tsx
// In a TranslatableFormFieldWrapper context with translatable field<SlugInput    {...field}    entityName="Product"    fieldName="slug"    watchFieldName="name" // Automatically resolves to "translations.X.name"    entityId={productId}/>// In a TranslatableFormFieldWrapper context with non-translatable field<SlugInput    {...field}    entityName="Product"    fieldName="slug"    watchFieldName="enabled" // Uses "enabled" directly (base entity field)    entityId={productId}/>// For non-translatable entities<SlugInput    {...field}    entityName="Channel"    fieldName="code"    watchFieldName="n
...
```

Example 2 (ts):
```ts
function SlugInput(props: SlugInputProps): void
```

---

## AuthOptions

**URL:** https://docs.vendure.io/reference/typescript-api/auth/auth-options/

**Contents:**
- AuthOptions
- AuthOptions‚Äã
  - disableAuth‚Äã
  - tokenMethod‚Äã
  - cookieOptions‚Äã
  - authTokenHeaderKey‚Äã
  - sessionDuration‚Äã
  - sessionCacheStrategy‚Äã
  - sessionCacheTTL‚Äã
  - requireVerification‚Äã

The AuthOptions define how authentication and authorization is managed.

Disable authentication & permissions checks. NEVER set the to true in production. It exists only to aid certain development tasks.

Sets the method by which the session token is delivered and read.

Note that if the bearer method is used, Vendure will automatically expose the configured authTokenHeaderKey in the server's CORS configuration (adding Access-Control-Expose-Headers: vendure-auth-token by default).

From v1.2.0 it is possible to specify both methods as a tuple: ['cookie', 'bearer'].

Options related to the handling of cookies when using the 'cookie' tokenMethod.

Sets the header property which will be used to send the auth token when using the 'bearer' method.

Session duration, i.e. the time which must elapse from the last authenticated request after which the user must re-authenticate.

If passed as a number should represent milliseconds and if passed as a string describes a time span per zeit/ms. Eg: 60, '2 days', '10h', '7d'

This strategy defines how sessions will be cached. By default, since v3.1.0, sessions are cached using the underlying cache strategy defined in the SystemOptions.cacheStrategy.

The "time to live" of a given item in the session cache. This determines the length of time that a cache entry is kept before being considered "stale" and being replaced with fresh data taken from the database.

If passed as a number should represent seconds and if passed as a string describes a time span per zeit/ms. Eg: 60, '2 days', '10h', '7d'

Determines whether new User accounts require verification of their email address.

If set to "true", the customer will be required to verify their email address using a verification token they receive in their email. See the registerCustomerAccount mutation for more details on the verification behavior.

Sets the length of time that a verification token is valid for, after which the verification token must be refreshed.

If passed as a number should represent milliseconds and if passed as a string describes a time span per zeit/ms. Eg: 60, '2 days', '10h', '7d'

Configures the credentials to be used to create a superadmin

Configures one or more AuthenticationStrategies which defines how authentication is handled in the Shop API.

Configures one or more AuthenticationStrategy which defines how authentication is handled in the Admin API.

Allows custom Permissions to be defined, which can be used to restrict access to custom GraphQL resolvers and REST controllers. This is done using the `PermissionDefinition` class in conjunction with the `@Allow` decorator.

Custom permissions are defined using `PermissionDefinition` and then added to this array. For example:

```typescript
import { PermissionDefinition } from '@vendure/core';

const syncPermission = new PermissionDefinition({
  name: 'SyncInventory',
  description: 'Allows syncing stock levels via Admin API'
});

const config: VendureConfig = {
  authOptions: {
    customPermissions: [syncPermission],
  },
}
```

Then use the permission in your resolver:

```typescript
@Resolver()
export class InventorySyncResolver {
  @Allow(syncPermission.Permission)
  @Mutation()
  syncInventory() {
    // Only users with the SyncInventory permission can execute this
  }
}
```

**Examples:**

Example 1 (ts):
```ts
interface AuthOptions {    disableAuth?: boolean;    tokenMethod?: 'cookie' | 'bearer' | ReadonlyArray<'cookie' | 'bearer'>;    cookieOptions?: CookieOptions;    authTokenHeaderKey?: string;    sessionDuration?: string | number;    sessionCacheStrategy?: SessionCacheStrategy;    sessionCacheTTL?: string | number;    requireVerification?: boolean;    verificationTokenDuration?: string | number;    superadminCredentials?: SuperadminCredentials;    shopAuthenticationStrategy?: AuthenticationStrategy[];    adminAuthenticationStrategy?: AuthenticationStrategy[];    customPermissions?: PermissionDef
...
```

Example 2 (ts):
```ts
{  passwordValidationStrategy: new DefaultPasswordValidationStrategy({    // Minimum eight characters, at least one letter and one number    regexp: /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/,  }),}
```

---

## RegisterMethodHooks

**URL:** https://docs.vendure.io/reference/core-plugins/telemetry-plugin/register-method-hooks

**Contents:**
- RegisterMethodHooks
- registerMethodHooks‚Äã
  - target‚Äã
  - hooks‚Äã

Allows you to register hooks for a specific method of an instrumented class. These hooks allow extra telemetry actions to be performed on the method.

They can then be passed to the TelemetryPlugin via the TelemetryPluginOptions.

**Examples:**

Example 1 (typescript):
```typescript
const productServiceHooks = registerMethodHooks(ProductService, {    findOne: {        // This will be called before the method is executed        pre: ({ args: [ctx, productId], span }) => {            span.setAttribute('productId', productId);        },        // This will be called after the method is executed        post: ({ result, span }) => {            span.setAttribute('found', !!result);        },    },});
```

Example 2 (ts):
```ts
function registerMethodHooks<T>(target: Type<T>, hooks: MethodHooksForType<T>): MethodHookConfig<T>
```

---

## CustomerService

**URL:** https://docs.vendure.io/reference/typescript-api/services/customer-service

**Contents:**
- CustomerService
- CustomerService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findOneByUserId‚Äã
  - findAddressesByCustomerId‚Äã
  - getCustomerGroups‚Äã
  - create‚Äã
  - update‚Äã

Contains methods relating to Customer entities.

Returns the Customer entity associated with the given userId, if one exists. Setting filterOnChannel to true will limit the results to Customers which are assigned to the current active Channel only.

Returns all Address entities associated with the specified Customer.

Returns a list of all CustomerGroup entities.

Creates a new Customer, including creation of a new User with the special customer Role.

If the password argument is specified, the Customer will be immediately verified. If not, then an AccountRegistrationEvent is published, so that the customer can have their email address verified and set their password in a later step using the verifyCustomerEmailAddress() method.

This method is intended to be used in admin-created Customer flows.

Registers a new Customer account with the NativeAuthenticationStrategy and starts the email verification flow (unless AuthOptions requireVerification is set to false) by publishing an AccountRegistrationEvent.

This method is intended to be used in storefront Customer-creation flows.

Refreshes a stale email address verification token by generating a new one and publishing a AccountRegistrationEvent.

Given a valid verification token which has been published in an AccountRegistrationEvent, this method is used to set the Customer as verified as part of the account registration flow.

Publishes a new PasswordResetEvent for the given email address. This event creates a token which can be used in the resetPassword() method.

Given a valid password reset token created by a call to the requestPasswordReset() method, this method will change the Customer's password to that given as the password argument.

Publishes a IdentifierChangeRequestEvent for the given User. This event contains a token which is then used in the updateEmailAddress() method to change the email address of the User & Customer.

Given a valid email update token published in a IdentifierChangeRequestEvent, this method will update the Customer & User email address.

For guest checkouts, we assume that a matching email address is the same customer.

Creates a new Address for the given Customer.

If the Customer associated with the given Order does not yet have any Addresses, this method will create new Address(es) based on the Order's shipping & billing addresses.

**Examples:**

Example 1 (ts):
```ts
class CustomerService {    constructor(connection: TransactionalConnection, configService: ConfigService, userService: UserService, countryService: CountryService, listQueryBuilder: ListQueryBuilder, eventBus: EventBus, historyService: HistoryService, channelService: ChannelService, customFieldRelationService: CustomFieldRelationService, translator: TranslatorService)    findAll(ctx: RequestContext, options: ListQueryOptions<Customer> | undefined, relations: RelationPaths<Customer> = []) => Promise<PaginatedList<Customer>>;    findOne(ctx: RequestContext, id: ID, relations: RelationPaths<Custo
...
```

---

## Promotion Condition

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/promotion-condition

**Contents:**
- Promotion Condition
- PromotionCondition‚Äã
  - priorityValue‚Äã
  - code‚Äã
  - constructor‚Äã
  - check‚Äã
- PromotionConditionConfig‚Äã
  - code‚Äã
  - check‚Äã
  - priorityValue‚Äã

PromotionConditions are used to create Promotions. The purpose of a PromotionCondition is to check the order against a particular predicate function (the check function) and to return true if the Order satisfies the condition, or false if it does not.

Used to determine the order of application of multiple Promotions on the same Order. See the Promotion priorityScore field for more information.

This is the function which contains the conditional logic to decide whether a Promotion should apply to an Order. See CheckPromotionConditionFn.

This object is used to configure a PromotionCondition.

A function which checks whether or not a given Order satisfies the PromotionCondition.

The function should return either a boolean or and plain object type:

**Examples:**

Example 1 (ts):
```ts
class PromotionCondition<T extends ConfigArgs = ConfigArgs, C extends string = string, R extends CheckPromotionConditionResult = any> extends ConfigurableOperationDef<T> {    readonly priorityValue: number;    code: C    constructor(config: PromotionConditionConfig<T, C, R>)    check(ctx: RequestContext, order: Order, args: ConfigArg[], promotion: Promotion) => Promise<R>;}
```

Example 2 (ts):
```ts
interface PromotionConditionConfig<T extends ConfigArgs, C extends string, R extends CheckPromotionConditionResult> extends ConfigurableOperationDefOptions<T> {    code: C;    check: CheckPromotionConditionFn<T, R>;    priorityValue?: number;}
```

Example 3 (ts):
```ts
type CheckPromotionConditionFn<T extends ConfigArgs, R extends CheckPromotionConditionResult> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    promotion: Promotion,) => R | Promise<R>
```

---

## Money

**URL:** https://docs.vendure.io/reference/typescript-api/money/

**Contents:**
- Money
- üìÑÔ∏è BigIntMoneyStrategy
- üìÑÔ∏è DefaultMoneyStrategy
- üìÑÔ∏è Money Decorator
- üìÑÔ∏è MoneyStrategy
- üìÑÔ∏è RoundMoney

---

## ProcessContext

**URL:** https://docs.vendure.io/reference/typescript-api/common/process-context

**Contents:**
- ProcessContext
- ProcessContext‚Äã
  - isServer‚Äã
  - isWorker‚Äã

The ProcessContext can be injected into your providers & modules in order to know whether it is being executed in the context of the main Vendure server or the worker.

**Examples:**

Example 1 (ts):
```ts
import { Injectable, OnApplicationBootstrap } from '@nestjs/common';import { ProcessContext } from '@vendure/core';@Injectable()export class MyService implements OnApplicationBootstrap {  constructor(private processContext: ProcessContext) {}  onApplicationBootstrap() {    if (this.processContext.isServer) {      // code which will only execute when running in      // the server process    }  }}
```

Example 2 (ts):
```ts
class ProcessContext {    isServer: boolean    isWorker: boolean}
```

---

## CalculatedPropertySubscriber

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/calculated-property-subscriber

**Contents:**
- CalculatedPropertySubscriber
- CalculatedPropertySubscriber‚Äã
  - afterLoad‚Äã
  - afterInsert‚Äã

**Examples:**

Example 1 (ts):
```ts
class CalculatedPropertySubscriber implements EntitySubscriberInterface {    afterLoad(event: any) => ;    afterInsert(event: InsertEvent<any>) => Promise<any> | void;}
```

---

## FulfillmentTransitionData

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/fulfillment-transition-data

**Contents:**
- FulfillmentTransitionData
- FulfillmentTransitionData‚Äã
  - ctx‚Äã
  - orders‚Äã
  - fulfillment‚Äã

The data which is passed to the state transition handler of the FulfillmentStateMachine.

**Examples:**

Example 1 (ts):
```ts
interface FulfillmentTransitionData {    ctx: RequestContext;    orders: Order[];    fulfillment: Fulfillment;}
```

---

## PriceCalculationResult

**URL:** https://docs.vendure.io/reference/typescript-api/common/price-calculation-result

**Contents:**
- PriceCalculationResult
- PriceCalculationResult‚Äã
  - price‚Äã
  - priceIncludesTax‚Äã

The result of the price calculation from the ProductVariantPriceCalculationStrategy or the OrderItemPriceCalculationStrategy.

**Examples:**

Example 1 (ts):
```ts
type PriceCalculationResult = {    price: number;    priceIncludesTax: boolean;}
```

---

## ProductOptionService

**URL:** https://docs.vendure.io/reference/typescript-api/services/product-option-service

**Contents:**
- ProductOptionService
- ProductOptionService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã

Contains methods relating to ProductOption entities.

Deletes a ProductOption.

**Examples:**

Example 1 (ts):
```ts
class ProductOptionService {    constructor(connection: TransactionalConnection, translatableSaver: TranslatableSaver, customFieldRelationService: CustomFieldRelationService, eventBus: EventBus, translator: TranslatorService, listQueryBuilder: ListQueryBuilder)    findAll(ctx: RequestContext, options?: ListQueryOptions<ProductOption>, groupId?: ID, relations?: RelationPaths<ProductOption>) => Promise<PaginatedList<Translated<ProductOption>>>;    findOne(ctx: RequestContext, id: ID, relations?: RelationPaths<ProductOption>) => Promise<Translated<ProductOption> | undefined>;    create(ctx: Reque
...
```

---

## Mutations

**URL:** https://docs.vendure.io/reference/graphql-api/shop/mutations

**Contents:**
- Mutations
- addItemToOrder‚Äã
- addItemsToOrder‚Äã
- addPaymentToOrder‚Äã
- adjustOrderLine‚Äã
- applyCouponCode‚Äã
- authenticate‚Äã
- createCustomerAddress‚Äã
- deleteCustomerAddress‚Äã
- login‚Äã

---

## InMemoryJobBufferStorageStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/in-memory-job-buffer-storage-strategy

**Contents:**
- InMemoryJobBufferStorageStrategy
- InMemoryJobBufferStorageStrategy‚Äã
  - bufferStorage‚Äã
  - add‚Äã
  - bufferSize‚Äã
  - flush‚Äã

A JobBufferStorageStrategy which keeps the buffered jobs in memory. Should not be used in production, since it will lose data in the event of the server stopping.

Instead, use the DefaultJobQueuePlugin with the useDatabaseForBuffer: true option set, or the BullMQJobQueuePlugin or another custom strategy with persistent storage.

**Examples:**

Example 1 (ts):
```ts
class InMemoryJobBufferStorageStrategy implements JobBufferStorageStrategy {    protected bufferStorage = new Map<string, Set<Job>>();    add(bufferId: string, job: Job) => Promise<Job>;    bufferSize(bufferIds?: string[]) => Promise<{ [bufferId: string]: number }>;    flush(bufferIds?: string[]) => Promise<{ [bufferId: string]: Job[] }>;}
```

---

## DetailComponentWithResolver

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/detail-component-with-resolver

**Contents:**
- DetailComponentWithResolver
- detailComponentWithResolver‚Äã
  - config‚Äã

A helper function for creating tabs that point to a TypedBaseDetailComponent. This takes care of the route resolver parts so that the detail component automatically has access to the correct resolved detail data.

**Examples:**

Example 1 (ts):
```ts
@NgModule({  imports: [ReviewsSharedModule],  declarations: [/* ... *\/],  providers: [    registerPageTab({      location: 'product-detail',      tab: 'Specs',      route: 'specs',      component: detailComponentWithResolver({        component: ProductSpecDetailComponent,        query: GetProductSpecsDocument,        entityKey: 'spec',      }),    }),  ],})export class ProductSpecsUiExtensionModule {}
```

Example 2 (ts):
```ts
function detailComponentWithResolver<T extends TypedDocumentNode<any, { id: string }>, Field extends keyof ResultOf<T>, R extends Field>(config: {    component: Type<TypedBaseDetailComponent<T, Field>>;    query: T;    entityKey: R;    getBreadcrumbs?: (entity: ResultOf<T>[R]) => BreadcrumbValue;    variables?: T extends TypedDocumentNode<any, infer V> ? Omit<V, 'id'> : never;}): void
```

---

## GetSuperadminContext

**URL:** https://docs.vendure.io/reference/typescript-api/testing/get-superadmin-context

**Contents:**
- GetSuperadminContext
- getSuperadminContext‚Äã
  - app‚Äã

Creates a RequestContext configured for the default Channel with the activeUser set as the superadmin user. Useful for populating data.

**Examples:**

Example 1 (ts):
```ts
function getSuperadminContext(app: INestApplicationContext): Promise<RequestContext>
```

---

## UseRichTextEditor

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-rich-text-editor

**Contents:**
- UseRichTextEditor
- useRichTextEditor‚Äã

Provides access to the ProseMirror (rich text editor) instance.

**Examples:**

Example 1 (ts):
```ts
import { useRichTextEditor } from '@vendure/admin-ui/react';import React from 'react';export function Component() {    const { ref, editor } = useRichTextEditor({       attributes: { class: '' },       onTextInput: (text) => console.log(text),       isReadOnly: () => false,    });    return <div className="w-full" ref={ref} />}
```

---

## Asset

**URL:** https://docs.vendure.io/reference/typescript-api/entities/asset/

**Contents:**
- Asset
- Asset‚Äã
  - constructor‚Äã
  - name‚Äã
  - type‚Äã
  - mimeType‚Äã
  - width‚Äã
  - height‚Äã
  - fileSize‚Äã
  - source‚Äã

An Asset represents a file such as an image which can be associated with certain other entities such as Products.

Extends: VendureEntity

Implements: Taggable, ChannelAware, HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Asset extends VendureEntity implements Taggable, ChannelAware, HasCustomFields {    constructor(input?: DeepPartial<Asset>)    @Column() name: string;    @Column('varchar') type: AssetType;    @Column() mimeType: string;    @Column({ default: 0 }) width: number;    @Column({ default: 0 }) height: number;    @Column() fileSize: number;    @Column() source: string;    @Column() preview: string;    @Column('simple-json', { nullable: true })    focalPoint?: { x: number; y: number };    @ManyToMany(type => Tag)    @JoinTable()    tags: Tag[];    @ManyToMany(type => Channel)    @JoinTable()   
...
```

---

## VendurePluginMetadata

**URL:** https://docs.vendure.io/reference/typescript-api/plugin/vendure-plugin-metadata

**Contents:**
- VendurePluginMetadata
- VendurePluginMetadata‚Äã
  - configuration‚Äã
  - shopApiExtensions‚Äã
  - adminApiExtensions‚Äã
  - entities‚Äã
  - dashboard‚Äã
  - compatibility‚Äã
- APIExtensionDefinition‚Äã
  - schema‚Äã

Defines the metadata of a Vendure plugin. This interface is an superset of the Nestjs ModuleMetadata (which allows the definition of imports, exports, providers and controllers), which means that any Nestjs Module is a valid Vendure plugin. In addition, the VendurePluginMetadata allows the definition of extra properties specific to Vendure.

A function which can modify the VendureConfig object before the server bootstraps.

The plugin may extend the default Vendure GraphQL shop api by providing extended schema definitions and any required resolvers.

The plugin may extend the default Vendure GraphQL admin api by providing extended schema definitions and any required resolvers.

The plugin may define custom TypeORM database entities.

The plugin should define a valid semver version string to indicate which versions of Vendure core it is compatible with. Attempting to use a plugin with an incompatible version of Vendure will result in an error and the server will be unable to bootstrap.

If a plugin does not define this property, a message will be logged on bootstrap that the plugin is not guaranteed to be compatible with the current version of Vendure.

To effectively disable this check for a plugin, you can use an overly-permissive string such as >0.0.0.

Since Vendure v3.1.0, it is possible to ignore compatibility errors for specific plugins by passing the ignoreCompatibilityErrorsForPlugins option to the bootstrap function.

An object which allows a plugin to extend the Vendure GraphQL API.

Extensions to the schema. Passes the current schema as an optional argument, allowing the extension to be based on the existing schema.

An array of resolvers for the schema extensions. Should be defined as Nestjs GraphQL resolver classes, i.e. using the Nest @Resolver() decorator etc.

A map of GraphQL scalar types which should correspond to any custom scalars defined in your schema. Read more about defining custom scalars in the Apollo Server Custom Scalars docs

This method is called before the app bootstraps and should be used to perform any needed modifications to the VendureConfig.

**Examples:**

Example 1 (ts):
```ts
interface VendurePluginMetadata extends ModuleMetadata {    configuration?: PluginConfigurationFn;    shopApiExtensions?: APIExtensionDefinition;    adminApiExtensions?: APIExtensionDefinition;    entities?: Array<Type<any>> | (() => Array<Type<any>>);    dashboard?: DashboardExtension;    compatibility?: string;}
```

Example 2 (ts):
```ts
compatibility: '^3.0.0'
```

Example 3 (ts):
```ts
interface APIExtensionDefinition {    schema?: DocumentNode | ((schema?: GraphQLSchema) => DocumentNode | undefined);    resolvers?: Array<Type<any>> | (() => Array<Type<any>>);    scalars?: Record<string, GraphQLScalarType> | (() => Record<string, GraphQLScalarType>);}
```

Example 4 (ts):
```ts
const schema = gql`extend type SearchReindexResponse {    timeTaken: Int!    indexedItemCount: Int!}`;
```

---

## RequestContextService

**URL:** https://docs.vendure.io/reference/typescript-api/request/request-context-service

**Contents:**
- RequestContextService
- RequestContextService‚Äã
  - create‚Äã
  - fromRequest‚Äã

Creates new RequestContext instances.

Creates a RequestContext based on the config provided. This can be useful when interacting with services outside the request-response cycle, for example in stand-alone scripts or in worker jobs.

Creates a new RequestContext based on an Express request object. This is used internally in the API layer by the AuthGuard, and creates the RequestContext which is then passed to all resolvers & controllers.

**Examples:**

Example 1 (ts):
```ts
class RequestContextService {    create(config: {        req?: Request;        apiType: ApiType;        channelOrToken?: Channel | string;        languageCode?: LanguageCode;        currencyCode?: CurrencyCode;        user?: User;        activeOrderId?: ID;    }) => Promise<RequestContext>;    fromRequest(req: Request, info?: GraphQLResolveInfo, requiredPermissions?: Permission[], session?: CachedSession) => Promise<RequestContext>;}
```

---

## Custom Detail Components

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-detail-components/

**Contents:**
- Custom Detail Components
- üìÑÔ∏è CustomDetailComponentConfig
- üìÑÔ∏è CustomDetailComponentLocationId
- üìÑÔ∏è CustomDetailComponent
- üìÑÔ∏è RegisterCustomDetailComponent

CustomDetailComponentConfig

CustomDetailComponentLocationId

CustomDetailComponent

registerCustomDetailComponent

---

## JsonCompatible

**URL:** https://docs.vendure.io/reference/typescript-api/common/json-compatible

**Contents:**
- JsonCompatible
- JsonCompatible‚Äã

A type representing JSON-compatible values. From https://github.com/microsoft/TypeScript/issues/1897#issuecomment-580962081

**Examples:**

Example 1 (ts):
```ts
type JsonCompatible<T> = {    [P in keyof T]: T[P] extends Json        ? T[P]        : Pick<T, P> extends Required<Pick<T, P>>          ? never          : JsonCompatible<T[P]>;}
```

---

## Alerts

**URL:** https://docs.vendure.io/guides/extending-the-dashboard/alerts/

**Contents:**
- Alerts
- Creating a Custom Alert‚Äã
  - Example: Pending Search Index Updates Alert‚Äã

Alerts allow you to display important information to the administrators who use the Dashboard. They can be used to notify users about pending tasks, system status, or any conditions that require attention.

This API is further documented in the DashboardAlertDefinition API reference

To create a custom alert, you need to define a DashboardAlertDefinition object and register it with the Dashboard.

Let's take the built-in "pending search index updates" as an example, since it demonstrates many features you'll also use in your own custom alerts.

This alert is the registered in your dashboard extensions extry point:

**Examples:**

Example 1 (tsx):
```tsx
import { graphql } from '@/gql';import { api, DashboardAlertDefinition } from '@vendure/dashboard';import { toast } from 'sonner';const pendingSearchIndexUpdatesDocument = graphql(`    query GetPendingSearchIndexUpdates {        pendingSearchIndexUpdates    }`);export const runPendingSearchIndexUpdatesDocument = graphql(`    mutation RunPendingSearchIndexUpdates {        runPendingSearchIndexUpdates {            success        }    }`);export const pendingSearchIndexUpdatesAlert: DashboardAlertDefinition<number> = {    id: 'pending-search-index-updates',    // The `check` function is called pe
...
```

Example 2 (ts):
```ts
import { defineDashboardExtension } from '@vendure/dashboard';import { pendingSearchIndexUpdatesAlert } from './pending-updates-alert';defineDashboardExtension({    alerts: [pendingSearchIndexUpdatesAlert],});
```

---

## ProductOption

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product-option

**Contents:**
- ProductOption
- ProductOption‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - code‚Äã
  - translations‚Äã
  - group‚Äã
  - groupId‚Äã
  - productVariants‚Äã

A ProductOption is used to differentiate ProductVariants from one another.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class ProductOption extends VendureEntity implements Translatable, HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<ProductOption>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    @Column() code: string;    @OneToMany(type => ProductOptionTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<ProductOption>>;    @Index()    @ManyToOne(type => ProductOptionGroup, group => group.options)    group: ProductOptionGroup;    @EntityId()    groupId: ID;    @ManyToMany(type => ProductVariant, v
...
```

---

## VENDURE_VERSION

**URL:** https://docs.vendure.io/reference/typescript-api/common/vendure_version

**Contents:**
- VENDURE_VERSION
- VENDURE_VERSION‚Äã

A constant which holds the current version of the Vendure core. You can use this when your code needs to know the version of Vendure which is running.

**Examples:**

Example 1 (ts):
```ts
import { VENDURE_VERSION } from '@vendure/core';console.log('Vendure version:', VENDURE_VERSION);
```

---

## AffixedInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/affixed-input

**Contents:**
- AffixedInput
- AffixedInput‚Äã
  - props‚Äã

A component for displaying an input with a prefix and/or a suffix.

**Examples:**

Example 1 (tsx):
```tsx
<AffixedInput    {...field}    type="number"    suffix="%"    value={field.value}    onChange={e => field.onChange(e.target.valueAsNumber)}/>
```

Example 2 (ts):
```ts
function AffixedInput(props: Readonly<AffixedInputProps>): void
```

---

## Errors

**URL:** https://docs.vendure.io/reference/typescript-api/errors/

**Contents:**
- Errors
- üìÑÔ∏è ErrorHandlerStrategy
- üìÑÔ∏è ErrorResultUnion
- üìÑÔ∏è Error Types
- üìÑÔ∏è I18nError
- üìÑÔ∏è IsGraphQlErrorResult

---

## ShippingCalculator

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-calculator/

**Contents:**
- ShippingCalculator
- ShippingCalculator‚Äã
  - constructor‚Äã
- ShippingCalculationResult‚Äã
  - price‚Äã
  - priceIncludesTax‚Äã
  - taxRate‚Äã
  - metadata‚Äã
- CalculateShippingFn‚Äã

The ShippingCalculator is used by a ShippingMethod to calculate the price of shipping on a given Order.

The return value of the CalculateShippingFn.

The shipping price without any taxes.

Whether or not the given price already includes taxes.

The tax rate applied to the shipping price.

Arbitrary metadata may be returned from the calculation function. This can be used e.g. to return data on estimated delivery times or any other data which may be needed in the storefront application when listing eligible shipping methods.

A function which implements the specific shipping calculation logic. It takes an Order and an arguments object and should return the shipping price as an integer in cents.

Should return a ShippingCalculationResult object.

**Examples:**

Example 1 (ts):
```ts
const flatRateCalculator = new ShippingCalculator({  code: 'flat-rate-calculator',  description: [{ languageCode: LanguageCode.en, value: 'Default Flat-Rate Shipping Calculator' }],  args: {    rate: {      type: 'int',      ui: { component: 'currency-form-input' },    },    taxRate: {      type: 'int',      ui: { component: 'number-form-input', suffix: '%' },    },  },  calculate: (ctx, order, args) => {    return {      price: args.rate,      taxRate: args.taxRate,      priceIncludesTax: ctx.channel.pricesIncludeTax,    };  },});
```

Example 2 (ts):
```ts
class ShippingCalculator<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: ShippingCalculatorConfig<T>)}
```

Example 3 (ts):
```ts
interface ShippingCalculationResult {    price: number;    priceIncludesTax: boolean;    taxRate: number;    metadata?: Record<string, any>;}
```

Example 4 (ts):
```ts
type CalculateShippingFn<T extends ConfigArgs> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    method: ShippingMethod,) => CalculateShippingFnResult
```

---

## DefaultAssetImportStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/default-asset-import-strategy

**Contents:**
- DefaultAssetImportStrategy
- DefaultAssetImportStrategy‚Äã
  - constructor‚Äã
  - init‚Äã
  - getStreamFromPath‚Äã

The DefaultAssetImportStrategy is able to import paths from the local filesystem (taking into account the importExportOptions.importAssetsDir setting) as well as remote http/https urls.

**Examples:**

Example 1 (ts):
```ts
class DefaultAssetImportStrategy implements AssetImportStrategy {    constructor(options?: {            retryDelayMs: number;            retryCount: number;        })    init(injector: Injector) => ;    getStreamFromPath(assetPath: string) => ;}
```

---

## BigIntMoneyStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/money/big-int-money-strategy

**Contents:**
- BigIntMoneyStrategy
- BigIntMoneyStrategy‚Äã
  - moneyColumnOptions‚Äã
  - precision‚Äã
  - round‚Äã

A MoneyStrategy that stores monetary values as a bigint type in the database, which allows values up to ~9 quadrillion to be stored (limited by JavaScript's MAX_SAFE_INTEGER limit).

This strategy also slightly differs in the way rounding is performed, with rounding being done after multiplying the unit price, rather than before (as is the case with the DefaultMoneyStrategy.

**Examples:**

Example 1 (ts):
```ts
class BigIntMoneyStrategy implements MoneyStrategy {    readonly moneyColumnOptions: ColumnOptions = {        type: 'bigint',        transformer: {            to: (entityValue: number) => {                return entityValue;            },            from: (databaseValue: string): number => {                if (databaseValue == null) {                    return databaseValue;                }                const intVal = Number.parseInt(databaseValue, 10);                if (!Number.isSafeInteger(intVal)) {                    Logger.warn(`Monetary value ${databaseValue} is not a safe integer!`
...
```

---

## CustomFieldType

**URL:** https://docs.vendure.io/reference/typescript-api/custom-fields/custom-field-type

**Contents:**
- CustomFieldType
- CustomFieldType‚Äã

A data type for a custom field. The CustomFieldType determines the data types used in the generated database columns and GraphQL fields as follows (key: m = MySQL, p = Postgres, s = SQLite):

Additionally, the CustomFieldType also dictates which configuration options are available for that custom field.

**Examples:**

Example 1 (ts):
```ts
type CustomFieldType = | 'string'    | 'localeString'    | 'int'    | 'float'    | 'boolean'    | 'datetime'    | 'relation'    | 'text'    | 'localeText'    | 'struct'
```

---

## CustomerHistoryEntryComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-history-entry-components/customer-history-entry-component

**Contents:**
- CustomerHistoryEntryComponent
- CustomerHistoryEntryComponent‚Äã
  - customer‚Äã

Used to implement a HistoryEntryComponent which requires access to the Customer object.

**Examples:**

Example 1 (ts):
```ts
interface CustomerHistoryEntryComponent extends HistoryEntryComponent {    customer: CustomerFragment;}
```

---

## UseFormControl

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-form-control

**Contents:**
- UseFormControl
- useFormControl‚Äã

Provides access to the current FormControl value and a method to update the value.

**Examples:**

Example 1 (ts):
```ts
import { useFormControl, ReactFormInputProps } from '@vendure/admin-ui/react';import React from 'react';export function ReactNumberInput({ readonly }: ReactFormInputProps) {    const { value, setFormValue } = useFormControl();    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {        setFormValue(val);    };    return (        <div>            <input readOnly={readonly} type="number" onChange={handleChange} value={value} />        </div>    );}
```

Example 2 (ts):
```ts
function useFormControl(): void
```

---

## AssetPreviewStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/assets/asset-preview-strategy

**Contents:**
- AssetPreviewStrategy
- AssetPreviewStrategy‚Äã
  - generatePreviewImage‚Äã

The AssetPreviewStrategy determines how preview images for assets are created. For image assets, this would usually typically involve resizing to sensible dimensions. Other file types could be previewed in a variety of ways, e.g.:

This is configured via the assetOptions.assetPreviewStrategy property of your VendureConfig.

**Examples:**

Example 1 (ts):
```ts
interface AssetPreviewStrategy extends InjectableStrategy {    generatePreviewImage(ctx: RequestContext, mimeType: string, data: Buffer): Promise<Buffer>;}
```

---

## TelemetryPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/telemetry-plugin/

**Contents:**
- TelemetryPlugin
- TelemetryPlugin‚Äã
- Installation‚Äã
- Configuration‚Äã
- Preloading the SDK‚Äã
  - options‚Äã
  - constructor‚Äã
  - init‚Äã

The TelemetryPlugin is used to instrument the Vendure application and collect telemetry data using OpenTelemetry.

For a complete guide to setting up and working with Open Telemetry, see the Implementing Open Telemetry guide.

The plugin is configured via the TelemetryPlugin.init() method. This method accepts an options object which defines the OtelLogger options and method hooks.

In order to use the OpenTelemetry SDK, you must preload it before the Vendure server is started. This is done by using the --require flag when starting the server with a custom preload script.

Create a file named instrumentation.ts in the root of your project and add the following code:

The server would then be started with the following command:

or for development with ts-node:

**Examples:**

Example 1 (text):
```text
npm install @vendure/telemetry-plugin
```

Example 2 (ts):
```ts
import { VendureConfig } from '@vendure/core';import { TelemetryPlugin, registerMethodHooks } from '@vendure/telemetry-plugin';export const config: VendureConfig = {  // ...  plugins: [    TelemetryPlugin.init({      loggerOptions: {        // Log to the console at the verbose level        console: LogLevel.Verbose,      },    }),  ],};
```

Example 3 (ts):
```ts
import { OTLPLogExporter } from '@opentelemetry/exporter-logs-otlp-proto';import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';import { BatchLogRecordProcessor } from '@opentelemetry/sdk-logs';import { NodeSDK } from '@opentelemetry/sdk-node';import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';import { getSdkConfiguration } from '@vendure/telemetry-plugin/preload';// In this example we are using Loki as the OTLP endpoint for loggingprocess.env.OTEL_EXPORTER_OTLP_ENDPOINT = 'http://localhost:3100/otlp';process.env.OTEL_LOGS_EXPORTER = 'otlp';process.env.OTE
...
```

Example 4 (bash):
```bash
node --require ./dist/instrumentation.js ./dist/server.js
```

---

## AdminUiConfig

**URL:** https://docs.vendure.io/reference/typescript-api/common/admin-ui/admin-ui-config

**Contents:**
- AdminUiConfig
- AdminUiConfig‚Äã
  - apiHost‚Äã
  - apiPort‚Äã
  - adminApiPath‚Äã
  - tokenMethod‚Äã
  - authTokenHeaderKey‚Äã
  - channelTokenKey‚Äã
  - defaultLanguage‚Äã
  - defaultLocale‚Äã

This interface describes JSON config file (vendure-ui-config.json) used by the Admin UI. The values are loaded at run-time by the Admin UI app, and allow core configuration to be managed without the need to re-build the application.

The hostname of the Vendure server which the admin UI will be making API calls to. If set to "auto", the Admin UI app will determine the hostname from the current location (i.e. window.location.hostname).

The port of the Vendure server which the admin UI will be making API calls to. If set to "auto", the Admin UI app will determine the port from the current location (i.e. window.location.port).

The path to the GraphQL Admin API.

Whether to use cookies or bearer tokens to track sessions. Should match the setting of in the server's tokenMethod config option.

The header used when using the 'bearer' auth method. Should match the setting of the server's authOptions.authTokenHeaderKey config option.

The name of the header which contains the channel token. Should match the setting of the server's apiOptions.channelTokenKey config option.

The default language for the Admin UI. Must be one of the items specified in the availableLanguages property.

The default locale for the Admin UI. The locale affects the formatting of currencies & dates. Must be one of the items specified in the availableLocales property.

If not set, the browser default locale will be used.

An array of languages for which translations exist for the Admin UI.

An array of locales to be used on Admin UI.

If you are using an external AuthenticationStrategy for the Admin API, you can configure a custom URL for the login page with this option. On logging out or redirecting an unauthenticated user, the Admin UI app will redirect the user to this URL rather than the default username/password screen.

The custom brand name.

Option to hide vendure branding.

Option to hide version.

A url of a custom image to be used on the login screen, to override the images provided by Vendure's login image server.

Allows you to provide default reasons for a refund or cancellation. This will be used in the refund/cancel dialog. The values can be literal strings (e.g. "Not in stock") or translation tokens (see Adding Admin UI Translations).

**Examples:**

Example 1 (ts):
```ts
interface AdminUiConfig {    apiHost: string | 'auto';    apiPort: number | 'auto';    adminApiPath: string;    tokenMethod: 'cookie' | 'bearer';    authTokenHeaderKey: string;    channelTokenKey: string;    defaultLanguage: LanguageCode;    defaultLocale?: string;    availableLanguages: LanguageCode[];    availableLocales: string[];    loginUrl?: string;    brand?: string;    hideVendureBranding?: boolean;    hideVersion?: boolean;    loginImageUrl?: string;    cancellationReasons?: string[];}
```

---

## DataTableCellComponent

**URL:** https://docs.vendure.io/reference/dashboard/list-views/data-table-cell-component

**Contents:**
- DataTableCellComponent
- DataTableCellComponent‚Äã

This type is used to define re-usable components that can render a table cell in a DataTable.

**Examples:**

Example 1 (ts):
```ts
import { DataTableCellComponent } from '@vendure/dashboard';type CustomerCellData = {    customer: {        id: string;        firstName: string;        lastName: string;    } | null;};export const CustomerCell: DataTableCellComponent<CustomerCellData> = ({ row }) => {    const value = row.original.customer;    if (!value) {        return null;    }    return (        <Button asChild variant="ghost">            <Link to={`/customers/${value.id}`}>                {value.firstName} {value.lastName}            </Link>        </Button>    );};
```

Example 2 (ts):
```ts
type DataTableCellComponent<T> = <Data extends T>(context: CellContext<Data, any>) => any
```

---

## AddActionBarDropdownMenuItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/add-action-bar-dropdown-menu-item/

**Contents:**
- AddActionBarDropdownMenuItem
- addActionBarDropdownMenuItem‚Äã
  - config‚Äã

Adds a dropdown menu item to the ActionBar at the top right of each list or detail view. The locationId can be determined by pressing ctrl + u when running the Admin UI in dev mode.

**Examples:**

Example 1 (ts):
```ts
import { addActionBarDropdownMenuItem } from '@vendure/admin-ui/core';export default [    addActionBarDropdownMenuItem({        id: 'print-invoice',        label: 'Print Invoice',        locationId: 'order-detail',        routerLink: ['/extensions/invoicing'],    }),];
```

Example 2 (ts):
```ts
function addActionBarDropdownMenuItem(config: ActionBarDropdownMenuItem): void
```

---

## OrderOptions

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-options/

**Contents:**
- OrderOptions
- OrderOptions‚Äã
  - orderItemsLimit‚Äã
  - orderLineItemsLimit‚Äã
  - orderItemPriceCalculationStrategy‚Äã
  - process‚Äã
  - stockAllocationStrategy‚Äã
  - mergeStrategy‚Äã
  - checkoutMergeStrategy‚Äã
  - orderCodeStrategy‚Äã

The maximum number of individual items allowed in a single order. This option exists to prevent excessive resource usage when dealing with very large orders. For example, if an order contains a million items, then any operations on that order (modifying a quantity, adding or removing an item) will require Vendure to loop through all million items to perform price calculations against active promotions and taxes. This can have a significant performance impact for very large values.

Attempting to exceed this limit will cause Vendure to throw a OrderLimitError.

The maximum number of items allowed per order line. This option is an addition on the orderItemsLimit for more granular control. Note orderItemsLimit is still important in order to prevent excessive resource usage.

Attempting to exceed this limit will cause Vendure to throw a OrderLimitError`.

Defines the logic used to calculate the unit price of an OrderLine when adding an item to an Order.

Allows the definition of custom states and transition logic for the order process state machine. Takes an array of objects implementing the OrderProcess interface.

Determines the point of the order process at which stock gets allocated.

Defines the strategy used to merge a guest Order and an existing Order when signing in.

Defines the strategy used to merge a guest Order and an existing Order when signing in as part of the checkout flow.

Allows a user-defined function to create Order codes. This can be useful when integrating with existing systems. By default, Vendure will generate a 16-character alphanumeric string.

Note: when using a custom function for Order codes, bear in mind the database limit for string types (e.g. 255 chars for a varchar field in MySQL), and also the need for codes to be unique.

Defines the strategy used to check if and how an Order may be retrieved via the orderByCode query.

The default strategy permits permanent access to the Customer owning the Order and anyone within 2 hours after placing the Order.

Defines how we handle the situation where an item exists in an Order, and then later on another is added but in the meantime the price of the ProductVariant has changed.

By default, the latest price will be used. Any price changes resulting from using a newer price will be reflected in the GraphQL OrderLine.unitPrice[WithTax]ChangeSinceAdded field.

Defines the point of the order process at which the Order is set as "placed".

Defines the strategy used to determine the active Order when performing Shop API operations such as `activeOrder` and `addItemToOrder`. The strategy uses the active Session as its foundation mechanism.

Since v1.9.0, you can define multiple strategies which will be checked in order, using the first one that returns an Order.

**Examples:**

Example 1 (ts):
```ts
interface OrderOptions {    orderItemsLimit?: number;    orderLineItemsLimit?: number;    orderItemPriceCalculationStrategy?: OrderItemPriceCalculationStrategy;    process?: Array<OrderProcess<any>>;    stockAllocationStrategy?: StockAllocationStrategy;    mergeStrategy?: OrderMergeStrategy;    checkoutMergeStrategy?: OrderMergeStrategy;    orderCodeStrategy?: OrderCodeStrategy;    orderByCodeAccessStrategy?: OrderByCodeAccessStrategy;    changedPriceHandlingStrategy?: ChangedPriceHandlingStrategy;    orderPlacedStrategy?: OrderPlacedStrategy;    activeOrderStrategy?: ActiveOrderStrategy<any> 
...
```

---

## AuthService

**URL:** https://docs.vendure.io/reference/typescript-api/services/auth-service

**Contents:**
- AuthService
- AuthService‚Äã
  - constructor‚Äã
  - authenticate‚Äã
  - createAuthenticatedSessionForUser‚Äã
  - verifyUserPassword‚Äã
  - destroyAuthenticatedSession‚Äã

Contains methods relating to Session, AuthenticatedSession & AnonymousSession entities.

Authenticates a user's credentials and if okay, creates a new AuthenticatedSession.

Verify the provided password against the one we have for the given user. Requires the NativeAuthenticationStrategy to be configured.

Deletes all sessions for the user associated with the given session token.

**Examples:**

Example 1 (ts):
```ts
class AuthService {    constructor(connection: TransactionalConnection, configService: ConfigService, sessionService: SessionService, eventBus: EventBus)    authenticate(ctx: RequestContext, apiType: ApiType, authenticationMethod: string, authenticationData: any) => Promise<AuthenticatedSession | InvalidCredentialsError | NotVerifiedError>;    createAuthenticatedSessionForUser(ctx: RequestContext, user: User, authenticationStrategyName: string) => Promise<AuthenticatedSession | NotVerifiedError>;    verifyUserPassword(ctx: RequestContext, userId: ID, password: string) => Promise<boolean | Inva
...
```

---

## TestDbInitializer

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-db-initializer

**Contents:**
- TestDbInitializer
- TestDbInitializer‚Äã
  - init‚Äã
  - populate‚Äã
  - destroy‚Äã

Defines how the e2e TestService sets up a particular DB to run a single test suite. The @vendure/testing package ships with initializers for sql.js, MySQL & Postgres.

Custom initializers can be created by implementing this interface and registering it with the registerInitializer function:

Responsible for creating a database for the current test suite. Typically, this method will:

Execute the populateFn to populate your database.

Clean up any resources used during the init() phase (i.e. close open DB connections)

**Examples:**

Example 1 (ts):
```ts
export class CockroachDbInitializer implements TestDbInitializer<CockroachConnectionOptions> {    // database-specific implementation goes here}registerInitializer('cockroachdb', new CockroachDbInitializer());
```

Example 2 (ts):
```ts
interface TestDbInitializer<T extends BaseConnectionOptions> {    init(testFileName: string, connectionOptions: T): Promise<T>;    populate(populateFn: () => Promise<void>): Promise<void>;    destroy(): void | Promise<void>;}
```

---

## JobState

**URL:** https://docs.vendure.io/reference/typescript-api/common/job-state

**Contents:**
- JobState
- JobState‚Äã

The state of a Job in the JobQueue

**Examples:**

Example 1 (ts):
```ts
enum JobState {    CANCELLED = 'CANCELLED'    COMPLETED = 'COMPLETED'    FAILED = 'FAILED'    PENDING = 'PENDING'    RETRYING = 'RETRYING'    RUNNING = 'RUNNING'}
```

---

## HistoryEntry

**URL:** https://docs.vendure.io/reference/typescript-api/entities/history-entry

**Contents:**
- HistoryEntry
- HistoryEntry‚Äã
  - administrator‚Äã
  - type‚Äã
  - isPublic‚Äã
  - data‚Äã
  - customFields‚Äã

An abstract entity representing an entry in the history of an Order (OrderHistoryEntry) or a Customer (CustomerHistoryEntry).

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class HistoryEntry extends VendureEntity implements HasCustomFields {    @Index()    @ManyToOne(type => Administrator)    administrator?: Administrator;    @Column({ nullable: false, type: 'varchar' })    readonly type: HistoryEntryType;    @Column()    isPublic: boolean;    @Column('simple-json')    data: any;    @Column(type => CustomHistoryEntryFields)    customFields: CustomHistoryEntryFields;}
```

---

## Promotion

**URL:** https://docs.vendure.io/reference/typescript-api/entities/promotion

**Contents:**
- Promotion
- Promotion‚Äã
  - type‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - startsAt‚Äã
  - endsAt‚Äã
  - couponCode‚Äã
  - perCustomerUsageLimit‚Äã
  - usageLimit‚Äã

A Promotion is used to define a set of conditions under which promotions actions (typically discounts) will be applied to an Order.

Each assigned PromotionCondition is checked against the Order, and if they all return true, then each assign PromotionItemAction / PromotionLineAction / PromotionOrderAction / PromotionShippingAction is applied to the Order.

Extends: AdjustmentSource

Implements: ChannelAware, SoftDeletable, HasCustomFields, Translatable

The PriorityScore is used to determine the sequence in which multiple promotions are tested on a given order. A higher number moves the Promotion towards the end of the sequence.

The score is derived from the sum of the priorityValues of the PromotionConditions and PromotionActions comprising this Promotion.

An example illustrating the need for a priority is this:

Consider 2 Promotions, 1) buy 1 get one free and 2) 10% off when order total is over $50. If Promotion 2 is evaluated prior to Promotion 1, then it can trigger the 10% discount even if the subsequent application of Promotion 1 brings the order total down to way below $50.

**Examples:**

Example 1 (ts):
```ts
class Promotion extends AdjustmentSource implements ChannelAware, SoftDeletable, HasCustomFields, Translatable {    type = AdjustmentType.PROMOTION;    constructor(input?: DeepPartial<Promotion> & {            promotionConditions?: Array<PromotionCondition<any>>;            promotionActions?: Array<PromotionAction<any>>;        })    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column({ type: Date, nullable: true })    startsAt: Date | null;    @Column({ type: Date, nullable: true })    endsAt: Date | null;    @Column({ nullable: true })    couponCode: string;    @Col
...
```

---

## Product

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product/

**Contents:**
- Product
- Product‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - slug‚Äã
  - description‚Äã
  - enabled‚Äã
  - featuredAsset‚Äã
  - featuredAssetId‚Äã

A Product contains one or more ProductVariants and serves as a container for those variants, providing an overall name, description etc.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class Product extends VendureEntity implements Translatable, HasCustomFields, ChannelAware, SoftDeletable {    constructor(input?: DeepPartial<Product>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    slug: LocaleString;    description: LocaleString;    @Column({ default: true })    enabled: boolean;    @Index()    @ManyToOne(type => Asset, asset => asset.featuredInProducts, { onDelete: 'SET NULL' })    featuredAsset: Asset;    @EntityId({ nullable: true })    featuredAssetId: ID;    @OneToMany(type => ProductAsset, productAsset => productAsset.p
...
```

---

## CollectionFilter

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/collection-filter/

**Contents:**
- CollectionFilter
- CollectionFilter‚Äã
  - constructor‚Äã
  - apply‚Äã

A CollectionFilter defines a rule which can be used to associate ProductVariants with a Collection. The filtering is done by defining the apply() function, which receives a TypeORM QueryBuilder object to which clauses may be added.

Creating a CollectionFilter is considered an advanced Vendure topic. For more insight into how they work, study the default collection filters

Here's a simple example of a custom CollectionFilter:

**Examples:**

Example 1 (ts):
```ts
import { CollectionFilter, LanguageCode } from '@vendure/core';export const skuCollectionFilter = new CollectionFilter({  args: {    // The `args` object defines the user-configurable arguments    // which will get passed to the filter's `apply()` function.    sku: {      type: 'string',      label: [{ languageCode: LanguageCode.en, value: 'SKU' }],      description: [        {          languageCode: LanguageCode.en,          value: 'Matches any product variants with SKUs containing this value',        },      ],    },  },  code: 'variant-sku-filter',  description: [{ languageCode: LanguageCod
...
```

Example 2 (ts):
```ts
class CollectionFilter<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: CollectionFilterConfig<T>)    apply(qb: SelectQueryBuilder<ProductVariant>, args: ConfigArg[]) => SelectQueryBuilder<ProductVariant>;}
```

---

## Shipping

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/

**Contents:**
- Shipping
- üìÑÔ∏è CheckShippingEligibilityCheckerFn
- üìÑÔ∏è DefaultShippingLineAssignmentStrategy
- üìÑÔ∏è ShippingCalculator
- üìÑÔ∏è ShippingEligibilityCheckerConfig
- üìÑÔ∏è ShippingEligibilityChecker
- üìÑÔ∏è ShippingLineAssignmentStrategy
- üìÑÔ∏è ShippingOptions
- üìÑÔ∏è ShouldRunCheckFn

CheckShippingEligibilityCheckerFn

DefaultShippingLineAssignmentStrategy

ShippingEligibilityCheckerConfig

ShippingEligibilityChecker

ShippingLineAssignmentStrategy

---

## Order

**URL:** https://docs.vendure.io/reference/typescript-api/entities/order/

**Contents:**
- Order
- Order‚Äã
  - constructor‚Äã
  - type‚Äã
  - sellerOrders‚Äã
  - aggregateOrder‚Äã
  - aggregateOrderId‚Äã
  - code‚Äã
  - state‚Äã
  - active‚Äã

An Order is created whenever a Customer adds an item to the cart. It contains all the information required to fulfill an order: which ProductVariants in what quantities; the shipping address and price; any applicable promotions; payments etc.

An Order exists in a well-defined state according to the OrderState type. A state machine is used to govern the transition from one state to another.

Extends: VendureEntity

Implements: ChannelAware, HasCustomFields

A unique code for the Order, generated according to the OrderCodeStrategy. This should be used as an order reference for Customers, rather than the Order's id.

Whether the Order is considered "active", meaning that the Customer can still make changes to it and has not yet completed the checkout process. This is governed by the OrderPlacedStrategy.

The date & time that the Order was placed, i.e. the Customer completed the checkout and the Order is no longer "active". This is governed by the OrderPlacedStrategy.

Surcharges are arbitrary modifications to the Order total which are neither ProductVariants nor discounts resulting from applied Promotions. For example, one-off discounts based on customer interaction, or surcharges based on payment methods.

An array of all coupon codes applied to the Order.

Promotions applied to the order. Only gets populated after the payment process has completed, i.e. the Order is no longer active.

The subTotal is the total of all OrderLines in the Order. This figure also includes any Order-level discounts which have been prorated (proportionally distributed) amongst the OrderItems. To get a total of all OrderLines which does not account for prorated discounts, use the sum of OrderLine's discountedLinePrice values.

Same as subTotal, but inclusive of tax.

The shipping charges applied to this order.

The total of all the shippingLines.

Equal to subTotal plus shipping

The final payable amount. Equal to subTotalWithTax plus shippingWithTax.

A summary of the taxes being applied to this Order.

**Examples:**

Example 1 (ts):
```ts
class Order extends VendureEntity implements ChannelAware, HasCustomFields {    constructor(input?: DeepPartial<Order>)    @Column('varchar', { default: OrderType.Regular })    type: OrderType;    @OneToMany(type => Order, sellerOrder => sellerOrder.aggregateOrder)    sellerOrders: Order[];    @Index()    @ManyToOne(type => Order, aggregateOrder => aggregateOrder.sellerOrders)    aggregateOrder?: Order;    @EntityId({ nullable: true })    aggregateOrderId?: ID;    @Column()    @Index({ unique: true })    code: string;    @Column('varchar') state: OrderState;    @Column({ default: true })    ac
...
```

---

## Product

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product

**Contents:**
- Product
- Product‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - slug‚Äã
  - description‚Äã
  - enabled‚Äã
  - featuredAsset‚Äã
  - featuredAssetId‚Äã

A Product contains one or more ProductVariants and serves as a container for those variants, providing an overall name, description etc.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class Product extends VendureEntity implements Translatable, HasCustomFields, ChannelAware, SoftDeletable {    constructor(input?: DeepPartial<Product>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    slug: LocaleString;    description: LocaleString;    @Column({ default: true })    enabled: boolean;    @Index()    @ManyToOne(type => Asset, asset => asset.featuredInProducts, { onDelete: 'SET NULL' })    featuredAsset: Asset;    @EntityId({ nullable: true })    featuredAssetId: ID;    @OneToMany(type => ProductAsset, productAsset => productAsset.p
...
```

---

## DurationPipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/duration-pipe

**Contents:**
- DurationPipe
- DurationPipe‚Äã
  - constructor‚Äã
  - transform‚Äã

Displays a number of milliseconds in a more human-readable format, e.g. "12ms", "33s", "2:03m"

**Examples:**

Example 1 (ts):
```ts
{{ timeInMs | duration }}
```

Example 2 (ts):
```ts
class DurationPipe implements PipeTransform {    constructor(i18nService: I18nService)    transform(value: number) => string;}
```

---

## DefaultPasswordValidationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/default-password-validation-strategy

**Contents:**
- DefaultPasswordValidationStrategy
- DefaultPasswordValidationStrategy‚Äã
  - constructor‚Äã
  - validate‚Äã

The DefaultPasswordValidationStrategy allows you to specify a minimum length and/or a regular expression to match passwords against. The default maxLength is 72.

TODO: By default, the minLength will be set to 4. This is rather permissive and is only this way in order to reduce the risk of backward-compatibility breaks. In the next major version this default will be made more strict.

**Examples:**

Example 1 (ts):
```ts
class DefaultPasswordValidationStrategy implements PasswordValidationStrategy {    constructor(options: { minLength?: number; maxLength?: number; regexp?: RegExp })    validate(ctx: RequestContext, password: string) => boolean | string;}
```

---

## OrderPlacedStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-placed-strategy

**Contents:**
- OrderPlacedStrategy
- OrderPlacedStrategy‚Äã
  - shouldSetAsPlaced‚Äã

This strategy is responsible for deciding at which stage in the order process the Order will be set as "placed" (i.e. the Customer has checked out, and next it must be processed by an Administrator).

By default, the order is set as "placed" when it transitions from 'ArrangingPayment' to either 'PaymentAuthorized' or 'PaymentSettled'.

This is configured via the orderOptions.orderPlacedStrategy property of your VendureConfig.

This method is called whenever an active Order transitions from one state to another. If it resolves to true, then the Order will be set as "placed", which means:

**Examples:**

Example 1 (ts):
```ts
interface OrderPlacedStrategy extends InjectableStrategy {    shouldSetAsPlaced(        ctx: RequestContext,        fromState: OrderState,        toState: OrderState,        order: Order,    ): boolean | Promise<boolean>;}
```

---

## OrderHistoryEntryComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-history-entry-components/order-history-entry-component

**Contents:**
- OrderHistoryEntryComponent
- OrderHistoryEntryComponent‚Äã
  - order‚Äã

Used to implement a HistoryEntryComponent which requires access to the Order object.

**Examples:**

Example 1 (ts):
```ts
interface OrderHistoryEntryComponent extends HistoryEntryComponent {    order: OrderDetailFragment;}
```

---

## AssetNamingStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/assets/asset-naming-strategy

**Contents:**
- AssetNamingStrategy
- AssetNamingStrategy‚Äã
  - generateSourceFileName‚Äã
  - generatePreviewFileName‚Äã

The AssetNamingStrategy determines how file names are generated based on the uploaded source file name, as well as how to handle naming conflicts.

This is configured via the assetOptions.assetNamingStrategy property of your VendureConfig.

Given the original file name of the uploaded file, generate a file name to be stored on the server. Operations like normalization and time-stamping can be performed in this method.

The output will be checked for a naming conflict with an existing file. If a conflict exists, this method will be invoked again with the second argument passed in and a new, unique file name should then be generated. This process will repeat until a unique file name has been returned.

Given the source file name generated in the generateSourceFileName method, this method should generate the file name of the preview image.

The same mechanism of checking for conflicts is used as described above.

**Examples:**

Example 1 (ts):
```ts
interface AssetNamingStrategy extends InjectableStrategy {    generateSourceFileName(ctx: RequestContext, originalFileName: string, conflictFileName?: string): string;    generatePreviewFileName(ctx: RequestContext, sourceFileName: string, conflictFileName?: string): string;}
```

---

## Session

**URL:** https://docs.vendure.io/reference/typescript-api/entities/session

**Contents:**
- Session
- Session‚Äã
  - token‚Äã
  - expires‚Äã
  - invalidated‚Äã
  - activeOrderId‚Äã
  - activeOrder‚Äã
  - activeChannelId‚Äã
  - activeChannel‚Äã
  - customFields‚Äã

A Session is created when a user makes a request to restricted API operations. A Session can be an AnonymousSession in the case of un-authenticated users, otherwise it is an AuthenticatedSession.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Session extends VendureEntity implements HasCustomFields {    @Index({ unique: true })    @Column()    token: string;    @Column() expires: Date;    @Column() invalidated: boolean;    @EntityId({ nullable: true })    activeOrderId?: ID;    @Index()    @ManyToOne(type => Order)    activeOrder: Order | null;    @EntityId({ nullable: true })    activeChannelId?: ID;    @Index()    @ManyToOne(type => Channel)    activeChannel: Channel | null;    @Column(type => CustomSessionFields)    customFields: CustomSessionFields;}
```

---

## RedisCachePlugin

**URL:** https://docs.vendure.io/reference/typescript-api/cache/redis-cache-plugin/

**Contents:**
- RedisCachePlugin
- RedisCachePlugin‚Äã
  - options‚Äã
  - init‚Äã
- RedisCachePluginInitOptions‚Äã
  - maxItemSizeInBytes‚Äã
  - namespace‚Äã
  - redisOptions‚Äã

This plugin provides a Redis-based RedisCacheStrategy which stores cached items in a Redis instance. This is a high-performance cache strategy which is suitable for production use, and is a drop-in replacement for the DefaultCachePlugin.

Note: To use this plugin, you need to manually install the ioredis package:

Configuration options for the RedisCachePlugin.

The maximum size of a single cache item in bytes. If a cache item exceeds this size, it will not be stored and an error will be logged.

The namespace to use for all keys stored in Redis. This can be useful if you are sharing a Redis instance between multiple applications.

Options to pass to the ioredis Redis client.

**Examples:**

Example 1 (shell):
```shell
npm install ioredis@^5.3.2
```

Example 2 (ts):
```ts
class RedisCachePlugin {    static options: RedisCachePluginInitOptions = {        maxItemSizeInBytes: 128_000,        redisOptions: {},        namespace: 'vendure-cache',    };    init(options: RedisCachePluginInitOptions) => ;}
```

Example 3 (ts):
```ts
interface RedisCachePluginInitOptions {    maxItemSizeInBytes?: number;    namespace?: string;    redisOptions?: import('ioredis').RedisOptions;}
```

---

## Input Objects

**URL:** https://docs.vendure.io/reference/graphql-api/admin/input-types

**Contents:**
- Input Objects
- AddItemInput‚Äã
- AddItemToDraftOrderInput‚Äã
- AddNoteToCustomerInput‚Äã
- AddNoteToOrderInput‚Äã
- AdjustDraftOrderLineInput‚Äã
- AdministratorFilterParameter‚Äã
- AdministratorListOptions‚Äã
- AdministratorPaymentInput‚Äã
- AdministratorRefundInput‚Äã

---

## Action Bar

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/

**Contents:**
- Action Bar
- üìÑÔ∏è ActionBarContext
- üìÑÔ∏è ActionBarDropdownMenuItem
- üìÑÔ∏è ActionBarItem
- üìÑÔ∏è ActionBarLocationId
- üìÑÔ∏è AddActionBarDropdownMenuItem
- üìÑÔ∏è AddActionBarItem
- üìÑÔ∏è PageLocationId
- üìÑÔ∏è RouterLinkDefinition

ActionBarDropdownMenuItem

addActionBarDropdownMenuItem

---

## Transport Options

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/transport-options

**Contents:**
- Transport Options
- EmailTransportOptions‚Äã
- SMTPTransportOptions‚Äã
  - type‚Äã
  - logging‚Äã
- SESTransportOptions‚Äã
  - type‚Äã
- SendmailTransportOptions‚Äã
  - type‚Äã
  - path‚Äã

A union of all the possible transport options for sending emails.

The SMTP transport options of Nodemailer

If true, uses the configured VendureLogger to log messages from Nodemailer as it interacts with the SMTP server.

The SES transport options of Nodemailer

See Nodemailers's SES docs for more details

Uses the local Sendmail program to send the email.

Outputs the email as an HTML file for development purposes.

Does nothing with the generated email. Intended for use in testing where we don't care about the email transport, or when using a custom EmailSender which does not require transport options.

Forwards the raw GeneratedEmailContext object to a provided callback, for use in testing.

Callback to be invoked when an email would be sent.

**Examples:**

Example 1 (ts):
```ts
type EmailTransportOptions = | SMTPTransportOptions    | SendmailTransportOptions    | FileTransportOptions    | NoopTransportOptions    | SESTransportOptions    | TestingTransportOptions
```

Example 2 (ts):
```ts
interface SMTPTransportOptions extends SMTPTransport.Options {    type: 'smtp';    logging?: boolean;}
```

Example 3 (ts):
```ts
import { SES, SendRawEmailCommand } from '@aws-sdk/client-ses' const ses = new SES({    apiVersion: '2010-12-01',    region: 'eu-central-1',    credentials: {        accessKeyId: process.env.SES_ACCESS_KEY || '',        secretAccessKey: process.env.SES_SECRET_KEY || '',    }, }) const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    EmailPlugin.init({      handler: defaultEmailHandlers,      templateLoader: new FileBasedTemplateLoader(path.join(__dirname, '../static/email/templates')),      transport: {        type: 'ses',        SES: { ses, aws: 
...
```

Example 4 (ts):
```ts
interface SESTransportOptions extends SESTransport.Options {    type: 'ses';}
```

---

## CollectionFilter

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/collection-filter

**Contents:**
- CollectionFilter
- CollectionFilter‚Äã
  - constructor‚Äã
  - apply‚Äã

A CollectionFilter defines a rule which can be used to associate ProductVariants with a Collection. The filtering is done by defining the apply() function, which receives a TypeORM QueryBuilder object to which clauses may be added.

Creating a CollectionFilter is considered an advanced Vendure topic. For more insight into how they work, study the default collection filters

Here's a simple example of a custom CollectionFilter:

**Examples:**

Example 1 (ts):
```ts
import { CollectionFilter, LanguageCode } from '@vendure/core';export const skuCollectionFilter = new CollectionFilter({  args: {    // The `args` object defines the user-configurable arguments    // which will get passed to the filter's `apply()` function.    sku: {      type: 'string',      label: [{ languageCode: LanguageCode.en, value: 'SKU' }],      description: [        {          languageCode: LanguageCode.en,          value: 'Matches any product variants with SKUs containing this value',        },      ],    },  },  code: 'variant-sku-filter',  description: [{ languageCode: LanguageCod
...
```

Example 2 (ts):
```ts
class CollectionFilter<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: CollectionFilterConfig<T>)    apply(qb: SelectQueryBuilder<ProductVariant>, args: ConfigArg[]) => SelectQueryBuilder<ProductVariant>;}
```

---

## RefundState

**URL:** https://docs.vendure.io/reference/typescript-api/payment/refund-state

**Contents:**
- RefundState
- RefundState‚Äã

These are the default states of the refund process.

**Examples:**

Example 1 (ts):
```ts
type RefundState = 'Pending' | 'Settled' | 'Failed' | keyof CustomRefundStates | keyof RefundStates
```

---

## Ctx Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/ctx-decorator

**Contents:**
- Ctx Decorator
- Ctx‚Äã

Resolver param decorator which extracts the RequestContext from the incoming request object.

**Examples:**

Example 1 (ts):
```ts
@Query() getAdministrators(@Ctx() ctx: RequestContext) {     // ... }
```

---

## GetSdkConfiguration

**URL:** https://docs.vendure.io/reference/core-plugins/telemetry-plugin/get-sdk-configuration

**Contents:**
- GetSdkConfiguration
- getSdkConfiguration‚Äã
  - options‚Äã
- SdkConfigurationOptions‚Äã
  - logToConsole‚Äã
  - config‚Äã

Creates a configuration object for the OpenTelemetry Node SDK. This is used to set up a custom preload script which must be run before the main Vendure server is loaded by means of the Node.js --require flag.

This would them be run as:

Options for configuring the OpenTelemetry Node SDK.

When set to true, the SDK will log spans to the console instead of sending them to an exporter. This should just be used for debugging purposes.

The configuration object for the OpenTelemetry Node SDK.

**Examples:**

Example 1 (ts):
```ts
// instrumentation.tsimport { OTLPLogExporter } from '@opentelemetry/exporter-logs-otlp-proto';import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';import { BatchLogRecordProcessor } from '@opentelemetry/sdk-logs';import { NodeSDK } from '@opentelemetry/sdk-node';import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';import { getSdkConfiguration } from '@vendure/telemetry-plugin/preload';process.env.OTEL_EXPORTER_OTLP_ENDPOINT = 'http://localhost:3100/otlp';process.env.OTEL_LOGS_EXPORTER = 'otlp';process.env.OTEL_RESOURCE_ATTRIBUTES = 'service.name=vendure-de
...
```

Example 2 (bash):
```bash
node --require ./dist/instrumentation.js ./dist/server.js
```

Example 3 (ts):
```ts
function getSdkConfiguration(options?: SdkConfigurationOptions): Partial<NodeSDKConfiguration>
```

Example 4 (ts):
```ts
interface SdkConfigurationOptions {    logToConsole?: boolean;    config: Partial<NodeSDKConfiguration>;}
```

---

## AdminUiAppConfig

**URL:** https://docs.vendure.io/reference/typescript-api/common/admin-ui/admin-ui-app-config

**Contents:**
- AdminUiAppConfig
- AdminUiAppConfig‚Äã
  - path‚Äã
  - route‚Äã
  - compile‚Äã

Configures the path to a custom-build of the Admin UI app.

The path to the compiled admin UI app files. If not specified, an internal default build is used. This path should contain the vendure-ui-config.json file, index.html, the compiled js bundles etc.

Specifies the url route to the Admin UI app.

The function which will be invoked to start the app compilation process.

**Examples:**

Example 1 (ts):
```ts
interface AdminUiAppConfig {    path: string;    route?: string;    compile?: () => Promise<void>;}
```

---

## CustomerHistoryEntry

**URL:** https://docs.vendure.io/reference/typescript-api/entities/customer-history-entry

**Contents:**
- CustomerHistoryEntry
- CustomerHistoryEntry‚Äã
  - constructor‚Äã
  - customer‚Äã

Represents an event in the history of a particular Customer.

**Examples:**

Example 1 (ts):
```ts
class CustomerHistoryEntry extends HistoryEntry {    constructor(input: DeepPartial<CustomerHistoryEntry>)    @Index()    @ManyToOne(type => Customer, { onDelete: 'CASCADE' })    customer: Customer;}
```

---

## RegisterFormInputComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-input-components/register-form-input-component

**Contents:**
- RegisterFormInputComponent
- registerFormInputComponent‚Äã
  - id‚Äã
  - component‚Äã

Registers a custom FormInputComponent which can be used to control the argument inputs of a ConfigurableOperationDef (e.g. CollectionFilter, ShippingMethod etc.) or for a custom field.

This input component can then be used in a custom field:

or with an argument of a ConfigurableOperationDef:

**Examples:**

Example 1 (ts):
```ts
import { registerFormInputComponent } from '@vendure/admin-ui/core';export default [    registerFormInputComponent('my-custom-input', MyCustomFieldControl),];
```

Example 2 (ts):
```ts
import { VendureConfig } from '@vendure/core';const config: VendureConfig = {  // ...  customFields: {    ProductVariant: [      {        name: 'rrp',        type: 'int',        ui: { component: 'my-custom-input' },      },    ]  }}
```

Example 3 (ts):
```ts
args: {  rrp: { type: 'int', ui: { component: 'my-custom-input' } },}
```

Example 4 (ts):
```ts
function registerFormInputComponent(id: string, component: Type<FormInputComponent>): void
```

---

## ProductVariantPrice

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product-variant-price

**Contents:**
- ProductVariantPrice
- ProductVariantPrice‚Äã
  - constructor‚Äã
  - price‚Äã
  - channelId‚Äã
  - currencyCode‚Äã
  - variant‚Äã
  - customFields‚Äã

A ProductVariantPrice is a Channel-specific price for a ProductVariant. For every Channel to which a ProductVariant is assigned, there will be a corresponding ProductVariantPrice entity.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class ProductVariantPrice extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<ProductVariantPrice>)    @Money() price: number;    @EntityId({ nullable: true }) channelId: ID;    @Column('varchar')    currencyCode: CurrencyCode;    @Index()    @ManyToOne(type => ProductVariant, variant => variant.productVariantPrices, { onDelete: 'CASCADE' })    variant: ProductVariant;    @Column(type => CustomProductVariantPriceFields)    customFields: CustomProductVariantPriceFields;}
```

---

## OrderTestingService

**URL:** https://docs.vendure.io/reference/typescript-api/services/order-testing-service

**Contents:**
- OrderTestingService
- OrderTestingService‚Äã
  - constructor‚Äã
  - testShippingMethod‚Äã
  - testEligibleShippingMethods‚Äã

This service is responsible for creating temporary mock Orders against which tests can be run, such as testing a ShippingMethod or Promotion.

Runs a given ShippingMethod configuration against a mock Order to test for eligibility and resulting price.

Tests all available ShippingMethods against a mock Order and return those which are eligible. This is intended to simulate a call to the eligibleShippingMethods query of the Shop API.

**Examples:**

Example 1 (ts):
```ts
class OrderTestingService {    constructor(connection: TransactionalConnection, orderCalculator: OrderCalculator, shippingCalculator: ShippingCalculator, configArgService: ConfigArgService, configService: ConfigService, productPriceApplicator: ProductPriceApplicator, translator: TranslatorService)    testShippingMethod(ctx: RequestContext, input: TestShippingMethodInput) => Promise<TestShippingMethodResult>;    testEligibleShippingMethods(ctx: RequestContext, input: TestEligibleShippingMethodsInput) => Promise<ShippingMethodQuote[]>;}
```

---

## ActionBarDropdownMenuItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/action-bar-dropdown-menu-item

**Contents:**
- ActionBarDropdownMenuItem
- ActionBarDropdownMenuItem‚Äã
  - id‚Äã
  - label‚Äã
  - locationId‚Äã
  - hasDivider‚Äã
  - buttonState‚Äã
  - onClick‚Äã
  - routerLink‚Äã
  - icon‚Äã

A dropdown menu item in the ActionBar area at the top of one of the list or detail views.

A unique identifier for the item.

The label to display for the item. This can also be a translation token, e.g. invoice-plugin.print-invoice.

The location in the UI where this menu item should be displayed.

Whether to render a divider above this item.

A function which returns an observable of the button state, allowing you to dynamically enable/disable or show/hide the button.

An optional icon to display with the item. The icon should be a valid shape name from the Clarity Icons set.

Control the display of this item based on the user permissions. Note: if you attempt to pass a PermissionDefinition object, you will get a compilation error. Instead, pass the plain string version. For example, if the permission is defined as:

then the generated permission strings will be:

**Examples:**

Example 1 (ts):
```ts
interface ActionBarDropdownMenuItem {    id: string;    label: string;    locationId: ActionBarLocationId;    hasDivider?: boolean;    buttonState?: (context: ActionBarContext) => Observable<ActionBarButtonState | undefined>;    onClick?: (event: MouseEvent, context: ActionBarContext) => void;    routerLink?: RouterLinkDefinition;    icon?: string;    requiresPermission?: string | string[];}
```

Example 2 (ts):
```ts
export const MyPermission = new PermissionDefinition('ProductReview');
```

---

## ReactCustomDetailComponentConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/react-custom-detail-component-config

**Contents:**
- ReactCustomDetailComponentConfig
- ReactCustomDetailComponentConfig‚Äã
  - locationId‚Äã
  - component‚Äã
  - props‚Äã

Configures a React-based component to be placed in a detail page in the given location.

The id of the detail page location in which to place the component.

The React component to render.

Optional props to pass to the React component.

**Examples:**

Example 1 (ts):
```ts
interface ReactCustomDetailComponentConfig {    locationId: CustomDetailComponentLocationId;    component: ElementType;    props?: Record<string, any>;}
```

---

## GenerateMigration

**URL:** https://docs.vendure.io/reference/typescript-api/migration/generate-migration/

**Contents:**
- GenerateMigration
- generateMigration‚Äã
  - userConfig‚Äã
  - options‚Äã

Generates a new migration file based on any schema changes (e.g. adding or removing CustomFields). See TypeORM migration docs for more information about the underlying migration mechanism.

**Examples:**

Example 1 (ts):
```ts
function generateMigration(userConfig: Partial<VendureConfig>, options: MigrationOptions): Promise<string | undefined>
```

---

## Widgets

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/widgets

**Contents:**
- Widgets
- DashboardWidgetDefinition‚Äã
  - id‚Äã
  - name‚Äã
  - component‚Äã
  - defaultSize‚Äã
  - minSize‚Äã
  - maxSize‚Äã

Status: Developer Preview

Defines a dashboard widget that can be added to the dashboard.

A unique identifier for the widget.

The display name of the widget.

The React component that renders the widget.

The default size and position of the widget.

The minimum size constraints for the widget.

The maximum size constraints for the widget.

**Examples:**

Example 1 (ts):
```ts
type DashboardWidgetDefinition = {    id: string;    name: string;    component: React.ComponentType<DashboardBaseWidgetProps>;    defaultSize: { w: number; h: number; x?: number; y?: number };    minSize?: { w: number; h: number };    maxSize?: { w: number; h: number };}
```

---

## SessionCacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/session-cache-strategy/

**Contents:**
- SessionCacheStrategy
- SessionCacheStrategy‚Äã
  - set‚Äã
  - get‚Äã
  - delete‚Äã
  - clear‚Äã
- CachedSessionUser‚Äã
  - id‚Äã
  - identifier‚Äã
  - verified‚Äã

This strategy defines how sessions get cached. Since most requests will need the Session object for permissions data, it can become a bottleneck to go to the database and do a multi-join SQL query each time. Therefore, we cache the session data only perform the SQL query once and upon invalidation of the cache.

The Vendure default from v3.1+ is to use a the DefaultSessionCacheStrategy, which delegates to the configured CacheStrategy to store the session data. This should be suitable for most use-cases.

If you are using v3.1 or later, you should not normally need to implement a custom SessionCacheStrategy, since this is now handled by the DefaultSessionCacheStrategy.

Prior to v3.1, the default was to use the InMemorySessionCacheStrategy, which is fast but suitable for single-instance deployments.

This is configured via the authOptions.sessionCacheStrategy property of your VendureConfig.

Here's an example implementation using Redis. To use this, you need to add the ioredis package as a dependency.

Store the session in the cache. When caching a session, the data should not be modified apart from performing any transforms needed to get it into a state to be stored, e.g. JSON.stringify().

Retrieve the session from the cache

Delete a session from the cache

Clear the entire cache

A simplified representation of the User associated with the current Session.

A simplified representation of a Session which is easy to store.

The timestamp after which this cache entry is considered stale and a fresh copy of the data will be set. Based on the sessionCacheTTL option.

**Examples:**

Example 1 (ts):
```ts
import { CachedSession, Logger, SessionCacheStrategy, VendurePlugin } from '@vendure/core';import { Redis, RedisOptions } from 'ioredis';export interface RedisSessionCachePluginOptions {  namespace?: string;  redisOptions?: RedisOptions;}const loggerCtx = 'RedisSessionCacheStrategy';const DEFAULT_NAMESPACE = 'vendure-session-cache';const DEFAULT_TTL = 86400;export class RedisSessionCacheStrategy implements SessionCacheStrategy {  private client: Redis;  constructor(private options: RedisSessionCachePluginOptions) {}  init() {    this.client = new Redis(this.options.redisOptions as RedisOptions
...
```

Example 2 (ts):
```ts
interface SessionCacheStrategy extends InjectableStrategy {    set(session: CachedSession): void | Promise<void>;    get(sessionToken: string): CachedSession | undefined | Promise<CachedSession | undefined>;    delete(sessionToken: string): void | Promise<void>;    clear(): void | Promise<void>;}
```

Example 3 (ts):
```ts
type CachedSessionUser = {    id: ID;    identifier: string;    verified: boolean;    channelPermissions: UserChannelPermissions[];}
```

Example 4 (ts):
```ts
type CachedSession = {    cacheExpiry: number;    id: ID;    token: string;    expires: Date;    activeOrderId?: ID;    authenticationStrategy?: string;    user?: CachedSessionUser;    activeChannelId?: ID;}
```

---

## DetailPage

**URL:** https://docs.vendure.io/reference/dashboard/detail-views/detail-page

**Contents:**
- DetailPage
- DetailPage‚Äã
  - props‚Äã
- DetailPageProps‚Äã
  - entityName‚Äã
  - pageId‚Äã
  - route‚Äã
  - title‚Äã
  - queryDocument‚Äã
  - createDocument‚Äã

Auto-generates a detail page with a form based on the provided query and mutation documents.

For more control over the layout, you would use the more low-level Page component.

Props to configure the DetailPage component.

The name of the entity. If not provided, it will be inferred from the query document.

A unique identifier for the page.

The Tanstack Router route used to navigate to this page.

The title of the page.

The query document used to fetch the entity.

The mutation document used to create the entity.

The mutation document used to update the entity.

A function that sets the values for the update input type based on the entity.

**Examples:**

Example 1 (ts):
```ts
function DetailPage<T extends TypedDocumentNode<any, any>, C extends TypedDocumentNode<any, any>, U extends TypedDocumentNode<any, any>>(props: DetailPageProps<T, C, U>): void
```

Example 2 (ts):
```ts
interface DetailPageProps<T extends TypedDocumentNode<any, any>, C extends TypedDocumentNode<any, any>, U extends TypedDocumentNode<any, any>, EntityField extends keyof ResultOf<T> = DetailEntityPath<T>> {    entityName?: string;    pageId: string;    route: AnyRoute;    title: (entity: ResultOf<T>[EntityField]) => string;    queryDocument: T;    createDocument?: C;    updateDocument: U;    setValuesForUpdate: (entity: ResultOf<T>[EntityField]) => VariablesOf<U>['input'];}
```

---

## PluginCommonModule

**URL:** https://docs.vendure.io/reference/typescript-api/plugin/plugin-common-module

**Contents:**
- PluginCommonModule
- PluginCommonModule‚Äã

This module provides the common services, configuration, and event bus capabilities required by a typical plugin. It should be imported into plugins to avoid having to repeat the same boilerplate for each individual plugin.

The PluginCommonModule exports:

**Examples:**

Example 1 (ts):
```ts
class PluginCommonModule {}
```

---

## AssetPreviewPipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/asset-preview-pipe

**Contents:**
- AssetPreviewPipe
- AssetPreviewPipe‚Äã
  - transform‚Äã

Given an Asset object (an object with preview and optionally focalPoint properties), this pipe returns a string with query parameters designed to work with the image resize capabilities of the AssetServerPlugin.

**Examples:**

Example 1 (html):
```html
<img [src]="asset | assetPreview:'tiny'" /><img [src]="asset | assetPreview:150" />
```

Example 2 (ts):
```ts
class AssetPreviewPipe implements PipeTransform {    transform(asset?: AssetFragment, preset: string | number = 'thumb') => string;}
```

---

## OrderableAsset

**URL:** https://docs.vendure.io/reference/typescript-api/entities/orderable-asset

**Contents:**
- OrderableAsset
- OrderableAsset‚Äã
  - constructor‚Äã
  - assetId‚Äã
  - asset‚Äã
  - position‚Äã

This base class is extended in order to enable specific ordering of the one-to-many Entity -> Assets relation. Using a many-to-many relation does not provide a way to guarantee order of the Assets, so this entity is used in place of the usual join table that would be created by TypeORM. See https://typeorm.io/#/many-to-many-relations/many-to-many-relations-with-custom-properties

Extends: VendureEntity

Implements: Orderable

**Examples:**

Example 1 (ts):
```ts
class OrderableAsset extends VendureEntity implements Orderable {    constructor(input?: DeepPartial<OrderableAsset>)    @Column()    assetId: ID;    @Index()    @ManyToOne(type => Asset, { eager: true, onDelete: 'CASCADE' })    asset: Asset;    @Column()    position: number;}
```

---

## BullMQPluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/job-queue-plugin/bull-mqplugin-options

**Contents:**
- BullMQPluginOptions
- BullMQPluginOptions‚Äã
  - connection‚Äã
  - queueOptions‚Äã
  - workerOptions‚Äã
  - setRetries‚Äã
  - setBackoff‚Äã
  - setJobOptions‚Äã
- BackoffOptions‚Äã
  - type‚Äã

Configuration options for the BullMQJobQueuePlugin.

Connection options which will be passed directly to BullMQ when creating a new Queue, Worker and Scheduler instance.

If omitted, it will attempt to connect to Redis at 127.0.0.1:6379.

Additional options used when instantiating the BullMQ Queue instance. See the BullMQ QueueOptions docs

Additional options used when instantiating the BullMQ Worker instance. See the BullMQ WorkerOptions docs

When a job is added to the JobQueue using JobQueue.add(), the calling code may specify the number of retries in case of failure. This option allows you to override that number and specify your own number of retries based on the job being added.

This allows you to specify the backoff settings when a failed job gets retried. In other words, this determines how much time should pass before attempting to process the failed job again. If the function returns undefined, the default value of exponential/1000ms will be used.

This allows you to specify additional options for a job when it is added to the queue. The object returned is the BullMQ JobsOptions type, which includes control over settings such as delay, attempts, priority and much more.

This function is called every time a job is added to the queue, so you can return different options based on the job being added.

Configuration for the backoff function when retrying failed jobs.

**Examples:**

Example 1 (ts):
```ts
interface BullMQPluginOptions {    connection?: ConnectionOptions;    queueOptions?: Omit<QueueOptions, 'connection'>;    workerOptions?: Omit<WorkerOptions, 'connection'>;    setRetries?: (queueName: string, job: Job) => number;    setBackoff?: (queueName: string, job: Job) => BackoffOptions | undefined;    setJobOptions?: (queueName: string, job: Job) => BullJobsOptions;}
```

Example 2 (ts):
```ts
setRetries: (queueName, job) => {  if (queueName === 'send-email') {    // Override the default number of retries    // for the 'send-email' job because we have    // a very unreliable email service.    return 10;  }  return job.retries;}
```

Example 3 (ts):
```ts
setBackoff: (queueName, job) => {  return {    type: 'exponential', // or 'fixed'    delay: 10000 // first retry after 10s, second retry after 20s, 40s,...  };}
```

Example 4 (ts):
```ts
// Here we want to assign a higher priority to jobs in the 'critical' queuesetJobOptions: (queueName, job) => {  const priority = queueName === 'critical' ? 1 : 5;  return { priority };}
```

---

## UseLazyQuery

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-lazy-query

**Contents:**
- UseLazyQuery
- useLazyQuery‚Äã
  - query‚Äã
  - options‚Äã

A React hook which allows you to execute a GraphQL query lazily.

**Examples:**

Example 1 (ts):
```ts
import { useLazyQuery } from '@vendure/admin-ui/react';import { gql } from 'graphql-tag';const GET_PRODUCT = gql`   query GetProduct($id: ID!) {     product(id: $id) {       id       name       description     }   }`;type ProductResponse = {    product: {        name: string        description: string    }}export const MyComponent = () => {    const [getProduct, { data, loading, error }] = useLazyQuery<ProductResponse>(GET_PRODUCT, { refetchOnChannelChange: true });   const handleClick = () => {        getProduct({             id: '1',        }).then(result => {            // do something with
...
```

Example 2 (ts):
```ts
function useLazyQuery<T, V extends Record<string, any> = Record<string, any>>(query: DocumentNode | TypedDocumentNode<T, V>, options: { refetchOnChannelChange: boolean } = { refetchOnChannelChange: false }): void
```

---

## PaginatedList

**URL:** https://docs.vendure.io/reference/typescript-api/common/paginated-list

**Contents:**
- PaginatedList
- PaginatedList‚Äã
  - items‚Äã
  - totalItems‚Äã

A type describing the shape of a paginated list response. In Vendure, almost all list queries (products, collections, orders, customers etc) return an object of this type.

**Examples:**

Example 1 (ts):
```ts
type PaginatedList<T> = {    items: T[];    totalItems: number;}
```

---

## JobQueueService

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job-queue-service

**Contents:**
- JobQueueService
- JobQueueService‚Äã
  - constructor‚Äã
  - createQueue‚Äã
  - start‚Äã
  - addBuffer‚Äã
  - removeBuffer‚Äã
  - bufferSize‚Äã
  - flush‚Äã
  - getJobQueues‚Äã

The JobQueueService is used to create new JobQueue instances and access existing jobs.

Configures and creates a new JobQueue instance.

Adds a JobBuffer, which will make it active and begin collecting jobs to buffer.

Removes a JobBuffer, prevent it from collecting and buffering any subsequent jobs.

Returns an object containing the number of buffered jobs arranged by bufferId. This can be used to decide whether a particular buffer has any jobs to flush.

Passing in JobBuffer instances or ids limits the results to the specified JobBuffers. If no argument is passed, sizes will be returned for all JobBuffers.

Flushes the specified buffers, which means that the buffer is cleared and the jobs get sent to the job queue for processing. Before sending the jobs to the job queue, they will be passed through each JobBuffer's reduce() method, which is can be used to optimize the amount of work to be done by e.g. de-duplicating identical jobs or aggregating data over the collected jobs.

Passing in JobBuffer instances or ids limits the action to the specified JobBuffers. If no argument is passed, all JobBuffers will be flushed.

Returns an array of all Jobs which were added to the job queue.

Returns an array of { name: string; running: boolean; } for each registered JobQueue.

**Examples:**

Example 1 (ts):
```ts
// A service which transcodes video filesclass VideoTranscoderService {  private jobQueue: JobQueue<{ videoId: string; }>;  async onModuleInit() {    // The JobQueue is created on initialization    this.jobQueue = await this.jobQueueService.createQueue({      name: 'transcode-video',      process: async job => {        return await this.transcodeVideo(job.data.videoId);      },    });  }  addToTranscodeQueue(videoId: string) {    this.jobQueue.add({ videoId, })  }  private async transcodeVideo(videoId: string) {    // e.g. call some external transcoding service  }}
```

Example 2 (ts):
```ts
class JobQueueService implements OnModuleDestroy {    constructor(configService: ConfigService, jobBufferService: JobBufferService)    createQueue(options: CreateQueueOptions<Data>) => Promise<JobQueue<Data>>;    start() => Promise<void>;    addBuffer(buffer: JobBuffer<any>) => ;    removeBuffer(buffer: JobBuffer<any>) => ;    bufferSize(forBuffers: Array<JobBuffer<any> | string>) => Promise<{ [bufferId: string]: number }>;    flush(forBuffers: Array<JobBuffer<any> | string>) => Promise<Job[]>;    getJobQueues() => GraphQlJobQueue[];}
```

Example 3 (ts):
```ts
const sizes = await this.jobQueueService.bufferSize('buffer-1', 'buffer-2');// sizes = { 'buffer-1': 12, 'buffer-2': 3 }
```

---

## UseDetailPage

**URL:** https://docs.vendure.io/reference/dashboard/detail-views/use-detail-page

**Contents:**
- UseDetailPage
- useDetailPage‚Äã
  - options‚Äã
- DetailPageOptions‚Äã
  - pageId‚Äã
  - queryDocument‚Äã
  - entityField‚Äã
  - params‚Äã
  - entityName‚Äã
  - createDocument‚Äã

Status: Developer Preview

This hook is used to create an entity detail page which can read and update an entity.

Options used to configure the result of the useDetailPage hook.

The page id. This is optional, but if provided, it will be used to identify the page when extending the detail page query

The query document to fetch the entity.

The field of the query document that contains the entity.

The parameters used to identify the entity.

The entity type name for custom field configuration lookup. Required to filter out readonly custom fields before mutations. If not provided, the function will try to infer it from the query document.

The document to create the entity.

The document to update the entity.

The function to set the values for the update document.

The function to call when the update is successful.

The function to call when the update is successful.

**Examples:**

Example 1 (ts):
```ts
const { form, submitHandler, entity, isPending, resetForm } = useDetailPage({    queryDocument: paymentMethodDetailDocument,    createDocument: createPaymentMethodDocument,    updateDocument: updatePaymentMethodDocument,    setValuesForUpdate: entity => {        return {            id: entity.id,            enabled: entity.enabled,            name: entity.name,            code: entity.code,            description: entity.description,            checker: entity.checker?.code                ? {                      code: entity.checker?.code,                      arguments: entity.checker?.args,
...
```

Example 2 (ts):
```ts
function useDetailPage<T extends TypedDocumentNode<any, any>, C extends TypedDocumentNode<any, any>, U extends TypedDocumentNode<any, any>, EntityField extends keyof ResultOf<T> = keyof ResultOf<T>, VarNameUpdate extends keyof VariablesOf<U> = 'input', VarNameCreate extends keyof VariablesOf<C> = 'input'>(options: DetailPageOptions<T, C, U, EntityField, VarNameCreate, VarNameUpdate>): UseDetailPageResult<T, U, EntityField>
```

Example 3 (ts):
```ts
interface DetailPageOptions<T extends TypedDocumentNode<any, any>, C extends TypedDocumentNode<any, any>, U extends TypedDocumentNode<any, any>, EntityField extends keyof ResultOf<T> = DetailEntityPath<T>, VarNameCreate extends keyof VariablesOf<C> = 'input', VarNameUpdate extends keyof VariablesOf<U> = 'input'> {    pageId?: string;    queryDocument: T;    entityField?: EntityField;    params: {        id: string;    };    entityName?: string;    createDocument?: C;    updateDocument?: U;    setValuesForUpdate: (entity: NonNullable<ResultOf<T>[EntityField]>) => VariablesOf<U>[VarNameUpdate]; 
...
```

Example 4 (ts):
```ts
interface UseDetailPageResult<T extends TypedDocumentNode<any, any>, U extends TypedDocumentNode<any, any>, EntityField extends keyof ResultOf<T>> {    form: UseFormReturn<RemoveNullFields<VariablesOf<U>['input']>>;    submitHandler: (event: FormEvent<HTMLFormElement>) => void;    entity?: DetailPageEntity<T, EntityField>;    isPending: boolean;    refreshEntity: () => void;    resetForm: () => void;}
```

---

## UseInjector

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-injector

**Contents:**
- UseInjector
- useInjector‚Äã
  - token‚Äã

Exposes the Angular injector which allows the injection of services into React components.

**Examples:**

Example 1 (ts):
```ts
import { useInjector } from '@vendure/admin-ui/react';import { NotificationService } from '@vendure/admin-ui/core';export const MyComponent = () => {    const notificationService = useInjector(NotificationService);    const handleClick = () => {        notificationService.success('Hello world!');    };    // ...    return <div>...</div>;}
```

Example 2 (ts):
```ts
function useInjector<T = any>(token: ProviderToken<T>): T
```

---

## InjectableStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/common/injectable-strategy

**Contents:**
- InjectableStrategy
- InjectableStrategy‚Äã
  - init‚Äã
  - destroy‚Äã

This interface defines the setup and teardown hooks available to the various strategies used to configure Vendure.

Defines setup logic to be run during application bootstrap. Receives the Injector as an argument, which allows application providers to be used as part of the setup. This hook will be called on both the main server and the worker processes.

Defines teardown logic to be run before application shutdown.

**Examples:**

Example 1 (ts):
```ts
interface InjectableStrategy {    init?: (injector: Injector) => void | Promise<void>;    destroy?: () => void | Promise<void>;}
```

Example 2 (ts):
```ts
async init(injector: Injector) {  const myService = injector.get(MyService);  await myService.doSomething();}
```

---

## Components

**URL:** https://docs.vendure.io/reference/dashboard/components/

**Contents:**
- Components
- üìÑÔ∏è AssetGallery
- üìÑÔ∏è AssetPickerDialog
- üìÑÔ∏è DetailPageButton
- üìÑÔ∏è FacetValueChip
- üìÑÔ∏è FacetValueSelector
- üìÑÔ∏è PermissionGuard
- üìÑÔ∏è VendureImage

---

## Telemetry

**URL:** https://docs.vendure.io/reference/typescript-api/telemetry/

**Contents:**
- Telemetry
- üìÑÔ∏è Instrument
- üìÑÔ∏è InstrumentationStrategy
- üìÑÔ∏è WrappedMethodArgs

InstrumentationStrategy

---

## User

**URL:** https://docs.vendure.io/reference/typescript-api/entities/user

**Contents:**
- User
- User‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - identifier‚Äã
  - authenticationMethods‚Äã
  - verified‚Äã
  - roles‚Äã
  - lastLogin‚Äã
  - customFields‚Äã

A User represents any authenticated user of the Vendure API. This includes both Administrators as well as registered Customers.

Extends: VendureEntity

Implements: HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class User extends VendureEntity implements HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<User>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column()    identifier: string;    @OneToMany(type => AuthenticationMethod, method => method.user)    authenticationMethods: AuthenticationMethod[];    @Column({ default: false })    verified: boolean;    @ManyToMany(type => Role)    @JoinTable()    roles: Role[];    @Column({ type: Date, nullable: true })    lastLogin: Date | null;    @Column(type => CustomUserFields)    customFields: CustomUserFields; 
...
```

---

## TestEnvironment

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-environment

**Contents:**
- TestEnvironment
- TestEnvironment‚Äã
  - server‚Äã
  - adminClient‚Äã
  - shopClient‚Äã

The return value of createTestEnvironment, containing the test server and clients for the Shop API and Admin API.

A Vendure server instance against which GraphQL requests can be made.

A GraphQL client configured for the Admin API.

A GraphQL client configured for the Shop API.

**Examples:**

Example 1 (ts):
```ts
interface TestEnvironment {    server: TestServer;    adminClient: SimpleGraphQLClient;    shopClient: SimpleGraphQLClient;}
```

---

## RequestContextService

**URL:** https://docs.vendure.io/reference/typescript-api/request/request-context-service/

**Contents:**
- RequestContextService
- RequestContextService‚Äã
  - create‚Äã
  - fromRequest‚Äã

Creates new RequestContext instances.

Creates a RequestContext based on the config provided. This can be useful when interacting with services outside the request-response cycle, for example in stand-alone scripts or in worker jobs.

Creates a new RequestContext based on an Express request object. This is used internally in the API layer by the AuthGuard, and creates the RequestContext which is then passed to all resolvers & controllers.

**Examples:**

Example 1 (ts):
```ts
class RequestContextService {    create(config: {        req?: Request;        apiType: ApiType;        channelOrToken?: Channel | string;        languageCode?: LanguageCode;        currencyCode?: CurrencyCode;        user?: User;        activeOrderId?: ID;    }) => Promise<RequestContext>;    fromRequest(req: Request, info?: GraphQLResolveInfo, requiredPermissions?: Permission[], session?: CachedSession) => Promise<RequestContext>;}
```

---

## UseWidgetFilters

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-widget-filters

**Contents:**
- UseWidgetFilters
- useWidgetFilters‚Äã

Exposes a context object for use in building Insights page widgets.

**Examples:**

Example 1 (ts):
```ts
function useWidgetFilters(): void
```

---

## StellateService

**URL:** https://docs.vendure.io/reference/core-plugins/stellate-plugin/stellate-service

**Contents:**
- StellateService
- StellateService‚Äã
  - constructor‚Äã
  - purgeProducts‚Äã
  - purgeProductVariants‚Äã
  - purgeSearchResults‚Äã
  - purgeAllOfType‚Äã
  - purgeCollections‚Äã
  - purgeSearchResponseCacheIdentifiers‚Äã
  - purge‚Äã

The StellateService is used to purge the Stellate cache when certain events occur.

Purges the cache for the given Products.

Purges the cache for the given ProductVariants.

Purges the cache for SearchResults which contain the given Products or ProductVariants.

Purges the entire cache for the given type.

Purges the cache for the given Collections.

Purges the cache of SearchResults for the given Collections based on slug.

Purges the cache for the given type and keys.

**Examples:**

Example 1 (ts):
```ts
class StellateService {    constructor(options: StellatePluginOptions)    purgeProducts(products: Product[]) => ;    purgeProductVariants(productVariants: ProductVariant[]) => ;    purgeSearchResults(items: Array<ProductVariant | Product>) => ;    purgeAllOfType(type: CachedType) => ;    purgeCollections(collections: Collection[]) => ;    purgeSearchResponseCacheIdentifiers(collections: Collection[]) => ;    purge(type: CachedType, keys?: ID[], keyName:  = 'id') => ;}
```

---

## JobQueue

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/

**Contents:**
- JobQueue
- JobQueue‚Äã
  - name‚Äã
  - started‚Äã
  - constructor‚Äã
  - add‚Äã

A JobQueue is used to process Jobs. A job is added to the queue via the .add() method, and the configured JobQueueStrategy will check for new jobs and process each according to the defined process function.

Note: JobQueue instances should not be directly instantiated. Rather, the JobQueueService createQueue() method should be used (see that service for example usage).

Adds a new Job to the queue. The resolved SubscribableJob allows the calling code to subscribe to updates to the Job:

Alternatively, if you aren't interested in the intermediate progress changes, you can convert to a Promise like this:

**Examples:**

Example 1 (ts):
```ts
class JobQueue<Data extends JobData<Data> = object> {    name: string    started: boolean    constructor(options: CreateQueueOptions<Data>, jobQueueStrategy: JobQueueStrategy, jobBufferService: JobBufferService)    add(data: Data, options?: JobOptions<Data>) => Promise<SubscribableJob<Data>>;}
```

Example 2 (ts):
```ts
const job = await this.myQueue.add({ intervalMs, shouldFail }, { retries: 2 });return job.updates().pipe(  map(update => {    // The returned Observable will emit a value for every update to the job    // such as when the `progress` or `status` value changes.    Logger.info(`Job ${update.id}: progress: ${update.progress}`);    if (update.state === JobState.COMPLETED) {      Logger.info(`COMPLETED ${update.id}: ${update.result}`);    }    return update.result;  }),  catchError(err => of(err.message)),);
```

Example 3 (ts):
```ts
const job = await this.myQueue.add({ intervalMs, shouldFail }, { retries: 2 });return job.updates().toPromise()  .then(update => update.result),  .catch(err => err.message);
```

---

## BullMQJobQueueStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/job-queue-plugin/bull-mqjob-queue-strategy

**Contents:**
- BullMQJobQueueStrategy
- BullMQJobQueueStrategy‚Äã
  - init‚Äã
  - destroy‚Äã
  - add‚Äã
  - cancelJob‚Äã
  - findMany‚Äã
  - findManyById‚Äã
  - findOne‚Äã
  - removeSettledJobs‚Äã

This JobQueueStrategy uses BullMQ to implement a push-based job queue on top of Redis. It should not be used alone, but as part of the BullMQJobQueuePlugin.

Note: To use this strategy, you need to manually install the bullmq package:

**Examples:**

Example 1 (shell):
```shell
npm install bullmq@^5.4.2
```

Example 2 (ts):
```ts
class BullMQJobQueueStrategy implements InspectableJobQueueStrategy {    init(injector: Injector) => Promise<void>;    destroy() => ;    add(job: Job<Data>) => Promise<Job<Data>>;    cancelJob(jobId: string) => Promise<Job | undefined>;    findMany(options?: JobListOptions) => Promise<PaginatedList<Job>>;    findManyById(ids: ID[]) => Promise<Job[]>;    findOne(id: ID) => Promise<Job | undefined>;    removeSettledJobs(queueNames?: string[], olderThan?: Date) => Promise<number>;    start(queueName: string, process: (job: Job<Data>) => Promise<any>) => Promise<void>;    stop(queueName: string, p
...
```

---

## Middleware

**URL:** https://docs.vendure.io/reference/typescript-api/common/middleware

**Contents:**
- Middleware
- Middleware‚Äã
- Increasing the maximum request body size limit‚Äã
  - handler‚Äã
  - route‚Äã
  - beforeListen‚Äã

Defines API middleware, set in the ApiOptions. Middleware can be either Express middleware or NestJS middleware.

Internally, Vendure relies on the body-parser middleware to parse incoming JSON data. By default, the maximum body size is set to 100kb. Attempting to send a request with more than 100kb of JSON data will result in a PayloadTooLargeError. To increase this limit, we can manually configure the body-parser middleware:

The Express middleware function or NestJS NestMiddleware class.

The route to which this middleware will apply. Pattern based routes are supported as well.

The 'ab*cd' route path will match abcd, ab_cd, abecd, and so on. The characters ?, +, *, and () may be used in a route path, and are subsets of their regular expression counterparts. The hyphen (-) and the dot (.) are interpreted literally.

When set to true, this will cause the middleware to be applied before the Vendure server (and underlying Express server) starts listening for connections. In practical terms this means that the middleware will be at the very start of the middleware stack, before even the body-parser middleware which is automatically applied by NestJS. This can be useful in certain cases such as when you need to access the raw unparsed request for a specific route.

**Examples:**

Example 1 (ts):
```ts
import { VendureConfig } from '@vendure/core';import { json } from 'body-parser';export const config: VendureConfig = {  // ...  apiOptions: {    middleware: [{      handler: json({ limit: '10mb' }),      route: '*splat',      beforeListen: true,    }],  },};
```

Example 2 (ts):
```ts
interface Middleware {    handler: MiddlewareHandler;    route: string;    beforeListen?: boolean;}
```

---

## Import Export

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/

**Contents:**
- Import Export
- üìÑÔ∏è AssetImportStrategy
- üìÑÔ∏è AssetImporter
- üìÑÔ∏è DefaultAssetImportStrategy
- üìÑÔ∏è FastImporterService
- üìÑÔ∏è ImportExportOptions
- üìÑÔ∏è ImportParser
- üìÑÔ∏è Importer
- üìÑÔ∏è InitialData
- üìÑÔ∏è Populate

DefaultAssetImportStrategy

---

## ProductPriceApplicator

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/product-price-applicator

**Contents:**
- ProductPriceApplicator
- ProductPriceApplicator‚Äã
  - constructor‚Äã
  - applyChannelPriceAndTax‚Äã

This helper is used to apply the correct price to a ProductVariant based on the current context including active Channel, any current Order, etc. If you use the TransactionalConnection to directly query ProductVariants, you will find that the price and priceWithTax properties will always be 0 until you use the applyChannelPriceAndTax() method:

Populates the price field with the price for the specified channel. Make sure that the ProductVariant being passed in has its taxCategory relation joined.

If the throwIfNoPriceFound option is set to true, then an error will be thrown if no price is found for the given Channel.

**Examples:**

Example 1 (ts):
```ts
export class MyCustomService {  constructor(private connection: TransactionalConnection,              private productPriceApplicator: ProductPriceApplicator) {}  getVariant(ctx: RequestContext, id: ID) {    const productVariant = await this.connection      .getRepository(ctx, ProductVariant)      .findOne(id, { relations: ['taxCategory'] });    await this.productPriceApplicator      .applyChannelPriceAndTax(productVariant, ctx);    return productVariant;  }}
```

Example 2 (ts):
```ts
class ProductPriceApplicator {    constructor(configService: ConfigService, taxRateService: TaxRateService, zoneService: ZoneService, requestCache: RequestContextCacheService)    applyChannelPriceAndTax(variant: ProductVariant, ctx: RequestContext, order?: Order, throwIfNoPriceFound:  = false) => Promise<ProductVariant>;}
```

---

## TranslatableSaver

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/translatable-saver/

**Contents:**
- TranslatableSaver
- TranslatableSaver‚Äã
  - constructor‚Äã
  - create‚Äã
  - update‚Äã

A helper which contains methods for creating and updating entities which implement the Translatable interface.

Create a translatable entity, including creating any translation entities according to the translations array.

Update a translatable entity. Performs a diff of the translations array in order to perform the correct operation on the translations.

**Examples:**

Example 1 (ts):
```ts
export class MyService {  constructor(private translatableSaver: TranslatableSaver) {}  async create(ctx: RequestContext, input: CreateFacetInput): Promise<Translated<Facet>> {    const facet = await this.translatableSaver.create({      ctx,      input,      entityType: Facet,      translationType: FacetTranslation,      beforeSave: async f => {          f.code = await this.ensureUniqueCode(ctx, f.code);      },    });    return facet;  }  // ...}
```

Example 2 (ts):
```ts
class TranslatableSaver {    constructor(connection: TransactionalConnection)    create(options: CreateTranslatableOptions<T>) => Promise<T>;    update(options: UpdateTranslatableOptions<T>) => Promise<T>;}
```

---

## PageTitle

**URL:** https://docs.vendure.io/reference/dashboard/page-layout/page-title

**Contents:**
- PageTitle
- PageTitle‚Äã
  - props‚Äã

A component for displaying the title of a page. This should be used inside the Page component.

**Examples:**

Example 1 (ts):
```ts
function PageTitle(props: Readonly<{ children: React.ReactNode }>): void
```

---

## RequestContext

**URL:** https://docs.vendure.io/reference/typescript-api/request/request-context

**Contents:**
- RequestContext
- RequestContext‚Äã
  - empty‚Äã
  - deserialize‚Äã
  - userHasPermissions‚Äã
  - serialize‚Äã
  - copy‚Äã
  - req‚Äã
  - apiType‚Äã
  - channel‚Äã

The RequestContext holds information relevant to the current request, which may be required at various points of the stack.

It is a good practice to inject the RequestContext (using the Ctx decorator) into all resolvers & REST handler, and then pass it through to the service layer.

This allows the service layer to access information about the current user, the active language, the active Channel, and so on. In addition, the TransactionalConnection relies on the presence of the RequestContext object in order to correctly handle per-request database transactions.

The RequestContext also provides mechanisms for managing the database replication mode via the setReplicationMode method and the replicationMode getter. This allows for finer control over whether database queries within the context should be executed against the master or a replica database, which can be particularly useful in distributed database environments.

Creates an "empty" RequestContext object. This is only intended to be used when a service method must be called outside the normal request-response cycle, e.g. when programmatically populating data. Usually a better alternative is to use the RequestContextService create() method, which allows more control over the resulting RequestContext object.

Creates a new RequestContext object from a serialized object created by the serialize() method.

Returns true if there is an active Session & User associated with this request, and that User has the specified permissions on the active Channel.

Serializes the RequestContext object into a JSON-compatible simple object. This is useful when you need to send a RequestContext object to another process, e.g. to pass it to the Job Queue via the JobQueueService.

Creates a shallow copy of the RequestContext instance. This means that mutations to the copy itself will not affect the original, but deep mutations (e.g. copy.channel.code = 'new') will also affect the original.

The raw Express request object.

Signals which API this request was received by, e.g. admin or shop.

The active Channel of this request.

True if the current session is authorized to access the current resolver method.

True if the current anonymous session is only authorized to operate on entities that are owned by the current session.

Translate the given i18n key

Sets the replication mode for the current RequestContext. This mode determines whether the operations within this context should interact with the master database or a replica database. This allows for finer control over database query routing in distributed database environments.

Available modes:
- `'master'`: Routes operations to the master database
- `'replica'`: Routes operations to a replica database

The replication mode can be retrieved using the `replicationMode` getter property.

**Examples:**

Example 1 (ts):
```ts
@Query()myQuery(@Ctx() ctx: RequestContext) {  return this.myService.getData(ctx);}
```

Example 2 (ts):
```ts
@Query()myMutation(@Ctx() ctx: RequestContext) {  ctx.setReplicationMode('master');  return this.myService.getData(ctx);}
```

Example 3 (ts):
```ts
class RequestContext {    empty() => RequestContext;    deserialize(ctxObject: SerializedRequestContext) => RequestContext;    userHasPermissions(permissions: Permission[]) => boolean;    serialize() => SerializedRequestContext;    copy() => RequestContext;    req: Request | undefined    apiType: ApiType    channel: Channel    channelId: ID    languageCode: LanguageCode    currencyCode: CurrencyCode    session: CachedSession | undefined    activeUserId: ID | undefined    isAuthorized: boolean    authorizedAsOwnerOnly: boolean    translate(key: string, variables?: { [k: string]: any }) => strin
...
```

---

## Administrator

**URL:** https://docs.vendure.io/reference/typescript-api/entities/administrator

**Contents:**
- Administrator
- Administrator‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - firstName‚Äã
  - lastName‚Äã
  - emailAddress‚Äã
  - user‚Äã
  - customFields‚Äã

An administrative user who has access to the Admin UI and Admin API. The specific permissions of the Administrator are determined by the assigned Roles.

Extends: VendureEntity

Implements: SoftDeletable, HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Administrator extends VendureEntity implements SoftDeletable, HasCustomFields {    constructor(input?: DeepPartial<Administrator>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column() firstName: string;    @Column() lastName: string;    @Column({ unique: true })    emailAddress: string;    @OneToOne(type => User)    @JoinColumn()    user: User;    @Column(type => CustomAdministratorFields)    customFields: CustomAdministratorFields;}
```

---

## CustomDetailComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-detail-components/custom-detail-component

**Contents:**
- CustomDetailComponent
- CustomDetailComponent‚Äã
  - entity$‚Äã
  - detailForm‚Äã

CustomDetailComponents allow any arbitrary Angular components to be embedded in entity detail pages of the Admin UI.

**Examples:**

Example 1 (ts):
```ts
interface CustomDetailComponent {    entity$: Observable<any>;    detailForm: UntypedFormGroup;}
```

---

## FulfillmentStates

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/fulfillment-states

**Contents:**
- FulfillmentStates
- FulfillmentStates‚Äã

An interface to extend standard FulfillmentState.

**Examples:**

Example 1 (ts):
```ts
interface FulfillmentStates {}
```

---

## TestServer

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-server/

**Contents:**
- TestServer
- TestServer‚Äã
  - app‚Äã
  - constructor‚Äã
  - init‚Äã
  - bootstrap‚Äã
  - destroy‚Äã

A real Vendure server against which the e2e tests should be run.

Bootstraps an instance of Vendure server and populates the database according to the options passed in. Should be called in the beforeAll function.

The populated data is saved into an .sqlite file for each test file. On subsequent runs, this file is loaded so that the populate step can be skipped, which speeds up the tests significantly.

Bootstraps a Vendure server instance. Generally the .init() method should be used, as that will also populate the test data. However, the bootstrap() method is sometimes useful in tests which need to start and stop a Vendure instance multiple times without re-populating data.

Destroy the Vendure server instance and clean up all resources. Should be called after all tests have run, e.g. in an afterAll function.

**Examples:**

Example 1 (ts):
```ts
class TestServer {    public app: INestApplication;    constructor(vendureConfig: Required<VendureConfig>)    init(options: TestServerOptions) => Promise<void>;    bootstrap() => ;    destroy() => ;}
```

---

## PaymentMethodConfigOptions

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-method-config-options

**Contents:**
- PaymentMethodConfigOptions
- PaymentMethodConfigOptions‚Äã
  - createPayment‚Äã
  - settlePayment‚Äã
  - cancelPayment‚Äã
  - createRefund‚Äã
  - onStateTransitionStart‚Äã

Defines the object which is used to construct the PaymentMethodHandler.

This function provides the logic for creating a payment. For example, it may call out to a third-party service with the data and should return a CreatePaymentResult object contains the details of the payment.

This function provides the logic for settling a payment, also known as "capturing". For payment integrations that settle/capture the payment on creation (i.e. the createPayment() method returns with a state of 'Settled') this method need only return { success: true }.

This function provides the logic for cancelling a payment, which would be invoked when a call is made to the cancelPayment mutation in the Admin API. Cancelling a payment can apply if, for example, you have created a "payment intent" with the payment provider but not yet completed the payment. It allows the incomplete payment to be cleaned up on the provider's end if it gets cancelled via Vendure.

This function provides the logic for refunding a payment created with this payment method. Some payment providers may not provide the facility to programmatically create a refund. In such a case, this method should be omitted and any Refunds will have to be settled manually by an administrator.

This function, when specified, will be invoked before any transition from one PaymentState to another. The return value (a sync / async boolean) is used to determine whether the transition is permitted.

**Examples:**

Example 1 (ts):
```ts
interface PaymentMethodConfigOptions<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {    createPayment: CreatePaymentFn<T>;    settlePayment: SettlePaymentFn<T>;    cancelPayment?: CancelPaymentFn<T>;    createRefund?: CreateRefundFn<T>;    onStateTransitionStart?: OnTransitionStartFn<PaymentState, PaymentTransitionData>;}
```

---

## TranslatableFormFieldWrapper

**URL:** https://docs.vendure.io/reference/dashboard/form-components/translatable-form-field-wrapper

**Contents:**
- TranslatableFormFieldWrapper
- TranslatableFormFieldWrapper‚Äã
- TranslatableFormFieldProps‚Äã

This is the equivalent of the FormFieldWrapper component, but for translatable fields.

The props for the TranslatableFormField component.

**Examples:**

Example 1 (tsx):
```tsx
<PageBlock column="main" blockId="main-form">    <DetailFormGrid>        <TranslatableFormFieldWrapper            control={form.control}            name="name"            label={<Trans>Product name</Trans>}            render={({ field }) => <Input {...field} />}        />        <TranslatableFormFieldWrapper            control={form.control}            name="slug"            label={<Trans>Slug</Trans>}            render={({ field }) => <Input {...field} />}        />    </DetailFormGrid>    <TranslatableFormFieldWrapper        control={form.control}        name="description"        label={<Tra
...
```

Example 2 (ts):
```ts
type TranslatableFormFieldProps<TFieldValues extends TranslatableEntity | TranslatableEntity[]> = Omit<    ControllerProps<TFieldValues>,    'name'> & {    /**     * @description     * The label for the form field.     */    label?: React.ReactNode;    /**     * @description     * The name of the form field.     */    name: TFieldValues extends TranslatableEntity        ? keyof Omit<NonNullable<TFieldValues['translations']>[number], 'languageCode'>        : TFieldValues extends TranslatableEntity[]            ? keyof Omit<NonNullable<TFieldValues[number]['translations']>[number], 'languageCode
...
```

---

## Customer

**URL:** https://docs.vendure.io/reference/typescript-api/entities/customer

**Contents:**
- Customer
- Customer‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - title‚Äã
  - firstName‚Äã
  - lastName‚Äã
  - phoneNumber‚Äã
  - emailAddress‚Äã
  - groups‚Äã

This entity represents a customer of the store, typically an individual person. A Customer can be a guest, in which case it has no associated User. Customers with registered account will have an associated User entity.

Extends: VendureEntity

Implements: ChannelAware, HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class Customer extends VendureEntity implements ChannelAware, HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<Customer>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column({ nullable: true })    title: string;    @Column() firstName: string;    @Column() lastName: string;    @Column({ nullable: true })    phoneNumber: string;    @Column()    emailAddress: string;    @ManyToMany(type => CustomerGroup, group => group.customers)    @JoinTable()    groups: CustomerGroup[];    @OneToMany(type => Address, address => address.customer)    addresses: Ad
...
```

---

## HydrateOptions

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/hydrate-options

**Contents:**
- HydrateOptions
- HydrateOptions‚Äã
  - relations‚Äã
  - applyProductVariantPrices‚Äã

Options used to control which relations of the entity get hydrated when using the EntityHydrator helper.

Defines the relations to hydrate, using strings with dot notation to indicate nested joins. If the entity already has a particular relation available, that relation will be skipped (no extra DB join will be added).

If set to true, any ProductVariants will also have their price and priceWithTax fields applied based on the current context. If prices are not required, this can be left false which will be slightly more efficient.

**Examples:**

Example 1 (ts):
```ts
interface HydrateOptions<Entity extends VendureEntity> {    relations: Array<EntityRelationPaths<Entity>>;    applyProductVariantPrices?: boolean;}
```

---

## RegisterReactRouteComponentOptions

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/register-react-route-component-options

**Contents:**
- RegisterReactRouteComponentOptions
- RegisterReactRouteComponentOptions‚Äã

Configuration for a React-based route component.

**Examples:**

Example 1 (ts):
```ts
type RegisterReactRouteComponentOptions<Entity extends { id: string; updatedAt?: string }, T extends DocumentNode | TypedDocumentNode<any, { id: string }>, Field extends keyof ResultOf<T>, R extends Field> = RegisterRouteComponentOptions<ElementType, Entity, T, Field, R> & {    props?: Record<string, any>;}
```

---

## VendureDashboardPlugin

**URL:** https://docs.vendure.io/reference/dashboard/vite-plugin/vendure-dashboard-plugin

**Contents:**
- VendureDashboardPlugin
- vendureDashboardPlugin‚Äã
  - options‚Äã
- VitePluginVendureDashboardOptions‚Äã
- PathAdapter‚Äã
  - getCompiledConfigPath‚Äã
  - transformTsConfigPathMappings‚Äã
- ApiConfig‚Äã
  - host‚Äã
  - port‚Äã

This is the Vite plugin which powers the Vendure Dashboard, including:

Options for the vendureDashboardPlugin Vite plugin.

The PathAdapter interface allows customization of how paths are handled when compiling the Vendure config and its imports.

It enables support for more complex repository structures, such as monorepos, where the Vendure server configuration file may not be located in the root directory of the project.

If you get compilation errors like "Error loading Vendure config: Cannot find module", you probably need to provide a custom pathAdapter to resolve the paths correctly.

This can take some trial-and-error. Try logging values from the functions to figure out the exact settings that you need for your repo setup.

A function to determine the path to the compiled Vendure config file.

Options used by the vendureDashboardPlugin to configure how the Dashboard connects to the Vendure Admin API

The hostname of the Vendure server which the admin UI will be making API calls to. If set to "auto", the Admin UI app will determine the hostname from the current location (i.e. window.location.hostname).

The port of the Vendure server which the admin UI will be making API calls to. If set to "auto", the Admin UI app will determine the port from the current location (i.e. window.location.port).

The path to the GraphQL Admin API.

Whether to use cookies or bearer tokens to track sessions. Should match the setting of in the server's tokenMethod config option.

The header used when using the 'bearer' auth method. Should match the setting of the server's authOptions.authTokenHeaderKey config option.

The name of the header which contains the channel token. Should match the setting of the server's apiOptions.channelTokenKey config option.

Options used by the vendureDashboardPlugin to configure aspects of the Dashboard UI behaviour.

The default language for the Admin UI. Must be one of the items specified in the availableLanguages property.

The default locale for the Admin UI. The locale affects the formatting of currencies & dates. Must be one of the items specified in the availableLocales property.

If not set, the browser default locale will be used.

An array of languages for which translations exist for the Admin UI.

An array of locales to be used on Admin UI.

Options used by the vendureDashboardPlugin to configure aspects of the Dashboard UI behaviour.

Configuration for API connection settings

Configuration for internationalization settings

**Examples:**

Example 1 (ts):
```ts
function vendureDashboardPlugin(options: VitePluginVendureDashboardOptions): PluginOption[]
```

Example 2 (ts):
```ts
type VitePluginVendureDashboardOptions = {    /**     * @description     * The path to the Vendure server configuration file.     */    vendureConfigPath: string | URL;    /**     * @description     * The {@link PathAdapter} allows you to customize the resolution of paths     * in the compiled Vendure source code which is used as part of the     * introspection step of building the dashboard.     *     * It enables support for more complex repository structures, such as     * monorepos, where the Vendure server configuration file may not     * be located in the root directory of the project.  
...
```

Example 3 (ts):
```ts
vendureDashboardPlugin({    pathAdapter: {        getCompiledConfigPath: ({ inputRootDir, outputPath, configFileName }) => {            const projectName = inputRootDir.split('/libs/')[1].split('/')[0];            const pathAfterProject = inputRootDir.split(`/libs/${projectName}`)[1];            const compiledConfigFilePath = `${outputPath}/${projectName}${pathAfterProject}`;            return path.join(compiledConfigFilePath, configFileName);        },        transformTsConfigPathMappings: ({ phase, patterns }) => {            // "loading" phase is when the compiled Vendure code is being load
...
```

Example 4 (ts):
```ts
interface PathAdapter {    getCompiledConfigPath?: GetCompiledConfigPathFn;    transformTsConfigPathMappings?: TransformTsConfigPathMappingsFn;}
```

---

## GuestCheckoutStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/guest-checkout-strategy

**Contents:**
- GuestCheckoutStrategy
- GuestCheckoutStrategy‚Äã
  - setCustomerForOrder‚Äã

A strategy that determines how to deal with guest checkouts - i.e. when a customer checks out without being logged in. For example, a strategy could be used to implement business rules such as:

This is configured via the orderOptions.guestCheckoutStrategy property of your VendureConfig.

This method is called when the setCustomerForOrder mutation is executed. It should return either a Customer object or an ErrorResult.

**Examples:**

Example 1 (ts):
```ts
interface GuestCheckoutStrategy extends InjectableStrategy {    setCustomerForOrder(        ctx: RequestContext,        order: Order,        input: CreateCustomerInput,    ):        | ErrorResultUnion<SetCustomerForOrderResult, Customer>        | Promise<ErrorResultUnion<SetCustomerForOrderResult, Customer>>;}
```

---

## AddressBasedTaxZoneStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/tax/address-based-tax-zone-strategy

**Contents:**
- AddressBasedTaxZoneStrategy
- AddressBasedTaxZoneStrategy‚Äã
  - determineTaxZone‚Äã

Address based TaxZoneStrategy which tries to find the applicable Zone based on the country of the shipping address of the Order. This is useful for shops that do cross-border B2C orders and use the One-Stop-Shop (OSS) VAT scheme.

Returns the default Channel's default tax zone if no applicable zone is found.

This is configured via taxOptions.taxZoneStrategy = new AddressBasedTaxZoneStrategy() in your VendureConfig.

**Examples:**

Example 1 (ts):
```ts
import { VendureConfig, AddressBasedTaxZoneStrategy } from '@vendure/core';export const config: VendureConfig = {  // other options...  taxOptions: {    taxZoneStrategy: new AddressBasedTaxZoneStrategy(),  },};
```

Example 2 (ts):
```ts
class AddressBasedTaxZoneStrategy implements TaxZoneStrategy {    determineTaxZone(ctx: RequestContext, zones: Zone[], channel: Channel, order?: Order) => Zone;}
```

---

## FacetValueSelector

**URL:** https://docs.vendure.io/reference/dashboard/components/facet-value-selector

**Contents:**
- FacetValueSelector
- FacetValueSelector‚Äã
  - props‚Äã
- FacetValueSelectorProps‚Äã
  - onValueSelect‚Äã
  - disabled‚Äã
  - placeholder‚Äã
  - pageSize‚Äã

A component for selecting facet values.

A component for selecting facet values.

The function to call when a facet value is selected.

The value will have the following structure:

Whether the selector is disabled.

The placeholder text for the selector.

The number of facet values to display per page.

**Examples:**

Example 1 (tsx):
```tsx
<FacetValueSelector onValueSelect={onValueSelectHandler} disabled={disabled} />
```

Example 2 (ts):
```ts
function FacetValueSelector(props: FacetValueSelectorProps): void
```

Example 3 (ts):
```ts
interface FacetValueSelectorProps {    onValueSelect: (value: FacetValue) => void;    disabled?: boolean;    placeholder?: string;    pageSize?: number;}
```

Example 4 (ts):
```ts
{    id: string;    name: string;    code: string;    facet: {        id: string;        name: string;        code: string;    };}
```

---

## I18nError

**URL:** https://docs.vendure.io/reference/typescript-api/errors/i18n-error

**Contents:**
- I18nError
- I18nError‚Äã
  - constructor‚Äã

All errors thrown in the Vendure server must use or extend this error class. This allows the error message to be translated before being served to the client.

The error messages should be provided in the form of a string key which corresponds to a key defined in the i18n/messages/<languageCode>.json files.

Note that this class should not be directly used in code, but should be extended by a more specific Error class.

**Examples:**

Example 1 (ts):
```ts
class I18nError extends GraphQLError {    constructor(message: string, variables: { [key: string]: string | number } = {}, code?: string, logLevel: LogLevel = LogLevel.Warn)}
```

---

## StripePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/payments-plugin/stripe-plugin

**Contents:**
- StripePlugin
- StripePlugin‚Äã
- Requirements‚Äã
- Setup‚Äã
- Storefront usage‚Äã
- Local development‚Äã
  - options‚Äã
  - init‚Äã
- StripePluginOptions‚Äã
  - storeCustomersInStripe‚Äã

Plugin to enable payments through Stripe via the Payment Intents API.

You will need to create a Stripe account and get your secret key in the dashboard.

Create a webhook endpoint in the Stripe dashboard (Developers -> Webhooks, "Add an endpoint") which listens to the payment_intent.succeeded and payment_intent.payment_failed events. The URL should be https://my-server.com/payments/stripe, where my-server.com is the host of your Vendure server. Note: for local development, you'll need to use the Stripe CLI to test your webhook locally. See the local development section below.

Get the signing secret for the newly created webhook.

Install the Payments plugin and the Stripe Node library:

yarn add @vendure/payments-plugin stripe

npm install @vendure/payments-plugin stripe

The plugin is designed to work with the Custom payment flow. In this flow, Stripe provides libraries which handle the payment UI and confirmation for you. You can install it in your storefront project with:

If you are using React, you should also consider installing @stripe/react-stripe-js, which is a wrapper around Stripe Elements.

The high-level workflow is:

A full working storefront example of the Stripe integration can be found in the Remix Starter repo

Initialize the Stripe payment plugin

Configuration options for the Stripe payments plugin.

If set to true, a Customer object will be created in Stripe - if it doesn't already exist - for authenticated users, which prevents payment methods attached to other Customers to be used with the same PaymentIntent. This is done by adding a custom field to the Customer entity to store the Stripe customer ID, so switching this on will require a database migration / synchronization.

Attach extra metadata to Stripe payment intent creation call.

Note: If the paymentIntentCreateParams is also used and returns a metadata key, then the values returned by both functions will be merged.

Provide additional parameters to the Stripe payment intent creation. By default, the plugin will already pass the amount, currency, customer and automatic_payment_methods: { enabled: true } parameters.

For example, if you want to provide a description for the payment intent, you can do so like this:

Provide additional options to the Stripe payment intent creation. By default, the plugin will already pass the idempotencyKey parameter.

For example, if you want to provide a stripeAccount for the payment intent, you can do so like this:

Provide additional parameters to the Stripe customer creation. By default, the plugin will already pass the `email` and `name` parameters. This allows you to add additional fields such as address information to the Stripe customer object.

For example, if you want to provide address details for the customer, you can do so like this:

```typescript
import { EntityHydrator, VendureConfig } from '@vendure/core';
import { StripePlugin } from '@vendure/payments-plugin/package/stripe';

export const config: VendureConfig = {
  plugins: [
    StripePlugin.init({
      storeCustomersInStripe: true,
      customerCreateParams: async (injector, ctx, order) => {
        const entityHydrator = injector.get(EntityHydrator);
        const customer = order.customer;
        await entityHydrator.hydrate(ctx, customer, { relations: ['addresses'] });
        const defaultBillingAddress = customer.addresses.find(a => a.defaultBillingAddress) ?? customer.addresses[0];
        return {
          address: {
            line1: defaultBillingAddress.streetLine1 || order.shippingAddress?.streetLine1,
            postal_code: defaultBillingAddress.postalCode || order.shippingAddress?.postalCode,
            city: defaultBillingAddress.city || order.shippingAddress?.city,
            state: defaultBillingAddress.province || order.shippingAddress?.province,
            country: defaultBillingAddress.country.code || order.shippingAddress?.countryCode,
          },
        };
      }
    }),
  ],
};
```

**Examples:**

Example 1 (ts):
```ts
import { StripePlugin } from '@vendure/payments-plugin/package/stripe';// ...plugins: [  StripePlugin.init({    // This prevents different customers from using the same PaymentIntent    storeCustomersInStripe: true,  }),]
```

Example 2 (shell):
```shell
yarn add @stripe/stripe-js# ornpm install @stripe/stripe-js
```

Example 3 (ts):
```ts
import { Elements } from '@stripe/react-stripe-js';import { loadStripe, Stripe } from '@stripe/stripe-js';import { CheckoutForm } from './CheckoutForm';const stripePromise = getStripe('pk_test_....wr83u');type StripePaymentsProps = {  clientSecret: string;  orderCode: string;}export function StripePayments({ clientSecret, orderCode }: StripePaymentsProps) {  const options = {    // passing the client secret obtained from the server    clientSecret,  }  return (    <Elements stripe={stripePromise} options={options}>      <CheckoutForm orderCode={orderCode} />    </Elements>  );}
```

Example 4 (ts):
```ts
// CheckoutForm.tsximport { useStripe, useElements, PaymentElement } from '@stripe/react-stripe-js';import { FormEvent } from 'react';export const CheckoutForm = ({ orderCode }: { orderCode: string }) => {  const stripe = useStripe();  const elements = useElements();  const handleSubmit = async (event: FormEvent) => {    // We don't want to let default form submission happen here,    // which would refresh the page.    event.preventDefault();    if (!stripe || !elements) {      // Stripe.js has not yet loaded.      // Make sure to disable form submission until Stripe.js has loaded.      return
...
```

---

## Nav Menu

**URL:** https://docs.vendure.io/reference/admin-ui-api/nav-menu/

**Contents:**
- Nav Menu
- üìÑÔ∏è AddNavMenuItem
- üìÑÔ∏è AddNavMenuSection
- üìÑÔ∏è NavMenuItem
- üìÑÔ∏è NavMenuSection
- üìÑÔ∏è Navigation Types

---

## HistoryEntries

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/history-entries

**Contents:**
- HistoryEntries
- DashboardHistoryEntryComponent‚Äã
  - type‚Äã
  - component‚Äã
- HistoryEntryItem‚Äã
  - id‚Äã
  - type‚Äã
  - createdAt‚Äã
  - isPublic‚Äã
  - administrator‚Äã

A definition of a custom component that will be used to render the given type of history entry.

The type should correspond to a valid HistoryEntryType, such as

The component which is used to render the timeline entry. It should use the HistoryEntry component and pass the appropriate props to configure how it will be displayed.

The entity prop will be a subset of the Order object for Order history entries, or a subset of the Customer object for customer history entries.

This object contains the information about the history entry.

The HistoryEntryType, such as ORDER_STATE_TRANSITION.

Whether this entry is visible to customers via the Shop API

If an Administrator created this entry, their details will be available here.

The entry payload data. This will be an object, which is different for each type of history entry.

For example, the CUSTOMER_ADDED_TO_GROUP data looks like this:

and the ORDER_STATE_TRANSITION data looks like this:

The props for the HistoryEntry component.

The entry itself, which will get passed down to your custom component

The title of the entry

An icon which is used to represent the entry. Note that this will only display if isPrimary is true.

Optional tailwind classes to apply to the icon. For instance

The name to display of "who did the action". For instance:

When set to true, the timeline entry will feature the specified icon and will not be collapsible.

A component which is used to display a history entry in the order/customer history timeline.

**Examples:**

Example 1 (tsx):
```tsx
import { defineDashboardExtension, HistoryEntry } from '@vendure/dashboard';import { IdCard } from 'lucide-react';defineDashboardExtension({    historyEntries: [        {            type: 'CUSTOMER_TAX_ID_APPROVAL',            component: ({ entry, entity }) => {                return (                    <HistoryEntry                        entry={entry}                        title={'Tax ID verified'}                        timelineIconClassName={'bg-success text-success-foreground'}                        timelineIcon={<IdCard />}                    >                        <div className="t
...
```

Example 2 (ts):
```ts
interface DashboardHistoryEntryComponent {    type: string;    component: React.ComponentType<{        entry: HistoryEntryItem;        entity: OrderHistoryOrderDetail | CustomerHistoryCustomerDetail;    }>;}
```

Example 3 (ts):
```ts
interface HistoryEntryItem {    id: string;    type: string;    createdAt: string;    isPublic: boolean;    administrator?: {        id: string;        firstName: string;        lastName: string;    } | null;    data: any;}
```

Example 4 (json):
```json
{  groupName: 'Some Group',}
```

---

## BaseDetailComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/base-detail-component

**Contents:**
- BaseDetailComponent
- BaseDetailComponent‚Äã
  - entity$‚Äã
  - availableLanguages$‚Äã
  - languageCode$‚Äã
  - languageCode‚Äã
  - isNew$‚Äã
  - id‚Äã
  - detailForm‚Äã
  - destroy$‚Äã

A base class for entity detail views. It should be used in conjunction with the BaseEntityResolver.

**Examples:**

Example 1 (ts):
```ts
@Component({  selector: 'app-my-entity',  templateUrl: './my-entity.component.html',  styleUrls: ['./my-entity.component.scss'],  changeDetection: ChangeDetectionStrategy.OnPush,})export class GlobalSettingsComponent extends BaseDetailComponent<MyEntityFragment> implements OnInit {  detailForm: FormGroup;  constructor(    router: Router,    route: ActivatedRoute,    serverConfigService: ServerConfigService,    protected dataService: DataService,    private formBuilder: FormBuilder,  ) {    super(route, router, serverConfigService, dataService);    this.detailForm = this.formBuilder.group({    
...
```

Example 2 (ts):
```ts
class BaseDetailComponent<Entity extends { id: string; updatedAt?: string }> implements DeactivateAware {    entity$: Observable<Entity>;    availableLanguages$: Observable<LanguageCode[]>;    languageCode$: Observable<LanguageCode>;    languageCode: LanguageCode;    isNew$: Observable<boolean>;    id: string;    abstract detailForm: UntypedFormGroup;    protected destroy$ = new Subject<void>();    constructor(route: ActivatedRoute, router: Router, serverConfigService: ServerConfigService, dataService: DataService, permissionsService: PermissionsService)    init() => ;    setUpStreams() => ;  
...
```

---

## PresetOnlyStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/preset-only-strategy/

**Contents:**
- PresetOnlyStrategy
- PresetOnlyStrategy‚Äã
  - constructor‚Äã
  - getImageTransformParameters‚Äã
- PresetOnlyStrategyOptions‚Äã
  - defaultPreset‚Äã
  - permittedQuality‚Äã
  - permittedFormats‚Äã
  - allowFocalPoint‚Äã

An ImageTransformStrategy which only allows transformations to be made using presets which are defined in the available presets.

With this strategy enabled, requests to the asset server must include a preset parameter (or use the default preset)

This is valid: http://localhost:3000/assets/some-asset.jpg?preset=medium

This is invalid: http://localhost:3000/assets/some-asset.jpg?w=200&h=200, and the dimensions will be ignored.

The strategy can be configured to allow only certain quality values and formats, and to optionally allow the focal point to be specified in the URL.

If a preset is not found in the available presets, an error will be thrown.

Configuration options for the PresetOnlyStrategy.

The name of the default preset to use if no preset is specified in the URL.

The permitted quality of the transformed images. If set to 'any', then any quality is permitted. If set to an array of numbers (0-100), then only those quality values are permitted.

The permitted formats of the transformed images. If set to 'any', then any format is permitted. If set to an array of strings e.g. ['jpg', 'webp'], then only those formats are permitted.

Whether to allow the focal point to be specified in the URL.

**Examples:**

Example 1 (ts):
```ts
import { AssetServerPlugin, PresetOnlyStrategy } from '@vendure/core';// ...AssetServerPlugin.init({  //...  imageTransformStrategy: new PresetOnlyStrategy({    defaultPreset: 'thumbnail',    permittedQuality: [0, 50, 75, 85, 95],    permittedFormats: ['jpg', 'webp', 'avif'],    allowFocalPoint: true,  }),});
```

Example 2 (ts):
```ts
class PresetOnlyStrategy implements ImageTransformStrategy {    constructor(options: PresetOnlyStrategyOptions)    getImageTransformParameters({        input,        availablePresets,    }: GetImageTransformParametersArgs) => Promise<ImageTransformParameters> | ImageTransformParameters;}
```

Example 3 (ts):
```ts
interface PresetOnlyStrategyOptions {    defaultPreset: string;    permittedQuality?: number[];    permittedFormats?: ImageTransformFormat[];    allowFocalPoint?: boolean;}
```

---

## RedisCacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/cache/redis-cache-strategy

**Contents:**
- RedisCacheStrategy
- RedisCacheStrategy‚Äã
  - constructor‚Äã
  - init‚Äã
  - destroy‚Äã
  - get‚Äã
  - set‚Äã
  - delete‚Äã
  - invalidateTags‚Äã

A CacheStrategy which stores cached items in a Redis instance. This is a high-performance cache strategy which is suitable for production use.

Note: To use this strategy, you need to manually install the ioredis package:

**Examples:**

Example 1 (shell):
```shell
npm install ioredis@^5.3.2
```

Example 2 (ts):
```ts
class RedisCacheStrategy implements CacheStrategy {    constructor(options: RedisCachePluginInitOptions)    init() => ;    destroy() => ;    get(key: string) => Promise<T | undefined>;    set(key: string, value: T, options?: SetCacheKeyOptions) => Promise<void>;    delete(key: string) => Promise<void>;    invalidateTags(tags: string[]) => Promise<void>;}
```

---

## InMemorySessionCacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/in-memory-session-cache-strategy

**Contents:**
- InMemorySessionCacheStrategy
- InMemorySessionCacheStrategy‚Äã
  - constructor‚Äã
  - delete‚Äã
  - get‚Äã
  - set‚Äã
  - clear‚Äã

Caches session in memory, using a LRU cache implementation. Not suitable for multi-server setups since the cache will be local to each instance, reducing its effectiveness. By default the cache has a size of 1000, meaning that after 1000 sessions have been cached, any new sessions will cause the least-recently-used session to be evicted (removed) from the cache.

The cache size can be configured by passing a different number to the constructor function.

**Examples:**

Example 1 (ts):
```ts
class InMemorySessionCacheStrategy implements SessionCacheStrategy {    constructor(cacheSize?: number)    delete(sessionToken: string) => ;    get(sessionToken: string) => ;    set(session: CachedSession) => ;    clear() => ;}
```

---

## Custom Table Components

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-table-components/

**Contents:**
- Custom Table Components
- üìÑÔ∏è CustomColumnComponent
- üìÑÔ∏è DataTableComponentConfig
- üìÑÔ∏è RegisterDataTableComponent

CustomColumnComponent

DataTableComponentConfig

registerDataTableComponent

---

## SystemOptions

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/system-options

**Contents:**
- SystemOptions
- SystemOptions‚Äã
  - healthChecks‚Äã
  - errorHandlers‚Äã
  - cacheStrategy‚Äã
  - instrumentationStrategy‚Äã

Options relating to system functions.

Defines an array of HealthCheckStrategy instances which are used by the /health endpoint to verify that any critical systems which the Vendure server depends on are also healthy.

Defines an array of ErrorHandlerStrategy instances which are used to define logic to be executed when an error occurs, either on the server or the worker.

Defines the underlying method used to store cache key-value pairs which powers the CacheService.

**Examples:**

Example 1 (ts):
```ts
interface SystemOptions {    healthChecks?: HealthCheckStrategy[];    errorHandlers?: ErrorHandlerStrategy[];    cacheStrategy?: CacheStrategy;    instrumentationStrategy?: InstrumentationStrategy;}
```

---

## PasswordValidationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/password-validation-strategy

**Contents:**
- PasswordValidationStrategy
- PasswordValidationStrategy‚Äã
  - validate‚Äã

Defines validation to apply to new password (when creating an account or updating an existing account's password when using the NativeAuthenticationStrategy.

This is configured via the authOptions.passwordValidationStrategy property of your VendureConfig.

Validates a password submitted during account registration or when a customer updates their password. The method should resolve to true if the password is acceptable. If not, it should return false or optionally a string which will be passed to the returned ErrorResult, which can e.g. advise on why exactly the proposed password is not valid.

**Examples:**

Example 1 (ts):
```ts
interface PasswordValidationStrategy extends InjectableStrategy {    validate(ctx: RequestContext, password: string): Promise<boolean | string> | boolean | string;}
```

---

## FulfillmentService

**URL:** https://docs.vendure.io/reference/typescript-api/services/fulfillment-service

**Contents:**
- FulfillmentService
- FulfillmentService‚Äã
  - constructor‚Äã
  - create‚Äã
  - getFulfillmentLines‚Äã
  - getFulfillmentsLinesForOrderLine‚Äã
  - transitionToState‚Äã
  - getNextStates‚Äã

Contains methods relating to Fulfillment entities.

Creates a new Fulfillment for the given Orders and OrderItems, using the specified FulfillmentHandler.

Transitions the specified Fulfillment to a new state and upon successful transition publishes a FulfillmentStateTransitionEvent.

Returns an array of the next valid states for the Fulfillment.

**Examples:**

Example 1 (ts):
```ts
class FulfillmentService {    constructor(connection: TransactionalConnection, fulfillmentStateMachine: FulfillmentStateMachine, eventBus: EventBus, configService: ConfigService, customFieldRelationService: CustomFieldRelationService)    create(ctx: RequestContext, orders: Order[], lines: OrderLineInput[], handler: ConfigurableOperationInput) => Promise<Fulfillment | InvalidFulfillmentHandlerError | CreateFulfillmentError>;    getFulfillmentLines(ctx: RequestContext, id: ID) => Promise<FulfillmentLine[]>;    getFulfillmentsLinesForOrderLine(ctx: RequestContext, orderLineId: ID, relations: Rela
...
```

---

## Country

**URL:** https://docs.vendure.io/reference/typescript-api/entities/country/

**Contents:**
- Country
- Country‚Äã
  - constructor‚Äã
  - type‚Äã

A country to which is available when creating / updating an Address. Countries are grouped together into Zones which are in turn used to determine applicable shipping and taxes for an Order.

**Examples:**

Example 1 (ts):
```ts
class Country extends Region {    constructor(input?: DeepPartial<Country>)    readonly type: RegionType = 'country';}
```

---

## PresetOnlyStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/preset-only-strategy

**Contents:**
- PresetOnlyStrategy
- PresetOnlyStrategy‚Äã
  - constructor‚Äã
  - getImageTransformParameters‚Äã
- PresetOnlyStrategyOptions‚Äã
  - defaultPreset‚Äã
  - permittedQuality‚Äã
  - permittedFormats‚Äã
  - allowFocalPoint‚Äã

An ImageTransformStrategy which only allows transformations to be made using presets which are defined in the available presets.

With this strategy enabled, requests to the asset server must include a preset parameter (or use the default preset)

This is valid: http://localhost:3000/assets/some-asset.jpg?preset=medium

This is invalid: http://localhost:3000/assets/some-asset.jpg?w=200&h=200, and the dimensions will be ignored.

The strategy can be configured to allow only certain quality values and formats, and to optionally allow the focal point to be specified in the URL.

If a preset is not found in the available presets, an error will be thrown.

Configuration options for the PresetOnlyStrategy.

The name of the default preset to use if no preset is specified in the URL.

The permitted quality of the transformed images. If set to 'any', then any quality is permitted. If set to an array of numbers (0-100), then only those quality values are permitted.

The permitted formats of the transformed images. If set to 'any', then any format is permitted. If set to an array of strings e.g. ['jpg', 'webp'], then only those formats are permitted.

Whether to allow the focal point to be specified in the URL.

**Examples:**

Example 1 (ts):
```ts
import { AssetServerPlugin, PresetOnlyStrategy } from '@vendure/core';// ...AssetServerPlugin.init({  //...  imageTransformStrategy: new PresetOnlyStrategy({    defaultPreset: 'thumbnail',    permittedQuality: [0, 50, 75, 85, 95],    permittedFormats: ['jpg', 'webp', 'avif'],    allowFocalPoint: true,  }),});
```

Example 2 (ts):
```ts
class PresetOnlyStrategy implements ImageTransformStrategy {    constructor(options: PresetOnlyStrategyOptions)    getImageTransformParameters({        input,        availablePresets,    }: GetImageTransformParametersArgs) => Promise<ImageTransformParameters> | ImageTransformParameters;}
```

Example 3 (ts):
```ts
interface PresetOnlyStrategyOptions {    defaultPreset: string;    permittedQuality?: number[];    permittedFormats?: ImageTransformFormat[];    allowFocalPoint?: boolean;}
```

---

## AdminUiPluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/admin-ui-plugin/admin-ui-plugin-options

**Contents:**
- AdminUiPluginOptions
- AdminUiPluginOptions‚Äã
  - route‚Äã
  - port‚Äã
  - hostname‚Äã
  - app‚Äã
  - adminUiConfig‚Äã
  - compatibilityMode‚Äã

Configuration options for the AdminUiPlugin.

The route to the Admin UI.

Note: If you are using the compileUiExtensions function to compile a custom version of the Admin UI, then the route should match the baseHref option passed to that function. The default value of baseHref is /admin/, so it only needs to be changed if you set this route option to something other than "admin".

The port on which the server will listen. This port will be proxied by the AdminUiPlugin to the same port that the Vendure server is running on.

The hostname of the server serving the static admin ui files.

By default, the AdminUiPlugin comes bundles with a pre-built version of the Admin UI. This option can be used to override this default build with a different version, e.g. one pre-compiled with one or more ui extensions.

Allows the contents of the vendure-ui-config.json file to be set, e.g. for specifying the Vendure GraphQL API host, available UI languages, etc.

If you are running the AdminUiPlugin at the same time as the new DashboardPlugin, you should set this to true in order to avoid a conflict caused by both plugins defining the same schema extensions.

**Examples:**

Example 1 (ts):
```ts
interface AdminUiPluginOptions {    route: string;    port: number;    hostname?: string;    app?: AdminUiAppConfig | AdminUiAppDevModeConfig;    adminUiConfig?: Partial<AdminUiConfig>;    compatibilityMode?: boolean;}
```

---

## StructCustomFieldConfig

**URL:** https://docs.vendure.io/reference/typescript-api/custom-fields/struct-custom-field-config

**Contents:**
- StructCustomFieldConfig
- StructCustomFieldConfig‚Äã

Configures a "struct" custom field.

**Examples:**

Example 1 (ts):
```ts
type StructCustomFieldConfig = TypedCustomFieldConfig<    'struct',    Omit<GraphQLStructCustomFieldConfig, 'fields'>> & {    fields: StructFieldConfig[];}
```

---

## CurrencyInputComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/currency-input-component

**Contents:**
- CurrencyInputComponent
- CurrencyInputComponent‚Äã
  - disabled‚Äã
  - readonly‚Äã
  - value‚Äã
  - currencyCode‚Äã
  - valueChange‚Äã
  - prefix$‚Äã
  - suffix$‚Äã
  - hasFractionPart‚Äã

A form input control which displays currency in decimal format, whilst working with the integer cent value in the background.

**Examples:**

Example 1 (html):
```html
<vdr-currency-input    [(ngModel)]="entityPrice"    [currencyCode]="currencyCode"></vdr-currency-input>
```

Example 2 (ts):
```ts
class CurrencyInputComponent implements ControlValueAccessor, OnInit, OnChanges, OnDestroy {    @Input() disabled = false;    @Input() readonly = false;    @Input() value: number;    @Input() currencyCode = '';    @Output() valueChange = new EventEmitter();    prefix$: Observable<string>;    suffix$: Observable<string>;    hasFractionPart = true;    onChange: (val: any) => void;    onTouch: () => void;    _inputValue: string;    readonly precision: number;    readonly precisionFactor: number;    constructor(dataService: DataService, currencyService: CurrencyService)    ngOnInit() => ;    ngOnC
...
```

---

## JobBuffer

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job-buffer

**Contents:**
- JobBuffer
- JobBuffer‚Äã
  - id‚Äã
  - collect‚Äã
  - reduce‚Äã

A JobBuffer is used to temporarily prevent jobs from being sent to the job queue for processing. Instead, it collects certain jobs (as specified by the collect() method), and stores them.

How these buffered jobs are stored is determined by the configured JobBufferStorageStrategy.

The JobBuffer can be thought of as a kind of "interceptor" of jobs. That is, when a JobBuffer is active, it sits in between calls to JobQueue.add() and the actual adding of the job to the queue.

At some later point, the buffer can be flushed (by calling JobQueue.flush()), at which point all the jobs that were collected into the buffer will be removed from the buffer and passed to the JobBuffer.reduce() method. This method is able to perform additional logic to e.g. aggregate many jobs into a single job in order to de-duplicate work.

A JobBuffer is used by adding it to the JobQueueService, at which point it will become active and start collecting jobs.

At some later point, the buffer can be flushed, causing the buffered jobs to be passed through the reduce() method and sent to the job queue.

This method is called whenever a job is added to the job queue. If it returns true, then the job will be buffered and not added to the job queue. If it returns false, the job will be added to the job queue as normal.

This method is called whenever the buffer gets flushed via a call to JobQueueService.flush(). It allows logic to be run on the buffered jobs which enables optimizations such as aggregating and de-duplicating the work of many jobs into one job.

**Examples:**

Example 1 (ts):
```ts
// This is a buffer which will collect all the// 'apply-collection-filters' jobs and buffer them.export class CollectionJobBuffer implements JobBuffer<ApplyCollectionFiltersJobData> {  readonly id = 'apply-collection-filters-buffer';  collect(job: Job): boolean {    return job.queueName === 'apply-collection-filters';  }  // When the buffer gets flushed, this function will be passed all the collected jobs  // and will reduce them down to a single job that has aggregated all of the collectionIds.  reduce(collectedJobs: Array<Job<ApplyCollectionFiltersJobData>>): Array<Job<any>> {    // Concaten
...
```

Example 2 (ts):
```ts
const collectionBuffer = new CollectionJobBuffer();await this.jobQueueService.addBuffer(collectionBuffer);// Here you can perform some work which would ordinarily// trigger the 'apply-collection-filters' job, such as updating// collection filters or changing ProductVariant prices.await this.jobQueueService.flush(collectionBuffer);await this.jobQueueService.removeBuffer(collectionBuffer);
```

Example 3 (ts):
```ts
interface JobBuffer<Data extends JobData<Data> = object> {    readonly id: string;    collect(job: Job<Data>): boolean | Promise<boolean>;    reduce(collectedJobs: Array<Job<Data>>): Array<Job<Data>> | Promise<Array<Job<Data>>>;}
```

---

## TextareaInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/textarea-input

**Contents:**
- TextareaInput
- TextareaInput‚Äã
  - props‚Äã

A component for displaying a textarea input.

**Examples:**

Example 1 (ts):
```ts
function TextareaInput(props: Readonly<DashboardFormComponentProps>): void
```

---

## Scheduled Tasks

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/

**Contents:**
- Scheduled Tasks
- üìÑÔ∏è CleanSessionsTask
- üìÑÔ∏è DefaultSchedulerPlugin
- üìÑÔ∏è DefaultSchedulerStrategy
- üìÑÔ∏è ScheduledTask
- üìÑÔ∏è SchedulerOptions
- üìÑÔ∏è SchedulerService
- üìÑÔ∏è SchedulerStrategy

DefaultSchedulerPlugin

DefaultSchedulerStrategy

---

## EmailGenerator

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-generator

**Contents:**
- EmailGenerator
- EmailGenerator‚Äã
  - onInit‚Äã
  - generate‚Äã
- HandlebarsMjmlGenerator‚Äã
  - onInit‚Äã
  - generate‚Äã

An EmailGenerator generates the subject and body details of an email.

Any necessary setup can be performed here.

Given a subject and body from an email template, this method generates the final interpolated email text.

Uses Handlebars (https://handlebarsjs.com/) to output MJML (https://mjml.io) which is then compiled down to responsive email HTML.

**Examples:**

Example 1 (ts):
```ts
interface EmailGenerator<T extends string = any, E extends VendureEvent = any> extends InjectableStrategy {    onInit?(options: EmailPluginOptions): void | Promise<void>;    generate(        from: string,        subject: string,        body: string,        templateVars: { [key: string]: any },    ): Pick<EmailDetails, 'from' | 'subject' | 'body'>;}
```

Example 2 (ts):
```ts
class HandlebarsMjmlGenerator implements EmailGenerator {    onInit(options: InitializedEmailPluginOptions) => ;    generate(from: string, subject: string, template: string, templateVars: any) => ;}
```

---

## Facet

**URL:** https://docs.vendure.io/reference/typescript-api/entities/facet/

**Contents:**
- Facet
- Facet‚Äã
  - constructor‚Äã
  - name‚Äã
  - isPrivate‚Äã
  - code‚Äã
  - translations‚Äã
  - values‚Äã
  - customFields‚Äã
  - channels‚Äã

A Facet is a class of properties which can be applied to a Product or ProductVariant. They are used to enable faceted search whereby products can be filtered along a number of dimensions (facets).

For example, there could be a Facet named "Brand" which has a number of FacetValues representing the various brands of product, e.g. "Apple", "Samsung", "Dell", "HP" etc.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware

**Examples:**

Example 1 (ts):
```ts
class Facet extends VendureEntity implements Translatable, HasCustomFields, ChannelAware {    constructor(input?: DeepPartial<Facet>)    name: LocaleString;    @Column({ default: false })    isPrivate: boolean;    @Column({ unique: true })    code: string;    @OneToMany(type => FacetTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<Facet>>;    @OneToMany(type => FacetValue, value => value.facet)    values: FacetValue[];    @Column(type => CustomFacetFields)    customFields: CustomFacetFields;    @ManyToMany(type => Channel, channel => channel.fac
...
```

---

## ProductOptionGroupService

**URL:** https://docs.vendure.io/reference/typescript-api/services/product-option-group-service

**Contents:**
- ProductOptionGroupService
- ProductOptionGroupService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - getOptionGroupsByProductId‚Äã
  - create‚Äã
  - update‚Äã
  - deleteGroupAndOptionsFromProduct‚Äã

Contains methods relating to ProductOptionGroup entities.

Deletes the ProductOptionGroup and any associated ProductOptions. If the ProductOptionGroup is still referenced by a soft-deleted Product, then a soft-delete will be used to preserve referential integrity. Otherwise a hard-delete will be performed.

**Examples:**

Example 1 (ts):
```ts
class ProductOptionGroupService {    constructor(connection: TransactionalConnection, translatableSaver: TranslatableSaver, customFieldRelationService: CustomFieldRelationService, productOptionService: ProductOptionService, eventBus: EventBus, translator: TranslatorService)    findAll(ctx: RequestContext, filterTerm?: string, relations?: RelationPaths<ProductOptionGroup>) => Promise<Array<Translated<ProductOptionGroup>>>;    findOne(ctx: RequestContext, id: ID, relations?: RelationPaths<ProductOptionGroup>, findOneOptions?: { includeSoftDeleted: boolean }) => Promise<Translated<ProductOptionGr
...
```

---

## GraphiqlPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/graphiql-plugin/

**Contents:**
- GraphiqlPlugin
- GraphiqlPlugin‚Äã
- Installation‚Äã
- Custom API paths‚Äã
- Query parameters‚Äã
  - options‚Äã
  - constructor‚Äã
  - init‚Äã
  - configure‚Äã

This plugin provides a GraphiQL UI for exploring and testing the Vendure GraphQL APIs.

It adds routes /graphiql/admin and /graphiql/shop which serve the GraphiQL interface for the respective APIs.

By default, the plugin automatically reads the Admin API and Shop API paths from your Vendure configuration.

If you need to override these paths, you can specify them explicitly:

You can add the following query parameters to the GraphiQL URL:

**Examples:**

Example 1 (ts):
```ts
import { GraphiqlPlugin } from '@vendure/graphiql-plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    GraphiqlPlugin.init({      route: 'graphiql', // Optional, defaults to 'graphiql'    }),  ],};
```

Example 2 (typescript):
```typescript
GraphiQLPlugin.init({    route: 'my-custom-route', // defaults to `graphiql`});
```

Example 3 (ts):
```ts
class GraphiqlPlugin implements NestModule {    static options: Required<GraphiqlPluginOptions>;    constructor(processContext: ProcessContext, configService: ConfigService, graphiQLService: GraphiQLService)    init(options: GraphiqlPluginOptions = {}) => Type<GraphiqlPlugin>;    configure(consumer: MiddlewareConsumer) => ;}
```

---

## Storefront GraphQL Code Generation

**URL:** https://docs.vendure.io/guides/storefront/codegen/

**Contents:**
- Storefront GraphQL Code Generation
- Installation‚Äã
- Configuration‚Äã
- Running Codegen‚Äã
- Use the graphql() function‚Äã

Code generation means the automatic generation of TypeScript types based on your GraphQL schema and your GraphQL operations. This is a very powerful feature that allows you to write your code in a type-safe manner, without you needing to manually write any types for your API calls.

To do this, we will use Graphql Code Generator.

This guide is for adding codegen to your storefront. For a guide on adding codegen to your backend Vendure plugins or UI extensions, see the Plugin Codegen guide.

Follow the installation instructions in the GraphQL Code Generator Quick Start.

During the init step, you'll be prompted to select various options about how to configure the code generation.

The init step above will create a codegen.ts file in your project root. Add the highlighted lines:

During the init step, you will have installed a codegen script in your package.json. You can run this script to generate the TypeScript types for your GraphQL operations.

Ensure you have the Vendure server running before running the codegen script.

This will generate a src/gql directory containing the TypeScript types for your GraphQL operations.

If you have existing GraphQL queries and mutations in your application, you can now use the graphql() function exported by the src/gql/index.ts file to execute them. If you were previously using the gql tagged template function, replace it with the graphql() function.

In the above example, the type information all works out of the box because the graphql-request library from v5.0.0 has built-in support for the TypedDocumentNode type, as do the latest versions of most of the popular GraphQL client libraries, such as Apollo Client & Urql.

In the documentation examples on other pages, we do not assume the use of code generation in order to keep the examples as simple as possible.

**Examples:**

Example 1 (bash):
```bash
npm i graphqlnpm i -D typescript @graphql-codegen/clinpx graphql-code-generator initnpm install
```

Example 2 (ts):
```ts
import type { CodegenConfig } from '@graphql-codegen/cli';const config: CodegenConfig = {  overwrite: true,  schema: 'http://localhost:3000/shop-api',  documents: 'src/**/*.graphql.ts',  generates: {    'src/gql/': {      preset: 'client',      plugins: [],      config: {        scalars: {            // This tells codegen that the `Money` scalar is a number            Money: 'number',        },        namingConvention: {            // This ensures generated enums do not conflict with the built-in types.            enumValues: 'keep',        },      }    },  }};export default config;
```

Example 3 (bash):
```bash
npm run codegen
```

Example 4 (ts):
```ts
import { useQuery } from '@tanstack/react-query';import request from 'graphql-request'import { graphql } from './gql';// GET_PRODUCTS will be a `TypedDocumentNode` type,// which encodes the types of the query variables and the response data.const GET_PRODUCTS = graphql(`    query GetProducts($options: ProductListOptions) {        products(options: $options) {            items {                id                name                slug                featuredAsset {                    preview                }            }        }    }`);export default function App() {  // `data` will now be co
...
```

---

## InitializerService

**URL:** https://docs.vendure.io/reference/typescript-api/services/initializer-service

**Contents:**
- InitializerService
- InitializerService‚Äã
  - constructor‚Äã
  - onModuleInit‚Äã

Only used internally to run the various service init methods in the correct sequence on bootstrap.

**Examples:**

Example 1 (ts):
```ts
class InitializerService {    constructor(connection: TransactionalConnection, zoneService: ZoneService, channelService: ChannelService, roleService: RoleService, administratorService: AdministratorService, shippingMethodService: ShippingMethodService, globalSettingsService: GlobalSettingsService, taxRateService: TaxRateService, sellerService: SellerService, eventBus: EventBus, stockLocationService: StockLocationService)    onModuleInit() => ;}
```

---

## Role

**URL:** https://docs.vendure.io/reference/typescript-api/entities/role

**Contents:**
- Role
- Role‚Äã
  - constructor‚Äã
  - code‚Äã
  - description‚Äã
  - permissions‚Äã
  - channels‚Äã

A Role represents a collection of permissions which determine the authorization level of a User on a given set of Channels.

Extends: VendureEntity

Implements: ChannelAware

**Examples:**

Example 1 (ts):
```ts
class Role extends VendureEntity implements ChannelAware {    constructor(input?: DeepPartial<Role>)    @Column() code: string;    @Column() description: string;    @Column('simple-array') permissions: Permission[];    @ManyToMany(type => Channel, channel => channel.roles)    @JoinTable()    channels: Channel[];}
```

---

## ElasticsearchOptions

**URL:** https://docs.vendure.io/reference/core-plugins/elasticsearch-plugin/elasticsearch-options

**Contents:**
- ElasticsearchOptions
- ElasticsearchOptions‚Äã
  - host‚Äã
  - port‚Äã
  - connectionAttempts‚Äã
  - connectionAttemptInterval‚Äã
  - clientOptions‚Äã
  - indexPrefix‚Äã
  - indexSettings‚Äã
  - indexMappingProperties‚Äã

Configuration options for the ElasticsearchPlugin.

The host of the Elasticsearch server. May also be specified in clientOptions.node.

The port of the Elasticsearch server. May also be specified in clientOptions.node.

Maximum amount of attempts made to connect to the ElasticSearch server on startup.

Interval in milliseconds between attempts to connect to the ElasticSearch server on startup.

Options to pass directly to the Elasticsearch Node.js client. For example, to set authentication or other more advanced options. Note that if the node or nodes option is specified, it will override the values provided in the host and port options.

Prefix for the indices created by the plugin.

These options are directly passed to index settings. To apply some settings indices will be recreated.

A more complete example can be found in the discussion thread How to make elastic plugin to search by substring with stemming.

This option allow to redefine or define new properties in mapping. More about elastic mapping After changing this option indices will be recreated.

To reference a field defined by customProductMappings or customProductVariantMappings, you will need to prefix the name with 'product-<name>' or 'variant-<name>' respectively, e.g.:

Products limit chunk size for each loop iteration when indexing products.

Index operations are performed in bulk, with each bulk operation containing a number of individual index operations. This option sets the maximum number of operations in the memory buffer before a bulk operation is executed.

Configuration of the internal Elasticsearch query.

Custom mappings may be defined which will add the defined data to the Elasticsearch index and expose that data via the SearchResult GraphQL type, adding a new customMappings, customProductMappings & customProductVariantMappings fields.

The graphQlType property may be one of String, Int, Float, Boolean, ID or list versions thereof ([String!] etc) and can be appended with a ! to indicate non-nullable fields.

The public (default = true) property is used to reveal or hide the property in the GraphQL API schema. If this property is set to false it's not accessible in the customMappings field but it's still getting parsed to the elasticsearch index.

This config option defines custom mappings which are accessible when the "groupByProduct" or "groupBySKU" input options is set to true (Do not set both to true at the same time).

The `customProductMappings` enable adding custom data fields that become accessible through the SearchResult GraphQL type's `customProductMappings` field. These mappings receive product and variant array data via a `valueFn` function.

In contrast, `customProductVariantMappings` are accessible when both 'groupByProduct' and 'groupBySKU' are set to `false`. These variant mappings are always available through the `customProductVariantMappings` field and also the generic `customMappings` field.

Both mapping types support GraphQL types (`String`, `Int`, `Float`, `Boolean`, `ID`, or list variants like `[String!]`) and include a `public` property (default `true`) to control GraphQL schema visibility.

**Examples:**

Example 1 (ts):
```ts
interface ElasticsearchOptions {    host?: string;    port?: number;    connectionAttempts?: number;    connectionAttemptInterval?: number;    clientOptions?: ClientOptions;    indexPrefix?: string;    indexSettings?: object;    indexMappingProperties?: {        [indexName: string]: object;    };    reindexProductsChunkSize?: number;    reindexBulkOperationSizeLimit?: number;    searchConfig?: SearchConfig;    customProductMappings?: {        [fieldName: string]: CustomMapping<            [Product, ProductVariant[], LanguageCode, Injector, RequestContext]        >;    };    customProductVarian
...
```

Example 2 (ts):
```ts
// Configuring an English stemmerindexSettings: {  analysis: {    analyzer: {      custom_analyzer: {        tokenizer: 'standard',        filter: [          'lowercase',          'english_stemmer'        ]      }    },    filter : {      english_stemmer : {        type : 'stemmer',        name : 'english'      }    }  }},
```

Example 3 (ts):
```ts
// Configuring custom analyzer for the `productName` field.indexMappingProperties: {  productName: {    type: 'text',    analyzer:'custom_analyzer',    fields: {      keyword: {        type: 'keyword',        ignore_above: 256,      }    }  }}
```

Example 4 (ts):
```ts
customProductMappings: {   variantCount: {       graphQlType: 'Int!',       valueFn: (product, variants) => variants.length,   },},indexMappingProperties: {  'product-variantCount': {    type: 'integer',  }}
```

---

## Page

**URL:** https://docs.vendure.io/reference/dashboard/page-layout/page

**Contents:**
- Page
- Page‚Äã
  - props‚Äã
- PageProps‚Äã
  - pageId‚Äã
  - entity‚Äã
  - form‚Äã
  - submitHandler‚Äã

This component should be used to wrap all pages in the dashboard. It provides a consistent layout as well as a context for the slot-based PageBlock system.

The typical hierarchy of a page is as follows:

The props used to configure the Page component.

A string identifier for the page, e.g. "product-list", "review-detail", etc.

**Examples:**

Example 1 (tsx):
```tsx
import { Page, PageTitle, PageActionBar, PageLayout, PageBlock, Button } from '@vendure/dashboard';const pageId = 'my-page';export function MyPage() { return (   <Page pageId={pageId} form={form} submitHandler={submitHandler} entity={entity}>     <PageTitle>My Page</PageTitle>     <PageActionBar>       <PageActionBarRight>         <Button>Save</Button>       </PageActionBarRight>     </PageActionBar>     <PageLayout>       <PageBlock column="main" blockId="my-block">         <div>My Block</div>       </PageBlock>     </PageLayout>   </Page> )}
```

Example 2 (ts):
```ts
function Page(props: Readonly<PageProps>): void
```

Example 3 (ts):
```ts
interface PageProps extends ComponentProps<'div'> {    pageId?: string;    entity?: any;    form?: UseFormReturn<any>;    submitHandler?: any;}
```

---

## UseRouteParams

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-route-params

**Contents:**
- UseRouteParams
- useRouteParams‚Äã

Provides access to the current route params and query params.

**Examples:**

Example 1 (ts):
```ts
import { useRouteParams } from '@vendure/admin-ui/react';import React from 'react';export function MyComponent() {    const { params, queryParams } = useRouteParams();    // ...    return <div>{ params.id }</div>;}
```

Example 2 (ts):
```ts
function useRouteParams(): void
```

---

## SlugService

**URL:** https://docs.vendure.io/reference/typescript-api/services/slug-service

**Contents:**
- SlugService
- SlugService‚Äã
  - constructor‚Äã
  - generate‚Äã

A service that handles slug generation using the configured SlugStrategy.

Generates a slug from the input string using the configured SlugStrategy.

**Examples:**

Example 1 (ts):
```ts
class SlugService {    constructor(configService: ConfigService)    generate(ctx: RequestContext, params: SlugGenerateParams) => Promise<string>;}
```

---

## Injector

**URL:** https://docs.vendure.io/reference/typescript-api/common/injector/

**Contents:**
- Injector
- Injector‚Äã
  - constructor‚Äã
  - get‚Äã
  - resolve‚Äã

The Injector wraps the underlying Nestjs ModuleRef, allowing injection of providers known to the application's dependency injection container. This is intended to enable the injection of services into objects which exist outside of the Nestjs module system, e.g. the various Strategies which can be supplied in the VendureConfig.

Retrieve an instance of the given type from the app's dependency injection container. Wraps the Nestjs ModuleRef.get() method.

Retrieve an instance of the given scoped provider (transient or request-scoped) from the app's dependency injection container. Wraps the Nestjs ModuleRef.resolve() method.

**Examples:**

Example 1 (ts):
```ts
class Injector {    constructor(moduleRef: ModuleRef)    get(typeOrToken: Type<T> | string | symbol) => R;    resolve(typeOrToken: Type<T> | string | symbol, contextId?: ContextId) => Promise<R>;}
```

---

## Populate

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/populate/

**Contents:**
- Populate
- populate‚Äã
  - bootstrapFn‚Äã
  - initialDataPathOrObject‚Äã
  - productsCsvPath‚Äã
  - channelOrToken‚Äã

Populates the Vendure server with some initial data and (optionally) product data from a supplied CSV file. The format of the CSV file is described in the section Importing Product Data.

If the channelOrToken argument is provided, all ChannelAware entities (Products, ProductVariants, Assets, ShippingMethods, PaymentMethods etc.) will be assigned to the specified Channel. The argument can be either a Channel object or a valid channel token.

Internally the populate() function does the following:

**Examples:**

Example 1 (ts):
```ts
import { bootstrap } from '@vendure/core';import { populate } from '@vendure/core/cli';import { config } from './vendure-config.ts'import { initialData } from './my-initial-data.ts';const productsCsvFile = path.join(__dirname, 'path/to/products.csv')populate(  () => bootstrap(config),  initialData,  productsCsvFile,).then(app => app.close()).then(  () => process.exit(0),  err => {    console.log(err);    process.exit(1);  },);
```

Example 2 (ts):
```ts
function populate<T extends INestApplicationContext>(bootstrapFn: () => Promise<T | undefined>, initialDataPathOrObject: string | object, productsCsvPath?: string, channelOrToken?: string | import('@vendure/core').Channel): Promise<T>
```

---

## Link

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/link

**Contents:**
- Link
- Link‚Äã
  - props‚Äã

A React component which renders an anchor tag and navigates to the specified route when clicked. This is useful when you want to use a React component in a Vendure UI plugin which navigates to a route in the admin-ui.

**Examples:**

Example 1 (ts):
```ts
import { Link } from '@vendure/admin-ui/react';export const MyReactComponent = () => {    return <Link href="/extensions/my-extension">Go to my extension</Link>;}
```

Example 2 (ts):
```ts
function Link(props: PropsWithChildren<{ href: string; [props: string]: any }>): void
```

---

## CreateTestEnvironment

**URL:** https://docs.vendure.io/reference/typescript-api/testing/create-test-environment

**Contents:**
- CreateTestEnvironment
- createTestEnvironment‚Äã
  - config‚Äã

Configures a TestServer and a SimpleGraphQLClient for each of the GraphQL APIs for use in end-to-end tests. Returns a TestEnvironment object.

**Examples:**

Example 1 (ts):
```ts
import { createTestEnvironment, testConfig } from '@vendure/testing';describe('some feature to test', () => {  const { server, adminClient, shopClient } = createTestEnvironment(testConfig);  beforeAll(async () => {    await server.init({        // ... server options    });    await adminClient.asSuperAdmin();  });  afterAll(async () => {      await server.destroy();  });  // ... end-to-end tests here});
```

Example 2 (ts):
```ts
function createTestEnvironment(config: Required<VendureConfig>): TestEnvironment
```

---

## SentryService

**URL:** https://docs.vendure.io/reference/core-plugins/sentry-plugin/sentry-service

**Contents:**
- SentryService
- SentryService‚Äã
  - constructor‚Äã
  - captureException‚Äã
  - captureMessage‚Äã
  - startSpan‚Äã

Service for capturing errors and messages to Sentry.

**Examples:**

Example 1 (ts):
```ts
class SentryService {    constructor(options: SentryPluginOptions)    captureException(exception: Error) => ;    captureMessage(message: string, captureContext?: CaptureContext) => ;    startSpan(context: StartSpanOptions) => ;}
```

---

## Error Types

**URL:** https://docs.vendure.io/reference/typescript-api/errors/error-types

**Contents:**
- Error Types
- InternalServerError‚Äã
  - constructor‚Äã
- UserInputError‚Äã
  - constructor‚Äã
- IllegalOperationError‚Äã
  - constructor‚Äã
- UnauthorizedError‚Äã
  - constructor‚Äã
- ForbiddenError‚Äã

This error should be thrown when some unexpected and exceptional case is encountered.

This error should be thrown when user input is not as expected.

This error should be thrown when an operation is attempted which is not allowed.

This error should be thrown when the user's authentication credentials do not match.

This error should be thrown when a user attempts to access a resource which is outside of his or her privileges.

This error should be thrown when a Channel cannot be found based on the provided channel token.

This error should be thrown when an entity cannot be found in the database, i.e. no entity of the given entityName (Product, User etc.) exists with the provided id.

**Examples:**

Example 1 (ts):
```ts
class InternalServerError extends I18nError {    constructor(message: string, variables: { [key: string]: string | number } = {})}
```

Example 2 (ts):
```ts
class UserInputError extends I18nError {    constructor(message: string, variables: { [key: string]: string | number } = {})}
```

Example 3 (ts):
```ts
class IllegalOperationError extends I18nError {    constructor(message: string, variables: { [key: string]: string | number } = {})}
```

Example 4 (ts):
```ts
class UnauthorizedError extends I18nError {    constructor()}
```

---

## Connect to the API

**URL:** https://docs.vendure.io/guides/storefront/connect-api/

**Contents:**
- Connect to the API
- Select a GraphQL client‚Äã
- Managing Sessions‚Äã
  - Cookie-based sessions‚Äã
  - Bearer-token sessions‚Äã
  - Session duration‚Äã
- Specifying a channel‚Äã
- Setting language‚Äã
- Code generation‚Äã
- Examples‚Äã

The first thing you'll need to do is to connect your storefront app to the Shop API. The Shop API is a GraphQL API that provides access to the products, collections, customer data, and exposes mutations that allow you to add items to the cart, checkout, manage customer accounts, and more.

You can explore the Shop API by opening the GraphQL Playground in your browser at http://localhost:3000/shop-api when your Vendure server is running locally.

GraphQL requests are made over HTTP, so you can use any HTTP client such as the Fetch API to make requests to the Shop API. However, there are also a number of specialized GraphQL clients which can make working with GraphQL APIs easier. Here are some popular options:

Vendure supports two ways to manage user sessions: cookies and bearer token. The method you choose depends on your requirements, and is specified by the authOptions.tokenMethod property of the VendureConfig. By default, both are enabled on the server:

Using cookies is the simpler approach for browser-based applications, since the browser will manage the cookies for you automatically.

Enable the credentials option in your HTTP client. This allows the browser to send the session cookie with each request.

For example, if using a fetch-based client (such as Apollo client) you would set credentials: 'include' or if using XMLHttpRequest, you would set withCredentials: true

When using cookie-based sessions, you should set the authOptions.cookieOptions.secret property to some secret string which will be used to sign the cookies sent to clients to prevent tampering. This string could be hard-coded in your config file, or (better) reside in an environment variable:

When using cookies to manage sessions, you need to be aware of the SameSite cookie policy. This policy is designed to prevent cross-site request forgery (CSRF) attacks, but can cause problems when using a headless storefront app which is hosted on a different domain to the Vendure server. See this article for more information.

Using bearer tokens involves a bit more work on your part: you'll need to manually read response headers to get the token, and once you have it you'll have to manually add it to the headers of each request.

The workflow would be as follows:

Here's a simplified example of how that would look:

There are some concrete examples of this approach in the examples later on in this guide.

The duration of a session is determined by the `AuthOptions.sessionDuration` config property.

**sessionDuration Property:**

**Type:** `string | number`
**Default:** `'1y'` (one year)

This property defines the time which must elapse from the last authenticated request after which the user must re-authenticate.

The setting accepts two formats:
- **Numeric values** represent milliseconds
- **String values** follow the [zeit/ms](https://github.com/zeit/ms.js) format

**Supported examples:**
- `60` (milliseconds)
- `'2 days'`
- `'10h'` (hours)
- `'7d'` (days)

Session duration works alongside complementary authentication options like `sessionCacheStrategy` (manages session caching), `sessionCacheTTL` (cache freshness timing, default: 300 seconds), and `tokenMethod` (token delivery via cookie or bearer token).

**Examples:**

Example 1 (ts):
```ts
import { VendureConfig } from '@vendure/core';export const config: VendureConfig = {    // ...    authOptions: {        tokenMethod: ['bearer', 'cookie'],    },};
```

Example 2 (ts):
```ts
import { VendureConfig } from '@vendure/core';export const config: VendureConfig = {    // ...    authOptions: {        tokenMethod: ['bearer', 'cookie'],        cookieOptions: {            secret: process.env.COOKIE_SESSION_SECRET        }    }}
```

Example 3 (ts):
```ts
let token: string | undefined = localStorage.getItem('token')export async function request(query: string, variables: any) {     // If we already know the token, set the Authorization header.     const headers = token ? { Authorization: `Bearer ${token}` } : {};     const response = await someGraphQlClient(query, variables, headers);     // Check the response headers to see if Vendure has set the     // auth token. The header key "vendure-auth-token" may be set to     // a custom value with the authOptions.authTokenHeaderKey config option.     const authToken = response.headers.get('vendure-aut
...
```

Example 4 (ts):
```ts
export function query(document: string, variables: Record<string, any> = {}) {    return fetch('https://localhost:3000/shop-api', {        method: 'POST',        headers: {            'content-type': 'application/json',            'vendure-token': 'uk-channel',        },        credentials: 'include',        body: JSON.stringify({          query: document,          variables,        }),    })      .then((res) => res.json())      .catch((err) => console.log(err));}
```

---

## Promotion

**URL:** https://docs.vendure.io/reference/typescript-api/entities/promotion/

**Contents:**
- Promotion
- Promotion‚Äã
  - type‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - startsAt‚Äã
  - endsAt‚Äã
  - couponCode‚Äã
  - perCustomerUsageLimit‚Äã
  - usageLimit‚Äã

A Promotion is used to define a set of conditions under which promotions actions (typically discounts) will be applied to an Order.

Each assigned PromotionCondition is checked against the Order, and if they all return true, then each assign PromotionItemAction / PromotionLineAction / PromotionOrderAction / PromotionShippingAction is applied to the Order.

Extends: AdjustmentSource

Implements: ChannelAware, SoftDeletable, HasCustomFields, Translatable

The PriorityScore is used to determine the sequence in which multiple promotions are tested on a given order. A higher number moves the Promotion towards the end of the sequence.

The score is derived from the sum of the priorityValues of the PromotionConditions and PromotionActions comprising this Promotion.

An example illustrating the need for a priority is this:

Consider 2 Promotions, 1) buy 1 get one free and 2) 10% off when order total is over $50. If Promotion 2 is evaluated prior to Promotion 1, then it can trigger the 10% discount even if the subsequent application of Promotion 1 brings the order total down to way below $50.

**Examples:**

Example 1 (ts):
```ts
class Promotion extends AdjustmentSource implements ChannelAware, SoftDeletable, HasCustomFields, Translatable {    type = AdjustmentType.PROMOTION;    constructor(input?: DeepPartial<Promotion> & {            promotionConditions?: Array<PromotionCondition<any>>;            promotionActions?: Array<PromotionAction<any>>;        })    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column({ type: Date, nullable: true })    startsAt: Date | null;    @Column({ type: Date, nullable: true })    endsAt: Date | null;    @Column({ nullable: true })    couponCode: string;    @Col
...
```

---

## ShippingMethod

**URL:** https://docs.vendure.io/reference/typescript-api/entities/shipping-method/

**Contents:**
- ShippingMethod
- ShippingMethod‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - code‚Äã
  - name‚Äã
  - description‚Äã
  - checker‚Äã
  - calculator‚Äã
  - fulfillmentHandlerCode‚Äã

A ShippingMethod is used to apply a shipping price to an Order. It is composed of a ShippingEligibilityChecker and a ShippingCalculator. For a given Order, the checker is used to determine whether this ShippingMethod can be used. If yes, then the ShippingMethod can be applied and the calculator is used to determine the price of shipping.

Extends: VendureEntity

Implements: ChannelAware, SoftDeletable, HasCustomFields, Translatable

**Examples:**

Example 1 (ts):
```ts
class ShippingMethod extends VendureEntity implements ChannelAware, SoftDeletable, HasCustomFields, Translatable {    constructor(input?: DeepPartial<ShippingMethod>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column() code: string;    name: LocaleString;    description: LocaleString;    @Column('simple-json') checker: ConfigurableOperation;    @Column('simple-json') calculator: ConfigurableOperation;    @Column()    fulfillmentHandlerCode: string;    @ManyToMany(type => Channel, channel => channel.shippingMethods)    @JoinTable()    channels: Channel[];    @OneT
...
```

---

## DefaultTaxLineCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/tax/default-tax-line-calculation-strategy

**Contents:**
- DefaultTaxLineCalculationStrategy
- DefaultTaxLineCalculationStrategy‚Äã
  - calculate‚Äã

The default TaxLineCalculationStrategy which applies a single TaxLine to the OrderLine based on the applicable TaxRate.

**Examples:**

Example 1 (ts):
```ts
class DefaultTaxLineCalculationStrategy implements TaxLineCalculationStrategy {    calculate(args: CalculateTaxLinesArgs) => TaxLine[];}
```

---

## DatetimePickerComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/datetime-picker-component

**Contents:**
- DatetimePickerComponent
- DatetimePickerComponent‚Äã
  - yearRange‚Äã
  - weekStartDay‚Äã
  - timeGranularityInterval‚Äã
  - min‚Äã
  - max‚Äã
  - readonly‚Äã
  - dropdownComponent‚Äã
  - datetimeInput‚Äã

A form input for selecting datetime values.

The range above and below the current year which is selectable from the year select control. If a min or max value is set, these will override the yearRange.

The day that the week should start with in the calendar view.

The granularity of the minutes time picker

The minimum date as an ISO string

The maximum date as an ISO string

Sets the readonly state

**Examples:**

Example 1 (html):
```html
<vdr-datetime-picker [(ngModel)]="startDate"></vdr-datetime-picker>
```

Example 2 (ts):
```ts
class DatetimePickerComponent implements ControlValueAccessor, AfterViewInit, OnInit, OnDestroy {    @Input() yearRange;    @Input() weekStartDay: DayOfWeek = 'mon';    @Input() timeGranularityInterval = 5;    @Input() min: string | null = null;    @Input() max: string | null = null;    @Input() readonly = false;    @ViewChild('dropdownComponent', { static: true }) dropdownComponent: DropdownComponent;    @ViewChild('datetimeInput', { static: true }) datetimeInput: ElementRef<HTMLInputElement>;    @ViewChild('calendarTable') calendarTable: ElementRef<HTMLTableElement>;    disabled = false;    
...
```

---

## SqlCacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/cache/sql-cache-strategy

**Contents:**
- SqlCacheStrategy
- SqlCacheStrategy‚Äã
  - cacheSize‚Äã
  - ttlProvider‚Äã
  - constructor‚Äã
  - connection‚Äã
  - configService‚Äã
  - init‚Äã
  - get‚Äã
  - set‚Äã

A CacheStrategy that stores cached items in the database. This is the strategy used by the DefaultCachePlugin.

**Examples:**

Example 1 (ts):
```ts
class SqlCacheStrategy implements CacheStrategy {    protected cacheSize = 10_000;    protected ttlProvider: CacheTtlProvider;    constructor(config?: { cacheSize?: number; cacheTtlProvider?: CacheTtlProvider })    protected connection: TransactionalConnection;    protected configService: ConfigService;    init(injector: Injector) => ;    get(key: string) => Promise<T | undefined>;    set(key: string, value: T, options?: SetCacheKeyOptions) => ;    delete(key: string) => ;    invalidateTags(tags: string[]) => ;}
```

---

## Mutations

**URL:** https://docs.vendure.io/reference/graphql-api/admin/mutations/

**Contents:**
- Mutations
- addCustomersToGroup‚Äã
- addFulfillmentToOrder‚Äã
- addItemToDraftOrder‚Äã
- addManualPaymentToOrder‚Äã
- addMembersToZone‚Äã
- addNoteToCustomer‚Äã
- addNoteToOrder‚Äã
- addOptionGroupToProduct‚Äã
- adjustDraftOrderLine‚Äã

---

## PageDetailLayout

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/page-detail-layout

**Contents:**
- PageDetailLayout
- PageDetailLayout‚Äã
  - props‚Äã

A responsive container for detail views with a main content area and an optional sidebar.

**Examples:**

Example 1 (ts):
```ts
import { PageDetailLayout } from '@vendure/admin-ui/react';export function MyComponent() {  return (    <PageDetailLayout sidebar={<div>Sidebar content</div>}>      <div>Main content</div>    </PageDetailLayout>  );}
```

Example 2 (ts):
```ts
function PageDetailLayout(props: PropsWithChildren<{ sidebar?: ReactNode }>): void
```

---

## TemplateLoader

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/template-loader

**Contents:**
- TemplateLoader
- TemplateLoader‚Äã
  - loadTemplate‚Äã
  - loadPartials‚Äã
- FileBasedTemplateLoader‚Äã
  - constructor‚Äã
  - loadTemplate‚Äã
  - loadPartials‚Äã

Loads email templates based on the given request context, type and template name and return the template as a string.

Load template and return it's content as a string

Load partials and return their contents. This method is only called during initialization, i.e. during server startup.

Loads email templates from the local file system. This is the default loader used by the EmailPlugin.

**Examples:**

Example 1 (ts):
```ts
import { EmailPlugin, TemplateLoader } from '@vendure/email-plugin';class MyTemplateLoader implements TemplateLoader {     loadTemplate(injector, ctx, { type, templateName }){         return myCustomTemplateFunction(ctx);     }}// In vendure-config.ts:...EmailPlugin.init({    templateLoader: new MyTemplateLoader()    ...})
```

Example 2 (ts):
```ts
interface TemplateLoader {    loadTemplate(injector: Injector, ctx: RequestContext, input: LoadTemplateInput): Promise<string>;    loadPartials?(): Promise<Partial[]>;}
```

Example 3 (ts):
```ts
class FileBasedTemplateLoader implements TemplateLoader {    constructor(templatePath: string)    loadTemplate(_injector: Injector, _ctx: RequestContext, { type, templateName }: LoadTemplateInput) => Promise<string>;    loadPartials() => Promise<Partial[]>;}
```

---

## UseGeneratedForm

**URL:** https://docs.vendure.io/reference/dashboard/detail-views/use-generated-form

**Contents:**
- UseGeneratedForm
- useGeneratedForm‚Äã
  - options‚Äã
- GeneratedFormOptions‚Äã
  - document‚Äã
  - varName‚Äã
  - entity‚Äã
  - customFieldConfig‚Äã
  - setValues‚Äã
  - onSubmit‚Äã

This hook is used to create a form from a document and an entity. It will create a form with the fields defined in the document's input type. It will also create a submit handler that will submit the form to the server.

This hook is mostly used internally by the higher-level useDetailPage hook, but can in some cases be useful to use directly.

Options for the useGeneratedForm hook.

The document to use to generate the form.

The name of the variable to use in the document.

The entity to use to generate the form.

**Examples:**

Example 1 (tsx):
```tsx
const { form, submitHandler } = useGeneratedForm({ document: setDraftOrderCustomFieldsDocument, varName: undefined, entity: entity, setValues: entity => {   return {     orderId: entity.id,     input: {       customFields: entity.customFields,     },   }; },});
```

Example 2 (ts):
```ts
function useGeneratedForm<T extends TypedDocumentNode<any, any>, VarName extends keyof VariablesOf<T> | undefined, E extends Record<string, any> = Record<string, any>>(options: GeneratedFormOptions<T, VarName, E>): void
```

Example 3 (ts):
```ts
interface GeneratedFormOptions<T extends TypedDocumentNode<any, any>, VarName extends keyof VariablesOf<T> | undefined = 'input', E extends Record<string, any> = Record<string, any>> {    document?: T;    varName?: VarName;    entity: E | null | undefined;    customFieldConfig?: any[];    setValues: (        entity: NonNullable<E>,    ) => VarName extends keyof VariablesOf<T> ? VariablesOf<T>[VarName] : VariablesOf<T>;    onSubmit?: (        values: VarName extends keyof VariablesOf<T> ? VariablesOf<T>[VarName] : VariablesOf<T>,    ) => void;}
```

---

## UseChannel

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-channel

**Contents:**
- UseChannel
- useChannel‚Äã
- ChannelContext‚Äã
  - isLoading‚Äã
  - channels‚Äã
  - activeChannel‚Äã
  - setActiveChannel‚Äã
  - refreshChannels‚Äã

Provides access to the ChannelContext which contains information about the active channel.

Provides information about the active channel, and the means to set a new active channel.

Whether the channels are loading.

An array of all available channels.

The function to set the active channel.

The function to refresh the channels.

**Examples:**

Example 1 (tsx):
```tsx
const { activeChannel } = useChannel();
```

Example 2 (ts):
```ts
function useChannel(): void
```

Example 3 (ts):
```ts
interface ChannelContext {    isLoading: boolean;    channels: Channel[];    activeChannel: ActiveChannel | undefined;    setActiveChannel: (channelId: string) => void;    refreshChannels: () => void;}
```

---

## Bootstrap

**URL:** https://docs.vendure.io/reference/typescript-api/common/bootstrap/

**Contents:**
- Bootstrap
- bootstrap‚Äã
  - Passing additional options‚Äã
  - Ignoring compatibility errors for plugins‚Äã
  - userConfig‚Äã
  - options‚Äã
- BootstrapOptions‚Äã
  - nestApplicationOptions‚Äã
  - ignoreCompatibilityErrorsForPlugins‚Äã

Bootstraps the Vendure server. This is the entry point to the application.

Since v2.2.0, you can pass additional options to the NestJs application via the options parameter. For example, to integrate with the Nest Devtools, you need to pass the snapshot option:

Since v3.1.0, you can ignore compatibility errors for specific plugins by passing the ignoreCompatibilityErrorsForPlugins option.

This should be used with caution, only if you are sure that the plugin will still work as expected with the current version of Vendure.

Additional options that can be used to configure the bootstrap process of the Vendure server.

These options get passed directly to the NestFactory.create() method.

By default, if a plugin specifies a compatibility range which does not include the current Vendure version, the bootstrap process will fail. This option allows you to ignore compatibility errors for specific plugins.

This setting should be used with caution, only if you are sure that the plugin will still work as expected with the current version of Vendure.

**Examples:**

Example 1 (ts):
```ts
import { bootstrap } from '@vendure/core';import { config } from './vendure-config';bootstrap(config).catch(err => {  console.log(err);  process.exit(1);});
```

Example 2 (ts):
```ts
import { bootstrap } from '@vendure/core';import { config } from './vendure-config';bootstrap(config, {  nestApplicationOptions: {    snapshot: true,  }}).catch(err => {  console.log(err);  process.exit(1);});
```

Example 3 (ts):
```ts
import { bootstrap } from '@vendure/core';import { config } from './vendure-config';import { MyPlugin } from './plugins/my-plugin';bootstrap(config, {  // Let's say that `MyPlugin` is not yet compatible with the current version of Vendure  // but we know that it will still work as expected, and we are not able to publish  // a new version of the plugin right now.  ignoreCompatibilityErrorsForPlugins: [MyPlugin],});
```

Example 4 (ts):
```ts
function bootstrap(userConfig: Partial<VendureConfig>, options?: BootstrapOptions): Promise<INestApplication>
```

---

## LanguageCode

**URL:** https://docs.vendure.io/reference/typescript-api/common/language-code

**Contents:**
- LanguageCode
- LanguageCode‚Äã

Languages in the form of a ISO 639-1 language code with optional region or script modifier (e.g. de_AT). The selection available is based on the Unicode CLDR summary list and includes the major spoken languages of the world and any widely-used variants.

**Examples:**

Example 1 (ts):
```ts
enum LanguageCode {    af = 'af'    ak = 'ak'    am = 'am'    ar = 'ar'    as = 'as'    az = 'az'    be = 'be'    bg = 'bg'    bm = 'bm'    bn = 'bn'    bo = 'bo'    br = 'br'    bs = 'bs'    ca = 'ca'    ce = 'ce'    co = 'co'    cs = 'cs'    cu = 'cu'    cy = 'cy'    da = 'da'    de = 'de'    de_AT = 'de_AT'    de_CH = 'de_CH'    dz = 'dz'    ee = 'ee'    el = 'el'    en = 'en'    en_AU = 'en_AU'    en_CA = 'en_CA'    en_GB = 'en_GB'    en_US = 'en_US'    eo = 'eo'    es = 'es'    es_ES = 'es_ES'    es_MX = 'es_MX'    et = 'et'    eu = 'eu'    fa = 'fa'    fa_AF = 'fa_AF'    ff = 'ff'    fi 
...
```

---

## ProductOptionGroup

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product-option-group

**Contents:**
- ProductOptionGroup
- ProductOptionGroup‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - code‚Äã
  - translations‚Äã
  - options‚Äã
  - product‚Äã
  - customFields‚Äã

A grouping of one or more ProductOptions.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class ProductOptionGroup extends VendureEntity implements Translatable, HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<ProductOptionGroup>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    @Column()    code: string;    @OneToMany(type => ProductOptionGroupTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<ProductOptionGroup>>;    @OneToMany(type => ProductOption, option => option.group)    options: ProductOption[];    @Index()    @ManyToOne(type => Product, product => product.opti
...
```

---

## RegisterHistoryEntryComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-history-entry-components/register-history-entry-component/

**Contents:**
- RegisterHistoryEntryComponent
- registerHistoryEntryComponent‚Äã
  - config‚Äã

Registers a HistoryEntryComponent for displaying history entries in the Order/Customer history timeline.

**Examples:**

Example 1 (ts):
```ts
import { Component } from '@angular/core';import {    CustomerFragment,    CustomerHistoryEntryComponent,    registerHistoryEntryComponent,    SharedModule,    TimelineDisplayType,    TimelineHistoryEntry,} from '@vendure/admin-ui/core';@Component({    selector: 'tax-id-verification-component',    template: `        <div *ngIf="entry.data.valid">          Tax ID <strong>{{ entry.data.taxId }}</strong> was verified          <vdr-history-entry-detail *ngIf="entry.data">            <vdr-object-tree [value]="entry.data"></vdr-object-tree>          </vdr-history-entry-detail>        </div>        <
...
```

Example 2 (ts):
```ts
function registerHistoryEntryComponent(config: HistoryEntryConfig): void
```

---

## DefaultVerificationTokenStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/default-verification-token-strategy

**Contents:**
- DefaultVerificationTokenStrategy
- DefaultVerificationTokenStrategy‚Äã
  - init‚Äã
  - generateVerificationToken‚Äã
  - verifyVerificationToken‚Äã

The default VerificationTokenStrategy which generates a token consisting of the base64-encoded current time concatenated with a random id. The token is considered valid if the current time is within the configured verificationTokenDuration of the time encoded in the token.

**Examples:**

Example 1 (ts):
```ts
class DefaultVerificationTokenStrategy implements VerificationTokenStrategy {    init(injector: Injector) => ;    generateVerificationToken(_ctx: RequestContext) => string;    verifyVerificationToken(_ctx: RequestContext, token: string) => boolean;}
```

---

## Types

**URL:** https://docs.vendure.io/reference/graphql-api/shop/object-types

**Contents:**
- Types
- ActiveOrderResult‚Äã
- AddPaymentToOrderResult‚Äã
- Address‚Äã
- Adjustment‚Äã
- AlreadyLoggedInError‚Äã
- ApplyCouponCodeResult‚Äã
- Asset‚Äã
- AssetList‚Äã
- AuthenticationMethod‚Äã

---

## HistoryService

**URL:** https://docs.vendure.io/reference/typescript-api/services/history-service

**Contents:**
- HistoryService
- HistoryService‚Äã
- Custom History Entry Types‚Äã
  - constructor‚Äã
  - getHistoryForOrder‚Äã
  - createHistoryEntryForOrder‚Äã
  - getHistoryForCustomer‚Äã
  - createHistoryEntryForCustomer‚Äã
  - updateOrderHistoryEntry‚Äã
  - deleteOrderHistoryEntry‚Äã

Contains methods relating to HistoryEntry entities. Histories are timelines of actions related to a particular Customer or Order, recording significant events such as creation, state changes, notes, etc.

Since Vendure v1.9.0, it is possible to define custom HistoryEntry types.

Let's take an example where we have some Customers who are businesses. We want to verify their tax ID in order to allow them wholesale rates. As part of this verification, we'd like to add an entry into the Customer's history with data about the tax ID verification.

First of all we'd extend the GraphQL HistoryEntryType enum for our new type as part of a plugin

Next we need to create a TypeScript type definition file where we extend the CustomerHistoryEntryData interface. This is done via TypeScript's declaration merging and ambient modules features.

Note: it works exactly the same way if we wanted to add a custom type for Order history, except in that case we'd extend the OrderHistoryEntryData interface instead.

Now that we have our types set up, we can use the HistoryService to add a new HistoryEntry in a type-safe manner:

It is also possible to define a UI component to display custom history entry types. See the Custom History Timeline Components guide.

**Examples:**

Example 1 (ts):
```ts
import { PluginCommonModule, VendurePlugin } from '@vendure/core';import { VerificationService } from './verification.service';@VendurePlugin({  imports: [PluginCommonModule],  adminApiExtensions: {    schema: gql`      extend enum HistoryEntryType {        CUSTOMER_TAX_ID_VERIFICATION      }    `,  },  providers: [VerificationService],})export class TaxIDVerificationPlugin {}
```

Example 2 (ts):
```ts
// types.tsimport { CustomerHistoryEntryData } from '@vendure/core';export const CUSTOMER_TAX_ID_VERIFICATION = 'CUSTOMER_TAX_ID_VERIFICATION';declare module '@vendure/core' {  interface CustomerHistoryEntryData {    [CUSTOMER_TAX_ID_VERIFICATION]: {      taxId: string;      valid: boolean;      name?: string;      address?: string;    };  }}
```

Example 3 (ts):
```ts
// verification.service.tsimport { Injectable } from '@nestjs/common';import { RequestContext } from '@vendure/core';import { CUSTOMER_TAX_ID_VERIFICATION } from './types';@Injectable()export class VerificationService {  constructor(private historyService: HistoryService) {}  async verifyTaxId(ctx: RequestContext, customerId: ID, taxId: string) {    const result = await someTaxIdCheckingService(taxId);    await this.historyService.createHistoryEntryForCustomer({      customerId,      ctx,      type: CUSTOMER_TAX_ID_VERIFICATION,      data: {        taxId,        valid: result.isValid,        n
...
```

Example 4 (ts):
```ts
class HistoryService {    constructor(connection: TransactionalConnection, administratorService: AdministratorService, listQueryBuilder: ListQueryBuilder, eventBus: EventBus)    getHistoryForOrder(ctx: RequestContext, orderId: ID, publicOnly: boolean, options?: HistoryEntryListOptions) => Promise<PaginatedList<OrderHistoryEntry>>;    createHistoryEntryForOrder(args: CreateOrderHistoryEntryArgs<T>, isPublic:  = true) => Promise<OrderHistoryEntry>;    getHistoryForCustomer(ctx: RequestContext, customerId: ID, publicOnly: boolean, options?: HistoryEntryListOptions) => Promise<PaginatedList<Custom
...
```

---

## NotificationService

**URL:** https://docs.vendure.io/reference/admin-ui-api/services/notification-service

**Contents:**
- NotificationService
- NotificationService‚Äã
  - constructor‚Äã
  - success‚Äã
  - info‚Äã
  - warning‚Äã
  - error‚Äã
  - notify‚Äã
- NotificationType‚Äã
- ToastConfig‚Äã

Provides toast notification functionality.

Display a success toast notification

Display an info toast notification

Display a warning toast notification

Display an error toast notification

Display a toast notification.

The types of notification available.

Configuration for a toast notification.

**Examples:**

Example 1 (ts):
```ts
class MyComponent {  constructor(private notificationService: NotificationService) {}  save() {    this.notificationService        .success(_('asset.notify-create-assets-success'), {          count: successCount,        });  }}```ts title="Signature"class NotificationService {    constructor(i18nService: I18nService, resolver: ComponentFactoryResolver, overlayHostService: OverlayHostService)    success(message: string, translationVars?: { [key: string]: string | number }) => void;    info(message: string, translationVars?: { [key: string]: string | number }) => void;    warning(message: string
...
```

Example 2 (ts):
```ts
type NotificationType = 'info' | 'success' | 'error' | 'warning'
```

Example 3 (ts):
```ts
interface ToastConfig {    message: string;    translationVars?: { [key: string]: string | number };    type?: NotificationType;    duration?: number;}
```

---

## Events

**URL:** https://docs.vendure.io/reference/typescript-api/events/

**Contents:**
- Events
- üìÑÔ∏è BlockingEventHandlerOptions
- üìÑÔ∏è EventBus
- üìÑÔ∏è Event Types
- üìÑÔ∏è VendureEntityEvent
- üìÑÔ∏è VendureEvent

BlockingEventHandlerOptions

AccountRegistrationEvent

---

## OrderMergeStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-merge-strategy

**Contents:**
- OrderMergeStrategy
- OrderMergeStrategy‚Äã
  - merge‚Äã
- MergedOrderLine‚Äã
  - orderLineId‚Äã
  - quantity‚Äã
  - customFields‚Äã

An OrderMergeStrategy defines what happens when a Customer with an existing Order signs in with a guest Order, where both Orders may contain differing OrderLines.

Somehow these differing OrderLines need to be reconciled into a single collection of OrderLines. The OrderMergeStrategy defines the rules governing this reconciliation.

This is configured via the orderOptions.mergeStrategy property of your VendureConfig.

Merges the lines of the guest Order with those of the existing Order which is associated with the active customer.

The result of the OrderMergeStrategy merge method.

**Examples:**

Example 1 (ts):
```ts
interface OrderMergeStrategy extends InjectableStrategy {    merge(ctx: RequestContext, guestOrder: Order, existingOrder: Order): MergedOrderLine[];}
```

Example 2 (ts):
```ts
interface MergedOrderLine {    orderLineId: ID;    quantity: number;    customFields?: any;}
```

---

## PageLayout

**URL:** https://docs.vendure.io/reference/dashboard/page-layout/

**Contents:**
- PageLayout
- PageLayout‚Äã
  - props‚Äã
- PageLayoutProps‚Äã
  - children‚Äã
  - className‚Äã

This component governs the layout of the contents of a Page component. It should contain all the PageBlock components that are to be displayed on the page.

Status: Developer Preview

**Examples:**

Example 1 (ts):
```ts
function PageLayout(props: Readonly<PageLayoutProps>): void
```

Example 2 (ts):
```ts
type PageLayoutProps = {    children: React.ReactNode;    className?: string;}
```

---

## RegisterReactCustomDetailComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/register-react-custom-detail-component

**Contents:**
- RegisterReactCustomDetailComponent
- registerReactCustomDetailComponent‚Äã
  - config‚Äã

Registers a React component to be rendered in a detail page in the given location. Components used as custom detail components can make use of the useDetailComponentData hook.

**Examples:**

Example 1 (ts):
```ts
function registerReactCustomDetailComponent(config: ReactCustomDetailComponentConfig): void
```

---

## OtelLogger

**URL:** https://docs.vendure.io/reference/core-plugins/telemetry-plugin/otel-logger

**Contents:**
- OtelLogger
- OtelLogger‚Äã
  - constructor‚Äã
  - debug‚Äã
  - warn‚Äã
  - info‚Äã
  - error‚Äã
  - verbose‚Äã
- OtelLoggerOptions‚Äã
  - logToConsole‚Äã

A logger that emits logs to OpenTelemetry and optionally to the console.

Options for the OtelLogger.

If set to a LogLevel, the logger will also log to the console. This can be useful for local development or debugging.

**Examples:**

Example 1 (ts):
```ts
class OtelLogger implements VendureLogger {    constructor(options: OtelLoggerOptions)    debug(message: string, context?: string) => void;    warn(message: string, context?: string) => void;    info(message: string, context?: string) => void;    error(message: string, context?: string) => void;    verbose(message: string, context?: string) => void;}
```

Example 2 (ts):
```ts
interface OtelLoggerOptions {    logToConsole?: LogLevel;}
```

Example 3 (ts):
```ts
import { LogLevel } from '@vendure/core';import { TelemetryPlugin } from '@vendure/telemetry-plugin';// ...TelemetryPlugin.init({  loggerOptions: {    logToConsole: LogLevel.Verbose,  },});
```

---

## SettingsStore

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/

**Contents:**
- SettingsStore
- cleanOrphanedSettingsStoreTask‚Äã

A ScheduledTask that cleans up orphaned settings store entries from the database. Orphaned entries are entries that no longer have corresponding field definitions in the settings store configuration.

This task can be configured with options for dry-run mode, age thresholds, and batch processing settings. Users can override or disable this task entirely using the existing ScheduledTask APIs.

**Examples:**

Example 1 (ts):
```ts
// Override the default task with custom optionsconst customCleanupTask = new ScheduledTask({  id: 'clean-orphaned-settings-store',  description: 'Custom orphaned settings store cleanup',  schedule: cron => cron.every(7).days(),  async execute({ injector }) {    const settingsStoreService = injector.get(SettingsStoreService);    return settingsStoreService.cleanupOrphanedEntries({      olderThan: '30d',      maxDeleteCount: 500,      batchSize: 50,    });  },});
```

---

## DefaultOrderPlacedStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/default-order-placed-strategy

**Contents:**
- DefaultOrderPlacedStrategy
- DefaultOrderPlacedStrategy‚Äã
  - shouldSetAsPlaced‚Äã

The default OrderPlacedStrategy. The order is set as "placed" when it transitions from 'ArrangingPayment' to either 'PaymentAuthorized' or 'PaymentSettled'.

**Examples:**

Example 1 (ts):
```ts
class DefaultOrderPlacedStrategy implements OrderPlacedStrategy {    shouldSetAsPlaced(ctx: RequestContext, fromState: OrderState, toState: OrderState, order: Order) => boolean;}
```

---

## PageBlock

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/page-block

**Contents:**
- PageBlock
- PageBlock‚Äã
  - props‚Äã

A container for page content which provides a consistent width and spacing.

**Examples:**

Example 1 (ts):
```ts
import { PageBlock } from '@vendure/admin-ui/react';export function MyComponent() {  return (    <PageBlock>      ...    </PageBlock>  );}
```

Example 2 (ts):
```ts
function PageBlock(props: PropsWithChildren): void
```

---

## PluginCommonModule

**URL:** https://docs.vendure.io/reference/typescript-api/plugin/plugin-common-module/

**Contents:**
- PluginCommonModule
- PluginCommonModule‚Äã

This module provides the common services, configuration, and event bus capabilities required by a typical plugin. It should be imported into plugins to avoid having to repeat the same boilerplate for each individual plugin.

The PluginCommonModule exports:

**Examples:**

Example 1 (ts):
```ts
class PluginCommonModule {}
```

---

## OrderCodeStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-code-strategy/

**Contents:**
- OrderCodeStrategy
- OrderCodeStrategy‚Äã
  - generate‚Äã
- DefaultOrderCodeStrategy‚Äã
  - generate‚Äã

The OrderCodeStrategy determines how Order codes are generated. A custom strategy can be defined which e.g. integrates with an existing system to generate a code:

This is configured via the orderOptions.orderCodeStrategy property of your VendureConfig.

Generates the order code.

The default OrderCodeStrategy generates a random string consisting of 16 uppercase letters and numbers.

**Examples:**

Example 1 (ts):
```ts
class MyOrderCodeStrategy implements OrderCodeStrategy {  // Some imaginary service which calls out to an existing external  // order management system.  private mgmtService: ExternalOrderManagementService;  init(injector: Injector) {    this.mgmtService = injector.get(ExternalOrderManagementService);  }  async generate(ctx: RequestContext) {    const result = await this.mgmtService.getAvailableOrderParams();    return result.code;  }}
```

Example 2 (ts):
```ts
interface OrderCodeStrategy extends InjectableStrategy {    generate(ctx: RequestContext): string | Promise<string>;}
```

Example 3 (ts):
```ts
class DefaultOrderCodeStrategy implements OrderCodeStrategy {    generate(ctx: RequestContext) => string;}
```

---

## CacheConfig

**URL:** https://docs.vendure.io/reference/typescript-api/cache/cache-config

**Contents:**
- CacheConfig
- CacheConfig‚Äã
  - getKey‚Äã
  - options‚Äã

Configuration for a new Cache instance.

A function which generates a cache key from the given id. This key will be used to store the value in the cache.

By convention, the key should be namespaced to avoid conflicts.

Options available when setting the value in the cache.

**Examples:**

Example 1 (ts):
```ts
interface CacheConfig {    getKey: (id: string | number) => string;    options?: SetCacheKeyOptions;}
```

Example 2 (ts):
```ts
getKey: id => `MyStrategy:getProductVariantIds:${id}`,
```

---

## VendureLogger

**URL:** https://docs.vendure.io/reference/typescript-api/logger/vendure-logger

**Contents:**
- VendureLogger
- VendureLogger‚Äã
  - error‚Äã
  - warn‚Äã
  - info‚Äã
  - verbose‚Äã
  - debug‚Äã
  - setDefaultContext‚Äã

The VendureLogger interface defines the shape of a logger service which may be provided in the config.

**Examples:**

Example 1 (ts):
```ts
interface VendureLogger {    error(message: string, context?: string, trace?: string): void;    warn(message: string, context?: string): void;    info(message: string, context?: string): void;    verbose(message: string, context?: string): void;    debug(message: string, context?: string): void;    setDefaultContext?(defaultContext: string): void;}
```

---

## LanguageCode

**URL:** https://docs.vendure.io/reference/typescript-api/common/language-code/

**Contents:**
- LanguageCode
- LanguageCode‚Äã

Languages in the form of a ISO 639-1 language code with optional region or script modifier (e.g. de_AT). The selection available is based on the Unicode CLDR summary list and includes the major spoken languages of the world and any widely-used variants.

**Examples:**

Example 1 (ts):
```ts
enum LanguageCode {    af = 'af'    ak = 'ak'    am = 'am'    ar = 'ar'    as = 'as'    az = 'az'    be = 'be'    bg = 'bg'    bm = 'bm'    bn = 'bn'    bo = 'bo'    br = 'br'    bs = 'bs'    ca = 'ca'    ce = 'ce'    co = 'co'    cs = 'cs'    cu = 'cu'    cy = 'cy'    da = 'da'    de = 'de'    de_AT = 'de_AT'    de_CH = 'de_CH'    dz = 'dz'    ee = 'ee'    el = 'el'    en = 'en'    en_AU = 'en_AU'    en_CA = 'en_CA'    en_GB = 'en_GB'    en_US = 'en_US'    eo = 'eo'    es = 'es'    es_ES = 'es_ES'    es_MX = 'es_MX'    et = 'et'    eu = 'eu'    fa = 'fa'    fa_AF = 'fa_AF'    ff = 'ff'    fi 
...
```

---

## Promotion Action

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/promotion-action/

**Contents:**
- Promotion Action
- PromotionAction‚Äã
  - priorityValue‚Äã
  - constructor‚Äã
- PromotionItemAction‚Äã
  - constructor‚Äã
- PromotionOrderAction‚Äã
  - constructor‚Äã
- PromotionShippingAction‚Äã
  - constructor‚Äã

An abstract class which is extended by PromotionItemAction, PromotionOrderAction, and PromotionShippingAction.

Used to determine the order of application of multiple Promotions on the same Order. See the Promotion priorityScore field for more information.

Represents a PromotionAction which applies to individual OrderLines.

Represents a PromotionAction which applies to the Order as a whole.

Represents a PromotionAction which applies to the shipping cost of an Order.

The function which is used by a PromotionItemAction to calculate the discount on the OrderLine for each item.

The function which is used by a PromotionLineAction to calculate the discount on the OrderLine.

The function which is used by a PromotionOrderAction to calculate the discount on the Order.

The function which is used by a PromotionOrderAction to calculate the discount on the Order.

The signature of a PromotionAction's side-effect functions onActivate and onDeactivate.

Configuration for all types of PromotionAction.

Used to determine the order of application of multiple Promotions on the same Order. See the Promotion priorityScore field for more information.

Allows PromotionActions to define one or more PromotionConditions as dependencies. Having a PromotionCondition as a dependency has the following consequences:

An optional side effect function which is invoked when the promotion becomes active. It can be used for things like adding a free gift to the order or other side effects that are unrelated to price calculations.

If used, make sure to use the corresponding onDeactivate function to clean up or reverse any side effects as needed.

Used to reverse or clean up any side effects executed as part of the onActivate function.

Configuration for a PromotionItemAction

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount the OrderLine, i.e. the number should be negative.

Configuration for a PromotionLineAction

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount the OrderLine, i.e. the number should be negative.

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount the Order, i.e. the number should be negative.

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount.

**Promotion Action Types:**

- **PromotionItemAction**: Applies discounts to individual OrderLines on a per-item basis
- **PromotionLineAction**: Similar to PromotionItemAction but applies regardless of OrderLine quantity
- **PromotionOrderAction**: Applies discounts to the entire Order total
- **PromotionShippingAction**: Applies discounts specifically to shipping costs

**Execution Functions:**

Each action type requires an `execute` function:

- **PromotionItemActionConfig**: Receives OrderLine, returns negative number for per-item discount
- **PromotionOrderActionConfig**: Receives Order object, returns negative number for order-level discount
- **PromotionShippingActionConfig**: Receives ShippingLine and Order, returns negative number for shipping discount

All execute functions receive `ctx` (RequestContext), `args` (configuration arguments), `state` (condition results), and the `promotion` entity itself.

The `PromotionAction` class includes a `priorityValue` property (default: 0) used to determine application order when multiple promotions affect the same order.

**Examples:**

Example 1 (ts):
```ts
class PromotionAction<T extends ConfigArgs = ConfigArgs, U extends PromotionCondition[] | undefined = any> extends ConfigurableOperationDef<T> {    readonly priorityValue: number;    constructor(config: PromotionActionConfig<T, U>)}
```

Example 2 (ts):
```ts
// Applies a percentage discount to each OrderLineconst itemPercentageDiscount = new PromotionItemAction({    code: 'item_percentage_discount',    args: { discount: 'percentage' },    execute(ctx, orderLine, args) {        return -orderLine.unitPrice * (args.discount / 100);    },    description: 'Discount every item by { discount }%',});
```

Example 3 (ts):
```ts
class PromotionItemAction<T extends ConfigArgs = ConfigArgs, U extends Array<PromotionCondition<any>> = []> extends PromotionAction<T, U> {    constructor(config: PromotionItemActionConfig<T, U>)}
```

Example 4 (ts):
```ts
// Applies a percentage discount to the entire Orderconst orderPercentageDiscount = new PromotionOrderAction({    code: 'order_percentage_discount',    args: { discount: 'percentage' },    execute(ctx, order, args) {        return -order.subTotal * (args.discount / 100);    },    description: 'Discount order by { discount }%',});
```

---

## SchedulerService

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/scheduler-service

**Contents:**
- SchedulerService
- SchedulerService‚Äã
  - constructor‚Äã
  - onApplicationBootstrap‚Äã
  - onApplicationShutdown‚Äã
  - getTaskList‚Äã
  - updateTask‚Äã
  - runTask‚Äã

The service that is responsible for setting up and querying the scheduled tasks.

Returns a list of all the scheduled tasks and their current status.

**Examples:**

Example 1 (ts):
```ts
class SchedulerService implements OnApplicationBootstrap, OnApplicationShutdown {    constructor(configService: ConfigService, processContext: ProcessContext)    onApplicationBootstrap() => ;    onApplicationShutdown(signal?: string) => ;    getTaskList() => Promise<TaskInfo[]>;    updateTask(input: UpdateScheduledTaskInput) => Promise<TaskInfo>;    runTask(taskId: string) => Promise<Success>;}
```

---

## AddActionBarItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/add-action-bar-item

**Contents:**
- AddActionBarItem
- addActionBarItem‚Äã
  - config‚Äã

Adds a button to the ActionBar at the top right of each list or detail view. The locationId can be determined by pressing ctrl + u when running the Admin UI in dev mode.

**Examples:**

Example 1 (ts):
```ts
export default [    addActionBarItem({        id: 'print-invoice',        label: 'Print Invoice',        locationId: 'order-detail',        routerLink: ['/extensions/invoicing'],    }),];
```

Example 2 (ts):
```ts
function addActionBarItem(config: ActionBarItem): void
```

---

## ProductVariantPriceCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/product-variant-price-calculation-strategy

**Contents:**
- ProductVariantPriceCalculationStrategy
- ProductVariantPriceCalculationStrategy‚Äã
  - calculate‚Äã
- ProductVariantPriceCalculationArgs‚Äã
  - inputPrice‚Äã
  - productVariant‚Äã
  - taxCategory‚Äã
  - activeTaxZone‚Äã
  - ctx‚Äã

Defines how ProductVariant are calculated based on the input price, tax zone and current request context.

This is configured via the catalogOptions.productVariantPriceCalculationStrategy property of your VendureConfig.

The arguments passed the calculate method of the configured ProductVariantPriceCalculationStrategy.

The productVariant argument was added in v2.1.0.

**Examples:**

Example 1 (ts):
```ts
interface ProductVariantPriceCalculationStrategy extends InjectableStrategy {    calculate(args: ProductVariantPriceCalculationArgs): Promise<PriceCalculationResult>;}
```

Example 2 (ts):
```ts
interface ProductVariantPriceCalculationArgs {    inputPrice: number;    productVariant: ProductVariant;    taxCategory: TaxCategory;    activeTaxZone: Zone;    ctx: RequestContext;}
```

---

## PubSubJobQueueStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/job-queue-plugin/pub-sub-job-queue-strategy

**Contents:**
- PubSubJobQueueStrategy
- PubSubJobQueueStrategy‚Äã
  - init‚Äã
  - destroy‚Äã
  - add‚Äã
  - start‚Äã
  - stop‚Äã

This JobQueueStrategy uses Google Cloud Pub/Sub to implement a job queue for Vendure. It should not be used alone, but as part of the PubSubPlugin.

Note: To use this strategy, you need to manually install the @google-cloud/pubsub package:

Extends: InjectableJobQueueStrategy

Implements: JobQueueStrategy

**Examples:**

Example 1 (shell):
```shell
npm install```ts title="Signature"class PubSubJobQueueStrategy extends InjectableJobQueueStrategy implements JobQueueStrategy {    init(injector: Injector) => ;    destroy() => ;    add(job: Job<Data>) => Promise<Job<Data>>;    start(queueName: string, process: (job: Job<Data>) => Promise<any>) => ;    stop(queueName: string, process: (job: Job<Data>) => Promise<any>) => ;}
```

---

## UseAuth

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-auth

**Contents:**
- UseAuth
- useAuth‚Äã
- AuthContext‚Äã
  - status‚Äã
  - authenticationError‚Äã
  - isAuthenticated‚Äã
  - login‚Äã
  - logout‚Äã
  - user‚Äã
  - channels‚Äã

Provides access to the AuthContext which contains information about the active channel.

Provides information about the current user & their authentication & authorization status.

The status of the authentication.

The error message if the authentication fails.

Whether the user is authenticated.

The function to login the user.

The function to logout the user.

The function to refresh the current user.

**Examples:**

Example 1 (ts):
```ts
function useAuth(): void
```

Example 2 (ts):
```ts
interface AuthContext {    status: 'initial' | 'authenticated' | 'verifying' | 'unauthenticated';    authenticationError?: string;    isAuthenticated: boolean;    login: (username: string, password: string, onSuccess?: () => void) => void;    logout: (onSuccess?: () => void) => Promise<void>;    user: ResultOf<typeof CurrentUserQuery>['activeAdministrator'] | undefined;    channels: NonNullable<ResultOf<typeof CurrentUserQuery>['me']>['channels'] | undefined;    refreshCurrentUser: () => void;}
```

---

## RegisterRouteComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/routes/register-route-component

**Contents:**
- RegisterRouteComponent
- registerRouteComponent‚Äã
  - options‚Äã

Registers an Angular standalone component to be rendered in a route.

**Examples:**

Example 1 (ts):
```ts
import { registerRouteComponent } from '@vendure/admin-ui/core';import { registerReactRouteComponent } from '@vendure/admin-ui/react';import { ProductReviewDetailComponent } from './components/product-review-detail/product-review-detail.component';import { AllProductReviewsList } from './components/all-product-reviews-list/all-product-reviews-list.component';import { GetReviewDetailDocument } from './generated-types';export default [    registerRouteComponent({        path: '',        component: AllProductReviewsList,        breadcrumb: 'Product reviews',    }),    registerRouteComponent({    
...
```

Example 2 (ts):
```ts
function registerRouteComponent<Component extends any | BaseDetailComponent<Entity>, Entity extends { id: string; updatedAt?: string }, T extends DocumentNode | TypedDocumentNode<any, { id: string }>, Field extends keyof ResultOf<T>, R extends Field>(options: RegisterRouteComponentOptions<Component, Entity, T, Field, R>): void
```

---

## TaxOptions

**URL:** https://docs.vendure.io/reference/typescript-api/tax/tax-options

**Contents:**
- TaxOptions
- TaxOptions‚Äã
  - taxZoneStrategy‚Äã
  - taxLineCalculationStrategy‚Äã

Defines the strategy used to determine the applicable Zone used in tax calculations.

Defines the strategy used to calculate the TaxLines added to OrderItems.

**Examples:**

Example 1 (ts):
```ts
interface TaxOptions {    taxZoneStrategy?: TaxZoneStrategy;    taxLineCalculationStrategy?: TaxLineCalculationStrategy;}
```

---

## ActionBarItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/action-bar-item

**Contents:**
- ActionBarItem
- ActionBarItem‚Äã
  - id‚Äã
  - label‚Äã
  - locationId‚Äã
  - disabled‚Äã
  - buttonState‚Äã
  - onClick‚Äã
  - routerLink‚Äã
  - buttonColor‚Äã

A button in the ActionBar area at the top of one of the list or detail views.

A unique identifier for the item.

The label to display for the item. This can also be a translation token, e.g. invoice-plugin.print-invoice.

The location in the UI where this button should be displayed.

Deprecated since v2.1.0 - use buttonState instead.

A function which returns an observable of the button state, allowing you to dynamically enable/disable or show/hide the button.

An optional icon to display in the button. The icon should be a valid shape name from the Clarity Icons set.

Control the display of this item based on the user permissions. Note: if you attempt to pass a PermissionDefinition object, you will get a compilation error. Instead, pass the plain string version. For example, if the permission is defined as:

then the generated permission strings will be:

**Examples:**

Example 1 (ts):
```ts
interface ActionBarItem {    id: string;    label: string;    locationId: ActionBarLocationId;    disabled?: Observable<boolean>;    buttonState?: (context: ActionBarContext) => Observable<ActionBarButtonState>;    onClick?: (event: MouseEvent, context: ActionBarContext) => void;    routerLink?: RouterLinkDefinition;    buttonColor?: 'primary' | 'success' | 'warning';    buttonStyle?: 'solid' | 'outline' | 'link';    icon?: string;    requiresPermission?: string | string[];}
```

Example 2 (ts):
```ts
export const MyPermission = new PermissionDefinition('ProductReview');
```

---

## Allow Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/allow-decorator/

**Contents:**
- Allow Decorator
- Allow‚Äã
- Allow and Sessions‚Äã

Attaches metadata to the resolver defining which permissions are required to execute the operation, using one or more Permission values.

In a GraphQL context, it can be applied to top-level queries and mutations as well as field resolvers.

For REST controllers, it can be applied to route handler.

The @Allow() decorator is closely linked to the way Vendure manages sessions. For any operation or route that is decorated with @Allow(), there must be an authenticated session in progress, which would have been created during a prior authentication step.

The exception to this is when the operation is decorated with @Allow(Permission.Owner). This is a special permission which is designed to give access to certain resources to potentially un-authenticated users. For this reason, any operation decorated with this permission will always have an anonymous session created if no session is currently in progress.

For more information see Understanding Permission.Owner.

**Examples:**

Example 1 (ts):
```ts
@Allow(Permission.SuperAdmin) @Query() getAdministrators() {     // ... }
```

---

## HistoryEntryComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-history-entry-components/history-entry-component

**Contents:**
- HistoryEntryComponent
- HistoryEntryComponent‚Äã
  - entry‚Äã
  - getDisplayType‚Äã
  - isFeatured‚Äã
  - getName‚Äã
  - getIconShape‚Äã

This interface should be implemented by components intended to display a history entry in the Order or Customer history timeline. If the component needs access to the Order or Customer object itself, you should implement OrderHistoryEntryComponent or CustomerHistoryEntryComponent respectively.

The HistoryEntry data.

Defines whether this entry is highlighted with a "success", "error" etc. color.

Featured entries are always expanded. Non-featured entries start of collapsed and can be clicked to expand.

Returns the name of the person who did this action. For example, it could be the Customer's name or "Administrator".

Optional Clarity icon shape to display with the entry. Examples: 'note', ['success-standard', 'is-solid']

**Examples:**

Example 1 (ts):
```ts
interface HistoryEntryComponent {    entry: TimelineHistoryEntry;    getDisplayType: (entry: TimelineHistoryEntry) => TimelineDisplayType;    isFeatured: (entry: TimelineHistoryEntry) => boolean;    getName?: (entry: TimelineHistoryEntry) => string | undefined;    getIconShape?: (entry: TimelineHistoryEntry) => string | string[] | undefined;}
```

---

## RouterLinkDefinition

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/router-link-definition

**Contents:**
- RouterLinkDefinition
- RouterLinkDefinition‚Äã

A function which returns the router link for an ActionBarItem or NavMenuItem.

**Examples:**

Example 1 (ts):
```ts
type RouterLinkDefinition = ((route: ActivatedRoute, context: ActionBarContext) => any[]) | any[]
```

---

## StructFieldConfig

**URL:** https://docs.vendure.io/reference/typescript-api/custom-fields/struct-field-config

**Contents:**
- StructFieldConfig
- StructFieldConfig‚Äã

Configures an individual field of a "struct" custom field. The individual fields share the same API as the top-level custom fields, with the exception that they do not support the readonly, internal, nullable, unique and requiresPermission options.

**Examples:**

Example 1 (ts):
```ts
const customFields: CustomFields = {  Product: [    {      name: 'specifications',      type: 'struct',      fields: [        { name: 'processor', type: 'string' },        { name: 'ram', type: 'string' },        { name: 'screenSize', type: 'float' },      ],    },  ],};
```

Example 2 (ts):
```ts
type StructFieldConfig = | StringStructFieldConfig    | TextStructFieldConfig    | IntStructFieldConfig    | FloatStructFieldConfig    | BooleanStructFieldConfig    | DateTimeStructFieldConfig
```

---

## Dashboard Widgets

**URL:** https://docs.vendure.io/reference/admin-ui-api/dashboard-widgets/

**Contents:**
- Dashboard Widgets
- üìÑÔ∏è DashboardWidgetConfig
- üìÑÔ∏è RegisterDashboardWidget
- üìÑÔ∏è SetDashboardWidgetLayout
- üìÑÔ∏è WidgetLayoutDefinition

DashboardWidgetConfig

registerDashboardWidget

setDashboardWidgetLayout

WidgetLayoutDefinition

---

## Enums

**URL:** https://docs.vendure.io/reference/graphql-api/admin/enums

**Contents:**
- Enums
- AdjustmentType‚Äã
- AssetType‚Äã
- CurrencyCode‚Äã
- DeletionResult‚Äã
- ErrorCode‚Äã
- GlobalFlag‚Äã
- HistoryEntryType‚Äã
- JobState‚Äã
- LanguageCode‚Äã

---

## UseDisplayLocale

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-display-locale

**Contents:**
- UseDisplayLocale
- useDisplayLocale‚Äã

Returns information about the current display language & region.

**Examples:**

Example 1 (tsx):
```tsx
const {  bcp47Tag,  humanReadableLanguageAndLocale,  humanReadableLanguage,  isRTL,} = useDisplayLocale();console.log(bcp47Tag) // "en-GB"console.log(humanReadableLanguage) // "English"console.log(humanReadableLanguageAndLocale) // "British English"console.log(isRTL) // false
```

Example 2 (ts):
```ts
function useDisplayLocale(): void
```

---

## Role

**URL:** https://docs.vendure.io/reference/typescript-api/entities/role/

**Contents:**
- Role
- Role‚Äã
  - constructor‚Äã
  - code‚Äã
  - description‚Äã
  - permissions‚Äã
  - channels‚Äã

A Role represents a collection of permissions which determine the authorization level of a User on a given set of Channels.

Extends: VendureEntity

Implements: ChannelAware

**Examples:**

Example 1 (ts):
```ts
class Role extends VendureEntity implements ChannelAware {    constructor(input?: DeepPartial<Role>)    @Column() code: string;    @Column() description: string;    @Column('simple-array') permissions: Permission[];    @ManyToMany(type => Channel, channel => channel.roles)    @JoinTable()    channels: Channel[];}
```

---

## Default Inputs

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-input-components/default-inputs

**Contents:**
- Default Inputs
- BooleanFormInputComponent‚Äã
  - id‚Äã
  - readonly‚Äã
  - formControl‚Äã
  - config‚Äã
- HtmlEditorFormInputComponent‚Äã
  - id‚Äã
  - constructor‚Äã
  - ngOnInit‚Äã

A checkbox input. The default input component for boolean fields.

A JSON editor input with syntax highlighting and error detection. Works well with text type fields.

Extends: BaseCodeEditorFormInputComponent

Implements: FormInputComponent, AfterViewInit, OnInit

A JSON editor input with syntax highlighting and error detection. Works well with text type fields.

Extends: BaseCodeEditorFormInputComponent

Implements: FormInputComponent, AfterViewInit, OnInit

A special input used to display the "Combination mode" AND/OR toggle.

An input for monetary values. Should be used with int type fields.

Allows the selection of a Customer via an autocomplete select input. Should be used with ID type fields which represent Customer IDs.

Allows selection of a datetime. Default input for datetime type fields.

Allows the selection of multiple FacetValues via an autocomplete select input. Should be used with ID type list fields which represent FacetValue IDs.

Displays a number input. Default input for int and float type fields.

Displays a password text input. Should be used with string type fields.

Allows the selection of multiple ProductVariants via an autocomplete select input. Should be used with ID type list fields which represent ProductVariant IDs.

The default input component for relation type custom fields. Allows the selection of a ProductVariant, Product, Customer or Asset. For other entity types, a custom implementation will need to be defined. See registerFormInputComponent.

Uses the RichTextEditorComponent as in input for text type fields.

Uses a select input to allow the selection of a string value. Should be used with string type fields with options.

A checkbox input. The default input component for boolean fields.

Uses a regular text form input. This is the default input for string and localeString type fields.

Uses textarea form input. This is the default input for text type fields.

**Examples:**

Example 1 (ts):
```ts
class BooleanFormInputComponent implements FormInputComponent {    static readonly id: DefaultFormComponentId = 'boolean-form-input';    readonly: boolean;    formControl: UntypedFormControl;    config: DefaultFormComponentConfig<'boolean-form-input'>;}
```

Example 2 (ts):
```ts
class HtmlEditorFormInputComponent extends BaseCodeEditorFormInputComponent implements FormInputComponent, AfterViewInit, OnInit {    static readonly id: DefaultFormComponentId = 'html-editor-form-input';    constructor(changeDetector: ChangeDetectorRef)    ngOnInit() => ;}
```

Example 3 (ts):
```ts
class JsonEditorFormInputComponent extends BaseCodeEditorFormInputComponent implements FormInputComponent, AfterViewInit, OnInit {    static readonly id: DefaultFormComponentId = 'json-editor-form-input';    constructor(changeDetector: ChangeDetectorRef)    ngOnInit() => ;}
```

Example 4 (ts):
```ts
class CombinationModeFormInputComponent implements FormInputComponent, OnInit {    static readonly id: DefaultFormComponentId = 'combination-mode-form-input';    readonly: boolean;    formControl: UntypedFormControl;    config: DefaultFormComponentConfig<'combination-mode-form-input'>;    selectable$: Observable<boolean>;    constructor(configurableInputComponent: ConfigurableInputComponent)    ngOnInit() => ;    setCombinationModeAnd() => ;    setCombinationModeOr() => ;}
```

---

## Testing

**URL:** https://docs.vendure.io/reference/typescript-api/testing/

**Contents:**
- Testing
- üìÑÔ∏è CreateErrorResultGuard
- üìÑÔ∏è CreateTestEnvironment
- üìÑÔ∏è ErrorResultGuard
- üìÑÔ∏è GetSuperadminContext
- üìÑÔ∏è RegisterInitializer
- üìÑÔ∏è SimpleGraphQLClient
- üìÑÔ∏è TestConfig
- üìÑÔ∏è TestDbInitializer
- üìÑÔ∏è TestEnvironment

createErrorResultGuard

createTestEnvironment

---

## ActionBar

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/action-bar

**Contents:**
- ActionBar
- ActionBar‚Äã
  - props‚Äã

A container for the primary actions on a list or detail page

**Examples:**

Example 1 (ts):
```ts
import { ActionBar } from '@vendure/admin-ui/react';export function MyComponent() {  return (    <ActionBar leftContent={<div>Optional left content</div>}>      <button className='button primary'>Primary action</button>    </ActionBar>  );}
```

Example 2 (ts):
```ts
function ActionBar(props: PropsWithChildren<{ leftContent?: ReactNode }>): void
```

---

## Card

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/card

**Contents:**
- Card
- Card‚Äã
  - props‚Äã

A card component which can be used to group related content.

**Examples:**

Example 1 (ts):
```ts
import { Card } from '@vendure/admin-ui/react';export function MyComponent() {  return (    <Card title='My Title'>      <p>Some content</p>    </Card>  );}
```

Example 2 (ts):
```ts
function Card(props: PropsWithChildren<{ title?: string; paddingX?: boolean }>): void
```

---

## DefaultProductVariantPriceCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/default-product-variant-price-calculation-strategy

**Contents:**
- DefaultProductVariantPriceCalculationStrategy
- DefaultProductVariantPriceCalculationStrategy‚Äã
  - init‚Äã
  - calculate‚Äã

A default ProductVariant price calculation function.

**Examples:**

Example 1 (ts):
```ts
class DefaultProductVariantPriceCalculationStrategy implements ProductVariantPriceCalculationStrategy {    init(injector: Injector) => ;    calculate(args: ProductVariantPriceCalculationArgs) => Promise<PriceCalculationResult>;}
```

---

## FormFieldWrapper

**URL:** https://docs.vendure.io/reference/dashboard/form-components/form-field-wrapper

**Contents:**
- FormFieldWrapper
- FormFieldWrapper‚Äã
  - props‚Äã
- FormFieldWrapperProps‚Äã

This is a wrapper that can be used in all forms to wrap the actual form control, and provide a label, description and error message.

Use this instead of the default Shadcn FormField (etc.) components, as it also supports overridden form components.

If you are dealing with translatable fields, use the TranslatableFormFieldWrapper component instead.

The props for the FormFieldWrapper component.

**Examples:**

Example 1 (tsx):
```tsx
<PageBlock column="main" blockId="main-form">    <DetailFormGrid>        <FormFieldWrapper            control={form.control}            name="description"            label={<Trans>Description</Trans>}            render={({ field }) => <Input {...field} />}        />        <FormFieldWrapper            control={form.control}            name="code"            label={<Trans>Code</Trans>}            render={({ field }) => <Input {...field} />}        />    </DetailFormGrid></PageBlock>
```

Example 2 (ts):
```ts
function FormFieldWrapper<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: FormFieldWrapperProps<TFieldValues, TName>): void
```

Example 3 (ts):
```ts
type FormFieldWrapperProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = React.ComponentProps<typeof FormField<TFieldValues, TName>> & {    /**     * @description     * The label for the form field.     */    label?: React.ReactNode;    /**     * @description     * The description for the form field.     */    description?: React.ReactNode;    /**     * @description     * Whether to render the form control.     * If false, the form control will not be rendered.     * This is useful when you want to render the form control in 
...
```

---

## UseAlerts

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-alerts

**Contents:**
- UseAlerts
- useAlerts‚Äã
- AlertEntry‚Äã
  - definition‚Äã
  - active‚Äã
  - currentSeverity‚Äã
  - lastData‚Äã
  - dismiss‚Äã

Returns information about all registered Alerts, including how many are active and at what severity.

An individual Alert item.

**Examples:**

Example 1 (ts):
```ts
function useAlerts(): { alerts: AlertEntry[]; activeCount: number; highestSeverity: AlertSeverity }
```

Example 2 (ts):
```ts
interface AlertEntry {    definition: DashboardAlertDefinition;    active: boolean;    currentSeverity?: AlertSeverity;    lastData: any;    dismiss: () => void;}
```

---

## FacetValueChip

**URL:** https://docs.vendure.io/reference/dashboard/components/facet-value-chip

**Contents:**
- FacetValueChip
- FacetValueChip‚Äã
  - props‚Äã

A component for displaying a facet value as a chip.

**Examples:**

Example 1 (ts):
```ts
function FacetValueChip(props: FacetValueChipProps): void
```

---

## Interfaces

**URL:** https://docs.vendure.io/reference/typescript-api/entities/interfaces

**Contents:**
- Interfaces
- ChannelAware‚Äã
  - channels‚Äã
- SoftDeletable‚Äã
  - deletedAt‚Äã
- Orderable‚Äã
  - position‚Äã
- Taggable‚Äã
  - tags‚Äã
- Translatable‚Äã

Entities which can be assigned to Channels should implement this interface.

Entities which can be soft deleted should implement this interface.

Entities which can be ordered relative to their siblings in a list.

Entities which can have Tags applied to them.

Entities which have localizable string properties should implement this type.

**Examples:**

Example 1 (ts):
```ts
interface ChannelAware {    channels: Channel[];}
```

Example 2 (ts):
```ts
interface SoftDeletable {    deletedAt: Date | null;}
```

Example 3 (ts):
```ts
interface Orderable {    position: number;}
```

Example 4 (ts):
```ts
interface Taggable {    tags: Tag[];}
```

---

## Fulfillment

**URL:** https://docs.vendure.io/reference/typescript-api/entities/fulfillment

**Contents:**
- Fulfillment
- Fulfillment‚Äã
  - constructor‚Äã
  - state‚Äã
  - trackingCode‚Äã
  - method‚Äã
  - handlerCode‚Äã
  - lines‚Äã
  - orders‚Äã
  - customFields‚Äã

This entity represents a fulfillment of an Order or part of it, i.e. which OrderLines have been delivered to the Customer after successful payment.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Fulfillment extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<Fulfillment>)    @Column('varchar') state: FulfillmentState;    @Column({ default: '' })    trackingCode: string;    @Column()    method: string;    @Column()    handlerCode: string;    @OneToMany(type => FulfillmentLine, fulfillmentLine => fulfillmentLine.fulfillment)    lines: FulfillmentLine[];    @ManyToMany(type => Order, order => order.fulfillments)    orders: Order[];    @Column(type => CustomFulfillmentFields)    customFields: CustomFulfillmentFields;}
```

---

## RoundMoney

**URL:** https://docs.vendure.io/reference/typescript-api/money/round-money

**Contents:**
- RoundMoney
- roundMoney‚Äã
  - value‚Äã
  - quantity‚Äã

Rounds a monetary value according to the configured MoneyStrategy.

**Examples:**

Example 1 (ts):
```ts
function roundMoney(value: number, quantity:  = 1): number
```

---

## FulfillmentState

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/fulfillment-state

**Contents:**
- FulfillmentState
- FulfillmentState‚Äã

These are the default states of the fulfillment process. By default, they will be extended by the defaultFulfillmentProcess to also include Shipped and Delivered.

**Examples:**

Example 1 (ts):
```ts
type FulfillmentState = | 'Created'    | 'Pending'    | 'Cancelled'    | keyof CustomFulfillmentStates    | keyof FulfillmentStates
```

---

## Configuration

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/

**Contents:**
- Configuration
- üìÑÔ∏è ApiOptions
- üìÑÔ∏è CollectionFilter
- üìÑÔ∏è DefaultConfig
- üìÑÔ∏è DefaultSlugStrategy
- üìÑÔ∏è EntityDuplicator
- üìÑÔ∏è EntityId Decorator
- üìÑÔ∏è EntityIdStrategy
- üìÑÔ∏è EntityOptions
- üìÑÔ∏è MergeConfig

AutoIncrementIdStrategy

ProductVariantPriceSelectionStrategy

ProductVariantPriceUpdateStrategy

---

## TypedBaseDetailComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/typed-base-detail-component

**Contents:**
- TypedBaseDetailComponent
- TypedBaseDetailComponent‚Äã
  - result$‚Äã
  - entity‚Äã
  - constructor‚Äã
  - init‚Äã

A version of the BaseDetailComponent which is designed to be used with a TypedDocumentNode.

**Examples:**

Example 1 (ts):
```ts
class TypedBaseDetailComponent<T extends TypedDocumentNode<any, any>, Field extends keyof ResultOf<T>> extends BaseDetailComponent<NonNullable<ResultOf<T>[Field]>> {    protected result$: Observable<ResultOf<T>>;    protected entity: ResultOf<T>[Field];    constructor()    init() => ;}
```

---

## EmailPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/

**Contents:**
- EmailPlugin
- EmailPlugin‚Äã
- High-level description‚Äã
- Installation‚Äã
- Email templates‚Äã
  - Dynamic Email Templates‚Äã
- Customizing templates‚Äã
  - Setting global variables using globalTemplateVars‚Äã
  - Handlebars helpers‚Äã
- Extending the default email handler‚Äã

The EmailPlugin creates and sends transactional emails based on Vendure events. By default, it uses an MJML-based email generator to generate the email body and Nodemailer to send the emails.

Vendure has an internal events system (see EventBus) that allows plugins to subscribe to events. The EmailPlugin is configured with EmailEventHandlers that listen for a specific event and when it is published, the handler defines which template to use to generate the resulting email.

The plugin comes with a set of default handler for the following events:

You can also create your own handler and register them with the plugin - see the EmailEventHandler docs for more details.

yarn add @vendure/email-plugin

npm install @vendure/email-plugin

In the example above, the plugin has been configured to look in <app-root>/static/email/templates for the email template files. If you used @vendure/create to create your application, the templates will have been copied to that location during setup.

If you are installing the EmailPlugin separately, then you'll need to copy the templates manually from node_modules/@vendure/email-plugin/templates to a location of your choice, and then point the templatePath config property at that directory.

Instead of passing a static value to templatePath, use templateLoader to define a template path.

Emails are generated from templates which use MJML syntax. MJML is an open-source HTML-like markup language which makes the task of creating responsive email markup simple. By default, the templates are installed to <project root>/vendure/email/templates and can be freely edited.

Dynamic data such as the recipient's name or order items are specified using Handlebars syntax:

globalTemplateVars is an object that can be passed to the configuration of the Email Plugin with static object variables. You can also pass an async function that will be called with the RequestContext and the Injector so you can access services and e.g. load channel specific theme configurations.

The following helper functions are available for use in email templates:

The defaultEmailHandlers array defines the default handler such as for handling new account registration, order confirmation, password reset etc. These defaults can be extended by adding custom templates for languages other than the default, or even completely new types of emails which respond to any of the available VendureEvents.

A good way to learn how to create your own email handler is to take a look at the source code of the default handlers, which are located in the `default-email-handlers.ts` file.

**Default Email Handlers:**

The `defaultEmailHandlers` array provides built-in handlers for standard Vendure events:
- Order confirmation
- New customer email address verification
- Password reset request
- Email address change request

**Creating Custom Handlers:**

Custom handlers follow the same structure as the defaults, allowing developers to respond to any available VendureEvents.

**Modifying Default Handlers:**

Rather than replacing all defaults, you can import individual handlers and customize them:

```typescript
import {
  orderConfirmationHandler,
  emailVerificationHandler,
  passwordResetHandler,
  emailAddressChangeHandler,
} from '@vendure/email-plugin';
```

**Available Customization Methods:**

Individual handlers support these modifications:
- **setSubject()**: Set a new subject line (e.g., for order confirmation)
- **loadData()**: Fetch additional data via injected services
- **setTemplateVars()**: Define variables passed to email templates

You can chain these methods for sophisticated customizations, such as loading customer data before rendering password reset emails, then pass the modified handlers to `EmailPlugin.init()`.

**Examples:**

Example 1 (ts):
```ts
import { defaultEmailHandlers, EmailPlugin, FileBasedTemplateLoader } from '@vendure/email-plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    EmailPlugin.init({      handler: defaultEmailHandlers,      templateLoader: new FileBasedTemplateLoader(path.join(__dirname, '../static/email/templates')),      transport: {        type: 'smtp',        host: 'smtp.example.com',        port: 587,        auth: {          user: 'username',          pass: 'password',        }      },    }),  ],};
```

Example 2 (ts):
```ts
EmailPlugin.init({   ...,   templateLoader: new FileBasedTemplateLoader(my/order-confirmation/templates)  })
```

Example 3 (html):
```html
<p>Dear {{ order.customer.firstName }} {{ order.customer.lastName }},</p><p>Thank you for your order!</p><mj-table cellpadding="6px">  {{#each order.lines }}    <tr class="order-row">      <td>{{ quantity }} x {{ productVariant.name }}</td>      <td>{{ productVariant.quantity }}</td>      <td>{{ formatMoney totalPrice }}</td>    </tr>  {{/each}}</mj-table>
```

Example 4 (ts):
```ts
EmailPlugin.init({   globalTemplateVars: {     primaryColor: '#FF0000',     fromAddress: 'no-reply@ourstore.com'   }})
```

---

## ShippingLine

**URL:** https://docs.vendure.io/reference/typescript-api/entities/shipping-line

**Contents:**
- ShippingLine
- ShippingLine‚Äã
  - constructor‚Äã
  - shippingMethodId‚Äã
  - shippingMethod‚Äã
  - order‚Äã
  - listPrice‚Äã
  - listPriceIncludesTax‚Äã
  - adjustments‚Äã
  - taxLines‚Äã

A ShippingLine is created when a ShippingMethod is applied to an Order. It contains information about the price of the shipping method, any discounts that were applied, and the resulting tax on the shipping method.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class ShippingLine extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<ShippingLine>)    @EntityId()    shippingMethodId: ID | null;    @Index()    @ManyToOne(type => ShippingMethod)    shippingMethod: ShippingMethod;    @Index()    @ManyToOne(type => Order, order => order.shippingLines, { onDelete: 'CASCADE' })    order: Order;    @Money()    listPrice: number;    @Column()    listPriceIncludesTax: boolean;    @Column('simple-json')    adjustments: Adjustment[];    @Column('simple-json')    taxLines: TaxLine[];    @OneToMany(type => OrderLine, orderLine => or
...
```

---

## CacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/cache/cache-strategy/

**Contents:**
- CacheStrategy
- CacheStrategy‚Äã
  - get‚Äã
  - set‚Äã
  - delete‚Äã
  - invalidateTags‚Äã
- SetCacheKeyOptions‚Äã
  - ttl‚Äã
  - tags‚Äã

The CacheStrategy defines how the underlying shared cache mechanism is implemented.

It is used by the CacheService to take care of storage and retrieval of items from the cache.

If you are using the DefaultCachePlugin or the RedisCachePlugin, you will not need to manually specify a CacheStrategy, as these plugins will automatically configure the appropriate strategy.

This is configured via the systemOptions.cacheStrategy property of your VendureConfig.

Gets an item from the cache, or returns undefined if the key is not found, or the item has expired.

Sets a key-value pair in the cache. The value must be serializable, so cannot contain things like functions, circular data structures, class instances etc.

Optionally a "time to live" (ttl) can be specified, which means that the key will be considered stale after that many milliseconds.

Deletes an item from the cache.

Deletes all items from the cache which contain at least one matching tag.

Options available when setting the value in the cache.

The time-to-live for the cache key in milliseconds. This means that after this time period, the key will be considered stale and will no longer be returned from the cache. Omitting this is equivalent to having an infinite ttl.

An array of tags which can be used to group cache keys together. This can be useful for bulk deletion of related keys.

**Examples:**

Example 1 (ts):
```ts
interface CacheStrategy extends InjectableStrategy {    get<T extends JsonCompatible<T>>(key: string): Promise<T | undefined>;    set<T extends JsonCompatible<T>>(key: string, value: T, options?: SetCacheKeyOptions): Promise<void>;    delete(key: string): Promise<void>;    invalidateTags(tags: string[]): Promise<void>;}
```

Example 2 (ts):
```ts
interface SetCacheKeyOptions {    ttl?: number;    tags?: string[];}
```

---

## Address

**URL:** https://docs.vendure.io/reference/typescript-api/entities/address/

**Contents:**
- Address
- Address‚Äã
  - constructor‚Äã
  - customer‚Äã
  - fullName‚Äã
  - company‚Äã
  - streetLine1‚Äã
  - streetLine2‚Äã
  - city‚Äã
  - province‚Äã

Represents a Customer's address.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Address extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<Address>)    @Index()    @ManyToOne(type => Customer, customer => customer.addresses)    customer: Customer;    @Column({ default: '' }) fullName: string;    @Column({ default: '' })    company: string;    @Column() streetLine1: string;    @Column({ default: '' })    streetLine2: string;    @Column({ default: '' }) city: string;    @Column({ default: '' })    province: string;    @Column({ default: '' }) postalCode: string;    @Index()    @ManyToOne(type => Country)    country: Country;    @Colu
...
```

---

## SentryPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/sentry-plugin/

**Contents:**
- SentryPlugin
- SentryPlugin‚Äã
- Pre-requisites‚Äã
- Installation‚Äã
- Environment Variables‚Äã
- Configuration‚Äã
  - Step 1: Preload the Sentry instrument file‚Äã
  - Step 2: Add the SentryPlugin to your Vendure config‚Äã
- Tracing‚Äã
- Instrumenting your own code‚Äã

This plugin integrates the Sentry error tracking & performance monitoring service with your Vendure server. In addition to capturing errors, it also provides built-in support for tracing as well as enriching your Sentry events with additional context about the request.

This documentation applies from v3.5.0 of the plugin, which works differently to previous versions. Documentation for prior versions can be found here.

This plugin depends on access to Sentry, which can be self-hosted or used as a cloud service.

If using the hosted SaaS option, you must have a Sentry account and a project set up (sign up here). When setting up your project, select the "Node.js" platform and no framework.

Once set up, you will be given a Data Source Name (DSN) which you will need to provide to the plugin.

The following environment variables are used to control how the Sentry integration behaves:

Setting up the Sentry plugin requires two steps:

Make sure the SENTRY_DSN environment variable is defined.

The Sentry SDK must be initialized before your application starts. This is done by preloading the instrument file when starting your Vendure server:

Or if using TypeScript directly with tsx:

This plugin includes built-in support for tracing, which allows you to see the performance of your. To enable tracing, preload the instrument file as described in Step 1. This ensures that the Sentry SDK is initialized before any other code is executed.

You can also set the tracesSampleRate and profilesSampleRate options to control the sample rate for tracing and profiling, with the following environment variables:

The sample rate for tracing should be between 0 and 1. The sample rate for profiling should be between 0 and 1.

By default, both are set to undefined, which means that tracing and profiling are disabled.

You may want to add your own custom spans to your code. To do so, you can use the Sentry object from the @sentry/node package. For example:

To test whether your Sentry configuration is working correctly, you can set the includeErrorTestMutation option to true. This will add a mutation to the Admin API which will throw an error of the type specified in the errorType argument. For example:

You should then be able to see the error in your Sentry dashboard (it may take a couple of minutes to appear).

**Examples:**

Example 1 (sh):
```sh
npm install --save @vendure/sentry-plugin
```

Example 2 (sh):
```sh
node --import @vendure/sentry-plugin/instrument ./dist/index.js
```

Example 3 (sh):
```sh
tsx --import @vendure/sentry-plugin/instrument ./src/index.ts
```

Example 4 (ts):
```ts
import { VendureConfig } from '@vendure/core';import { SentryPlugin } from '@vendure/sentry-plugin';export const config: VendureConfig = {    // ...    plugins: [        // ...        SentryPlugin.init({            // Optional configuration            includeErrorTestMutation: true,        }),    ],};
```

---

## PageLayout

**URL:** https://docs.vendure.io/reference/dashboard/page-layout

**Contents:**
- PageLayout
- PageLayout‚Äã
  - props‚Äã
- PageLayoutProps‚Äã
  - children‚Äã
  - className‚Äã

This component governs the layout of the contents of a Page component. It should contain all the PageBlock components that are to be displayed on the page.

Status: Developer Preview

**Examples:**

Example 1 (ts):
```ts
function PageLayout(props: Readonly<PageLayoutProps>): void
```

Example 2 (ts):
```ts
type PageLayoutProps = {    children: React.ReactNode;    className?: string;}
```

---

## Seller

**URL:** https://docs.vendure.io/reference/typescript-api/entities/seller

**Contents:**
- Seller
- Seller‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - customFields‚Äã
  - channels‚Äã

A Seller represents the person or organization who is selling the goods on a given Channel. By default, a single-channel Vendure installation will have a single default Seller.

Extends: VendureEntity

Implements: SoftDeletable, HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Seller extends VendureEntity implements SoftDeletable, HasCustomFields {    constructor(input?: DeepPartial<Seller>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column() name: string;    @Column(type => CustomSellerFields)    customFields: CustomSellerFields;    @OneToMany(type => Channel, channel => channel.seller)    channels: Channel[];}
```

---

## HashedAssetNamingStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/hashed-asset-naming-strategy

**Contents:**
- HashedAssetNamingStrategy
- HashedAssetNamingStrategy‚Äã
  - generateSourceFileName‚Äã
  - generatePreviewFileName‚Äã

An extension of the DefaultAssetNamingStrategy which prefixes file names with the type ('source' or 'preview') as well as a 2-character sub-directory based on the md5 hash of the original file name.

This is an implementation of the technique knows as "hashed directory" file storage, and the purpose is to reduce the number of files in a single directory, since a very large number of files can lead to performance issues when reading and writing to that directory.

With this strategy, even with 200,000 total assets stored, each directory would only contain less than 800 files.

**Examples:**

Example 1 (ts):
```ts
class HashedAssetNamingStrategy extends DefaultAssetNamingStrategy {    generateSourceFileName(ctx: RequestContext, originalFileName: string, conflictFileName?: string) => string;    generatePreviewFileName(ctx: RequestContext, originalFileName: string, conflictFileName?: string) => string;}
```

---

## LocalizedStringArray

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/localized-string-array

**Contents:**
- LocalizedStringArray
- LocalizedStringArray‚Äã

An array of string values in a given LanguageCode, used to define human-readable string values. The ui property can be used in conjunction with the Vendure Admin UI to specify a custom form input component.

**Examples:**

Example 1 (ts):
```ts
const title: LocalizedStringArray = [  { languageCode: LanguageCode.en, value: 'English Title' },  { languageCode: LanguageCode.de, value: 'German Title' },  { languageCode: LanguageCode.zh, value: 'Chinese Title' },]
```

Example 2 (ts):
```ts
type LocalizedStringArray = Array<Omit<LocalizedString, '__typename'>>
```

---

## RegisterDataTableComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-table-components/register-data-table-component

**Contents:**
- RegisterDataTableComponent
- registerDataTableComponent‚Äã
  - config‚Äã

Allows you to override the default component used to render the data of a particular column in a DataTable. The component should implement the CustomColumnComponent interface. The tableId and columnId can be determined by pressing ctrl + u when running the Admin UI in dev mode.

**Examples:**

Example 1 (ts):
```ts
import { Component, Input } from '@angular/core';import { CustomColumnComponent } from '@vendure/admin-ui/core';@Component({    selector: 'custom-slug-component',    template: `        <a [href]="'https://example.com/products/' + rowItem.slug" target="_blank">{{ rowItem.slug }}</a>    `,    standalone: true,})export class CustomTableComponent implements CustomColumnComponent {    @Input() rowItem: any;}
```

Example 2 (ts):
```ts
import { registerDataTableComponent } from '@vendure/admin-ui/core';import { CustomTableComponent } from './components/custom-table.component';export default [    registerDataTableComponent({        component: CustomTableComponent,        tableId: 'product-list',        columnId: 'slug',    }),];
```

Example 3 (ts):
```ts
function registerDataTableComponent(config: DataTableComponentConfig): void
```

---

## I18nService

**URL:** https://docs.vendure.io/reference/typescript-api/common/i18n-service

**Contents:**
- I18nService
- I18nService‚Äã
  - addTranslationFile‚Äã
  - addTranslation‚Äã
- VendureTranslationResources‚Äã
  - error‚Äã
  - errorResult‚Äã
  - message‚Äã

Add a I18n translation by json file

Add a I18n translation (key-value) resource

I18n resources used for translations

**Examples:**

Example 1 (ts):
```ts
class I18nService implements OnModuleInit {    addTranslationFile(langKey: string, filePath: string) => void;    addTranslation(langKey: string, resources: VendureTranslationResources | any) => void;}
```

Example 2 (ts):
```ts
interface VendureTranslationResources {    error: any;    errorResult: any;    message: any;}
```

---

## React Hooks

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/

**Contents:**
- React Hooks
- üìÑÔ∏è UseDetailComponentData
- üìÑÔ∏è UseFormControl
- üìÑÔ∏è UseInjector
- üìÑÔ∏è UseLazyQuery
- üìÑÔ∏è UseMutation
- üìÑÔ∏è UsePageMetadata
- üìÑÔ∏è UseQuery
- üìÑÔ∏è UseRichTextEditor
- üìÑÔ∏è UseRouteParams

useDetailComponentData

---

## IfPermissionsDirective

**URL:** https://docs.vendure.io/reference/admin-ui-api/directives/if-permissions-directive

**Contents:**
- IfPermissionsDirective
- IfPermissionsDirective‚Äã
  - constructor‚Äã

Conditionally shows/hides templates based on the current active user having the specified permission. Based on the ngIf source. Also support "else" templates:

The permission can be a single string, or an array. If an array is passed, then all of the permissions must match (logical AND)

**Examples:**

Example 1 (html):
```html
<button *vdrIfPermissions="'DeleteCatalog'; else unauthorized">Delete Product</button><ng-template #unauthorized>Not allowed!</ng-template>
```

Example 2 (ts):
```ts
class IfPermissionsDirective extends IfDirectiveBase<Array<Permission[] | null>> {    constructor(_viewContainer: ViewContainerRef, templateRef: TemplateRef<any>, changeDetectorRef: ChangeDetectorRef, permissionsService: PermissionsService)}
```

---

## RunMigrations

**URL:** https://docs.vendure.io/reference/typescript-api/migration/run-migrations

**Contents:**
- RunMigrations
- runMigrations‚Äã
  - userConfig‚Äã

Runs any pending database migrations. See TypeORM migration docs for more information about the underlying migration mechanism.

**Examples:**

Example 1 (ts):
```ts
function runMigrations(userConfig: Partial<VendureConfig>): Promise<string[]>
```

---

## UseCustomFieldConfig

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-custom-field-config

**Contents:**
- UseCustomFieldConfig
- useCustomFieldConfig‚Äã
  - entityType‚Äã

Returns the custom field config for the given entity type (e.g. 'Product'). Also filters out any custom fields that the current active user does not have permissions to access.

**Examples:**

Example 1 (ts):
```ts
function useCustomFieldConfig(entityType: string): CustomFieldConfig[]
```

---

## Products Stock

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/

**Contents:**
- Products Stock
- üìÑÔ∏è CatalogOptions
- üìÑÔ∏è DefaultProductVariantPriceCalculationStrategy
- üìÑÔ∏è DefaultStockDisplayStrategy
- üìÑÔ∏è DefaultStockLocationStrategy
- üìÑÔ∏è MultiChannelStockLocationStrategy
- üìÑÔ∏è ProductVariantPriceCalculationStrategy
- üìÑÔ∏è StockDisplayStrategy
- üìÑÔ∏è StockLocationStrategy

DefaultProductVariantPriceCalculationStrategy

DefaultStockDisplayStrategy

DefaultStockLocationStrategy

MultiChannelStockLocationStrategy

ProductVariantPriceCalculationStrategy

StockLocationStrategy

---

## CleanupOrphanedSettingsStoreEntriesOptions

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/cleanup-orphaned-settings-store-entries-options

**Contents:**
- CleanupOrphanedSettingsStoreEntriesOptions
- CleanupOrphanedSettingsStoreEntriesOptions‚Äã
  - dryRun‚Äã
  - olderThan‚Äã
  - maxDeleteCount‚Äã
  - batchSize‚Äã

Options for cleaning up orphaned settings store entries.

If true, perform a dry run without actually deleting entries.

Only delete entries older than this duration. Examples: '30d', '7d', '1h', '30m'

Maximum number of entries to delete in a single operation.

Batch size for deletion operations.

**Examples:**

Example 1 (ts):
```ts
interface CleanupOrphanedSettingsStoreEntriesOptions {    dryRun?: boolean;    olderThan?: string;    maxDeleteCount?: number;    batchSize?: number;}
```

---

## S3AssetStorageStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/s3asset-storage-strategy/

**Contents:**
- S3AssetStorageStrategy
- S3AssetStorageStrategy‚Äã
- Use with S3-compatible services (MinIO)‚Äã
  - constructor‚Äã
  - init‚Äã
  - destroy‚Äã
  - writeFileFromBuffer‚Äã
  - writeFileFromStream‚Äã
  - readFileToBuffer‚Äã
  - readFileToStream‚Äã

An AssetStorageStrategy which uses Amazon S3 object storage service. To us this strategy you must first have access to an AWS account. See their getting started guide for how to get set up.

Before using this strategy, make sure you have the @aws-sdk/client-s3 and @aws-sdk/lib-storage package installed:

Note: Rather than instantiating this manually, use the configureS3AssetStorage function.

This strategy will also work with any S3-compatible object storage solutions, such as MinIO. See the configureS3AssetStorage for an example with MinIO.

Configuration for connecting to AWS S3.

The credentials used to access your s3 account. You can supply either the access key ID & secret, or you can make use of a shared credentials file To use a shared credentials file, import the fromIni() function from the "@aws-sdk/credential-provider-ini" or "@aws-sdk/credential-providers" package and supply the profile name (e.g. { profile: 'default' }) as its argument.

The S3 bucket in which to store the assets. If it does not exist, it will be created on startup.

Configuration object passed directly to the AWS SDK. S3.Types.ClientConfiguration can be used after importing aws-sdk. Using type any in order to avoid the need to include aws-sdk dependency in general.

Configuration object passed directly to the AWS SDK. ManagedUpload.ManagedUploadOptions can be used after importing aws-sdk. Using type any in order to avoid the need to include aws-sdk dependency in general.

Returns a configured instance of the S3AssetStorageStrategy which can then be passed to the AssetServerOptionsstorageStrategyFactory property.

Before using this strategy, make sure you have the @aws-sdk/client-s3 and @aws-sdk/lib-storage package installed:

Reference: How to use AWS SDK for Javascript with MinIO Server

**Examples:**

Example 1 (sh):
```sh
npm install @aws-sdk/client-s3 @aws-sdk/lib-storage
```

Example 2 (ts):
```ts
class S3AssetStorageStrategy implements AssetStorageStrategy {    constructor(s3Config: S3Config, toAbsoluteUrl: (request: Request, identifier: string) => string)    init() => ;    destroy?: (() => void | Promise<void>) | undefined;    writeFileFromBuffer(fileName: string, data: Buffer) => ;    writeFileFromStream(fileName: string, data: Readable) => ;    readFileToBuffer(identifier: string) => ;    readFileToStream(identifier: string) => ;    deleteFile(identifier: string) => ;    fileExists(fileName: string) => ;}
```

Example 3 (ts):
```ts
interface S3Config {    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;    bucket: string;    nativeS3Configuration?: any;    nativeS3UploadConfiguration?: any;}
```

Example 4 (sh):
```sh
npm install @aws-sdk/client-s3 @aws-sdk/lib-storage
```

---

## TaxLineCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/tax/tax-line-calculation-strategy/

**Contents:**
- TaxLineCalculationStrategy
- TaxLineCalculationStrategy‚Äã
  - calculate‚Äã
- CalculateTaxLinesArgs‚Äã
  - ctx‚Äã
  - order‚Äã
  - orderLine‚Äã
  - applicableTaxRate‚Äã

This strategy defines how the TaxLines on OrderItems are calculated. By default, the DefaultTaxLineCalculationStrategy is used, which directly applies a single TaxLine based on the applicable TaxRate.

However, custom strategies may use any suitable method for calculating TaxLines. For example, a third-party tax API or a lookup of a custom tax table may be used.

This is configured via the taxOptions.taxLineCalculationStrategy property of your VendureConfig.

This method is called when calculating the Order prices. Since it will be called whenever an Order is modified in some way (adding/removing items, applying promotions, setting ShippingMethod etc), care should be taken so that calling the function does not adversely impact overall performance. For example, by using caching and only calling external APIs when absolutely necessary.

**Examples:**

Example 1 (ts):
```ts
interface TaxLineCalculationStrategy extends InjectableStrategy {    calculate(args: CalculateTaxLinesArgs): TaxLine[] | Promise<TaxLine[]>;}
```

Example 2 (ts):
```ts
interface CalculateTaxLinesArgs {    ctx: RequestContext;    order: Order;    orderLine: OrderLine;    applicableTaxRate: TaxRate;}
```

---

## DataTables

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/data-tables

**Contents:**
- DataTables
- DashboardDataTableExtensionDefinition‚Äã
  - pageId‚Äã
  - blockId‚Äã
  - bulkActions‚Äã
  - extendListDocument‚Äã
  - displayComponents‚Äã

This allows you to customize aspects of existing data tables in the dashboard.

The ID of the page where the data table is located, e.g. 'product-list', 'order-list'.

The ID of the data table block. Defaults to 'list-table', which is the default blockId for the standard list pages. However, some other pages may use a different blockId, such as 'product-variants-table' on the 'product-detail' page.

An array of additional bulk actions that will be available on the data table.

Allows you to extend the list document for the data table.

Custom display components for specific columns in the data table.

**Examples:**

Example 1 (ts):
```ts
interface DashboardDataTableExtensionDefinition {    pageId: string;    blockId?: string;    bulkActions?: BulkAction[];    extendListDocument?: string | DocumentNode | (() => DocumentNode | string);    displayComponents?: DashboardDataTableDisplayComponent[];}
```

---

## ProductVariantSelectorComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/product-variant-selector-component

**Contents:**
- ProductVariantSelectorComponent
- ProductVariantSelectorComponent‚Äã
  - searchInput$‚Äã
  - searchLoading‚Äã
  - searchResults$‚Äã
  - productSelected‚Äã
  - constructor‚Äã
  - ngOnInit‚Äã
  - selectResult‚Äã

A component for selecting product variants via an autocomplete-style select input.

**Examples:**

Example 1 (html):
```html
<vdr-product-variant-selector  (productSelected)="selectResult($event)"></vdr-product-variant-selector>
```

Example 2 (ts):
```ts
class ProductVariantSelectorComponent implements OnInit {    searchInput$ = new Subject<string>();    searchLoading = false;    searchResults$: Observable<ProductSelectorSearchQuery['search']['items']>;    @Output() productSelected = new EventEmitter<ProductSelectorSearchQuery['search']['items'][number]>();    constructor(dataService: DataService)    ngOnInit() => void;    selectResult(product?: ProductSelectorSearchQuery['search']['items'][number]) => ;}
```

---

## Ctx Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/ctx-decorator/

**Contents:**
- Ctx Decorator
- Ctx‚Äã

Resolver param decorator which extracts the RequestContext from the incoming request object.

**Examples:**

Example 1 (ts):
```ts
@Query() getAdministrators(@Ctx() ctx: RequestContext) {     // ... }
```

---

## Permission

**URL:** https://docs.vendure.io/reference/typescript-api/common/permission

**Contents:**
- Permission
- Permission‚Äã
- Understanding Permission.Owner‚Äã

Permissions for administrators and customers. Used to control access to GraphQL resolvers via the Allow decorator.

Permission.Owner is a special permission which is used in some Vendure resolvers to indicate that that resolver should only be accessible to the "owner" of that resource.

For example, the Shop API activeCustomer query resolver should only return the Customer object for the "owner" of that Customer, i.e. based on the activeUserId of the current session. As a result, the resolver code looks like this:

Here we can see that the "ownership" must be enforced by custom logic inside the resolver. Since "ownership" cannot be defined generally nor statically encoded at build-time, any resolvers using Permission.Owner must include logic to enforce that only the owner of the resource has access. If not, then it is the equivalent of using Permission.Public.

**Examples:**

Example 1 (typescript):
```typescript
@Query()@Allow(Permission.Owner)async activeCustomer(@Ctx() ctx: RequestContext): Promise<Customer | undefined> {  const userId = ctx.activeUserId;  if (userId) {    return this.customerService.findOneByUserId(ctx, userId);  }}
```

Example 2 (ts):
```ts
enum Permission {    Authenticated = 'Authenticated'    CreateAdministrator = 'CreateAdministrator'    CreateAsset = 'CreateAsset'    CreateCatalog = 'CreateCatalog'    CreateChannel = 'CreateChannel'    CreateCollection = 'CreateCollection'    CreateCountry = 'CreateCountry'    CreateCustomer = 'CreateCustomer'    CreateCustomerGroup = 'CreateCustomerGroup'    CreateFacet = 'CreateFacet'    CreateOrder = 'CreateOrder'    CreatePaymentMethod = 'CreatePaymentMethod'    CreateProduct = 'CreateProduct'    CreatePromotion = 'CreatePromotion'    CreateSeller = 'CreateSeller'    CreateSettings = 'Cr
...
```

---

## CacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/cache/cache-strategy

**Contents:**
- CacheStrategy
- CacheStrategy‚Äã
  - get‚Äã
  - set‚Äã
  - delete‚Äã
  - invalidateTags‚Äã
- SetCacheKeyOptions‚Äã
  - ttl‚Äã
  - tags‚Äã

The CacheStrategy defines how the underlying shared cache mechanism is implemented.

It is used by the CacheService to take care of storage and retrieval of items from the cache.

If you are using the DefaultCachePlugin or the RedisCachePlugin, you will not need to manually specify a CacheStrategy, as these plugins will automatically configure the appropriate strategy.

This is configured via the systemOptions.cacheStrategy property of your VendureConfig.

Gets an item from the cache, or returns undefined if the key is not found, or the item has expired.

Sets a key-value pair in the cache. The value must be serializable, so cannot contain things like functions, circular data structures, class instances etc.

Optionally a "time to live" (ttl) can be specified, which means that the key will be considered stale after that many milliseconds.

Deletes an item from the cache.

Deletes all items from the cache which contain at least one matching tag.

Options available when setting the value in the cache.

The time-to-live for the cache key in milliseconds. This means that after this time period, the key will be considered stale and will no longer be returned from the cache. Omitting this is equivalent to having an infinite ttl.

An array of tags which can be used to group cache keys together. This can be useful for bulk deletion of related keys.

**Examples:**

Example 1 (ts):
```ts
interface CacheStrategy extends InjectableStrategy {    get<T extends JsonCompatible<T>>(key: string): Promise<T | undefined>;    set<T extends JsonCompatible<T>>(key: string, value: T, options?: SetCacheKeyOptions): Promise<void>;    delete(key: string): Promise<void>;    invalidateTags(tags: string[]): Promise<void>;}
```

Example 2 (ts):
```ts
interface SetCacheKeyOptions {    ttl?: number;    tags?: string[];}
```

---

## SqliteSearchStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/default-search-plugin/sqlite-search-strategy

**Contents:**
- SqliteSearchStrategy
- SqliteSearchStrategy‚Äã
  - init‚Äã
  - getFacetValueIds‚Äã
  - getCollectionIds‚Äã
  - getSearchResults‚Äã
  - getTotalCount‚Äã

A rather naive search for SQLite / SQL.js. Rather than proper full-text searching, it uses a weighted LIKE "%term%" operator instead.

**Examples:**

Example 1 (ts):
```ts
class SqliteSearchStrategy implements SearchStrategy {    init(injector: Injector) => ;    getFacetValueIds(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<Map<ID, number>>;    getCollectionIds(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<Map<ID, number>>;    getSearchResults(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<SearchResult[]>;    getTotalCount(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<number>;}
```

---

## Email Plugin Types

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-plugin-types

**Contents:**
- Email Plugin Types
- EventWithContext‚Äã
- EventWithAsyncData‚Äã
- EmailDetails‚Äã
  - from‚Äã
  - recipient‚Äã
  - subject‚Äã
  - body‚Äã
  - attachments‚Äã
  - cc‚Äã

A VendureEvent which also includes a ctx property containing the current RequestContext, which is used to determine the channel and language to use when generating the email.

A VendureEvent with a RequestContext and a data property which contains the value resolved from the EmailEventHandler.loadData() callback.

The final, generated email details to be sent.

A function used to load async data for use by an EmailEventHandler.

An object defining a file attachment for an email. Based on the object described here in the Nodemailer docs, but only uses the path property to define a filesystem path or a URL pointing to the attachment file.

The object passed to the TemplateLoader loadTemplate() method.

The type corresponds to the string passed to the EmailEventListener constructor.

The template name is specified by the EmailEventHander's call to the addTemplate() method, and will default to body.hbs

The variables defined by the globalTemplateVars as well as any variables defined in the EmailEventHandler's setTemplateVars() method.

A function used to define template variables available to email templates. See EmailEventHandler.setTemplateVars().

A function used to define attachments to be sent with the email. See https://nodemailer.com/message/attachments/ for more information about how attachments work in Nodemailer.

A function used to define the subject to be sent with the email.

Optional address-related fields for sending the email.

Comma separated list of recipients email addresses that will appear on the Cc: field

Comma separated list of recipients email addresses that will appear on the Bcc: field

An email address that will appear on the Reply-To: field

A function used to set the OptionalAddressFields.

A function used to set the EmailMetadata.

Metadata that can be attached to an email via the EmailEventHandler.setMetadata() method.

**Examples:**

Example 1 (ts):
```ts
type EventWithContext = VendureEvent & { ctx: RequestContext }
```

Example 2 (ts):
```ts
type EventWithAsyncData<Event extends EventWithContext, R> = Event & { data: R }
```

Example 3 (ts):
```ts
interface EmailDetails<Type extends 'serialized' | 'unserialized' = 'unserialized'> {    from: string;    recipient: string;    subject: string;    body: string;    attachments: Array<Type extends 'serialized' ? SerializedAttachment : Attachment>;    cc?: string;    bcc?: string;    replyTo?: string;}
```

Example 4 (ts):
```ts
type LoadDataFn<Event extends EventWithContext, R> = (context: {    event: Event;    injector: Injector;}) => Promise<R>
```

---

## RequestContextCacheService

**URL:** https://docs.vendure.io/reference/typescript-api/cache/request-context-cache-service

**Contents:**
- RequestContextCacheService
- RequestContextCacheService‚Äã
  - set‚Äã
  - get‚Äã
  - get‚Äã
  - get‚Äã

This service is used to cache arbitrary data relative to an ongoing request. It does this by using a WeakMap bound to the current RequestContext, so the cached data is available for the duration of the request. Once the request completes, the cached data will be automatically garbage-collected.

This is useful for caching data which is expensive to compute and which is needed multiple times during the handling of a single request.

Set a value in the RequestContext cache.

Get a value from the RequestContext cache. If the value is not found, the getDefault function will be called to get the value, which will then be cached and returned.

**Examples:**

Example 1 (ts):
```ts
class RequestContextCacheService {    set(ctx: RequestContext, key: any, val: T) => void;    get(ctx: RequestContext, key: any) => T | undefined;    get(ctx: RequestContext, key: any, getDefault?: () => T) => T;    get(ctx: RequestContext, key: any, getDefault?: () => T) => T | Promise<T> | undefined;}
```

---

## TransactionalConnection

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/transactional-connection

**Contents:**
- TransactionalConnection
- TransactionalConnection‚Äã
  - constructor‚Äã
  - rawConnection‚Äã
  - getRepository‚Äã
  - getRepository‚Äã
  - getRepository‚Äã
  - withTransaction‚Äã
  - withTransaction‚Äã
  - withTransaction‚Äã

The TransactionalConnection is a wrapper around the TypeORM Connection object which works in conjunction with the Transaction decorator to implement per-request transactions. All services which access the database should use this class rather than the raw TypeORM connection, to ensure that db changes can be easily wrapped in transactions when required.

The service layer does not need to know about the scope of a transaction, as this is covered at the API by the use of the Transaction decorator.

The plain TypeORM Connection object. Should be used carefully as any operations performed with this connection will not be performed within any outer transactions.

Returns a TypeORM repository. Note that when no RequestContext is supplied, the repository will not be aware of any existing transaction. Therefore, calling this method without supplying a RequestContext is discouraged without a deliberate reason.

Returns a TypeORM repository which is bound to any existing transactions. It is recommended to always pass the RequestContext argument when possible, otherwise the queries will be executed outside of any ongoing transactions which have been started by the Transaction decorator.

The options parameter allows specifying additional configurations, such as the replicationMode, which determines whether the repository should interact with the master or replica database.

Returns a TypeORM repository. Depending on the parameters passed, it will either be transaction-aware or not. If RequestContext is provided, the repository is bound to any ongoing transactions. The options parameter allows further customization, such as selecting the replication mode (e.g., 'master').

Allows database operations to be wrapped in a transaction, ensuring that in the event of an error being thrown at any point, the entire transaction will be rolled back and no changes will be saved.

In the context of API requests, you should instead use the Transaction decorator on your resolver or controller method.

On the other hand, for code that does not run in the context of a GraphQL/REST request, this method should be used to protect against non-atomic changes to the data which could leave your data in an inconsistent state.

Such situations include function processed by the JobQueue or stand-alone scripts which make use of Vendure internal services.

If there is already a RequestContext object available, you should pass it in as the first argument in order to create transactional context as

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
class TransactionalConnection {    constructor(dataSource: DataSource, transactionWrapper: TransactionWrapper)    rawConnection: DataSource    getRepository(target: ObjectType<Entity> | EntitySchema<Entity> | string) => Repository<Entity>;    getRepository(ctx: RequestContext | undefined, target: ObjectType<Entity> | EntitySchema<Entity> | string, options?: {            replicationMode?: ReplicationMode;        }) => Repository<Entity>;    getRepository(ctxOrTarget: RequestContext | ObjectType<Entity> | EntitySchema<Entity> | string | undefined, maybeTarget?: ObjectType<Entity> | EntitySchema<
...
```

Example 2 (ts):
```ts
private async transferCredit(outerCtx: RequestContext, fromId: ID, toId: ID, amount: number) {  await this.connection.withTransaction(outerCtx, async ctx => {    // Note you must not use `outerCtx` here, instead use `ctx`. Otherwise, this query    // will be executed outside of transaction    await this.giftCardService.updateCustomerCredit(ctx, fromId, -amount);    await this.connection.getRepository(ctx, GiftCard).update(fromId, { transferred: true })    // If some intermediate logic here throws an Error,    // then all DB transactions will be rolled back and neither Customer's    // credit b
...
```

---

## Types

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/types

**Contents:**
- Types
- BackoffStrategy‚Äã
- JobUpdate‚Äã
- JobUpdateOptions‚Äã
  - pollInterval‚Äã
  - timeoutMs‚Äã
  - errorOnFail‚Äã
- CreateQueueOptions‚Äã
  - name‚Äã
  - process‚Äã

Defines the backoff strategy used when retrying failed jobs. Returns the delay in ms that should pass before the failed job is retried.

Job update status as returned from the SubscribableJob's update() method.

Job update options, that you can specify by calling SubscribableJob updates method.

Used to configure a new JobQueue instance.

The name of the queue, e.g. "image processing", "re-indexing" etc.

Defines the work to be done for each job in the queue. The returned promise should resolve when the job is complete, or be rejected in case of an error.

A JSON-serializable data type which provides a Jobwith the data it needs to be processed.

Used to instantiate a new Job

**Examples:**

Example 1 (ts):
```ts
type BackoffStrategy = (queueName: string, attemptsMade: number, job: Job) => number
```

Example 2 (ts):
```ts
type JobUpdate<T extends JobData<T>> = Pick<    Job<T>,    'id' | 'state' | 'progress' | 'result' | 'error' | 'data'>
```

Example 3 (ts):
```ts
type JobUpdateOptions = {    pollInterval?: number;    timeoutMs?: number;    errorOnFail?: boolean;}
```

Example 4 (ts):
```ts
interface CreateQueueOptions<T extends JobData<T>> {    name: string;    process: (job: Job<T>) => Promise<any>;}
```

---

## OrderLine

**URL:** https://docs.vendure.io/reference/typescript-api/entities/order-line

**Contents:**
- OrderLine
- OrderLine‚Äã
  - constructor‚Äã
  - sellerChannel‚Äã
  - sellerChannelId‚Äã
  - shippingLine‚Äã
  - shippingLineId‚Äã
  - productVariant‚Äã
  - productVariantId‚Äã
  - taxCategory‚Äã

A single line on an Order which contains information about the ProductVariant and quantity ordered, as well as the price and tax information.

Extends: VendureEntity

Implements: HasCustomFields

The Channel of the Seller for a multivendor setup.

The ShippingLine to which this line has been assigned. This is determined by the configured ShippingLineAssignmentStrategy.

The ProductVariant which is being ordered.

The quantity of this OrderLine at the time the order was placed (as per the OrderPlacedStrategy).

The price as calculated when the OrderLine was first added to the Order. Usually will be identical to the listPrice, except when the ProductVariant price has changed in the meantime and a re-calculation of the Order has been performed.

This is the price as listed by the ProductVariant (and possibly modified by the OrderItemPriceCalculationStrategy), which, depending on the current Channel, may or may not include tax.

Whether the listPrice includes tax, which depends on the settings of the current Channel.

The price of a single unit, excluding tax and discounts.

The price of a single unit, including tax but excluding discounts.

Non-zero if the unitPrice has changed since it was initially added to Order.

Non-zero if the unitPriceWithTax has changed since it was initially added to Order.

The price of a single unit including discounts, excluding tax.

If Order-level discounts have been applied, this will not be the actual taxable unit price (see proratedUnitPrice), but is generally the correct price to display to customers to avoid confusion about the internal handling of distributed Order-level discounts.

The price of a single unit including discounts and tax

The actual unit price, taking into account both item discounts and prorated (proportionally-distributed) Order-level discounts. This value is the true economic value of a single unit in this OrderLine, and is used in tax and refund calculations.

The proratedUnitPrice including tax.

The total price of the line excluding tax and discounts.

The total price of the line including tax but excluding discounts.

The price of the line including discounts, excluding tax.

The price of the line including discounts and tax.

The total tax on this line.

The actual line price, taking into account both item discounts and prorated (proportionally-distributed) Order-level discounts. This value is the true economic value of the OrderLine, and is used in tax and refund calculations.

The proratedLinePric

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
class OrderLine extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<OrderLine>)    @Index()    @ManyToOne(type => Channel, { nullable: true, onDelete: 'SET NULL' })    sellerChannel?: Channel;    @EntityId({ nullable: true })    sellerChannelId?: ID;    @Index()    @ManyToOne(type => ShippingLine, shippingLine => shippingLine.orderLines, {        nullable: true,        onDelete: 'SET NULL',    })    shippingLine?: ShippingLine;    @EntityId({ nullable: true })    shippingLineId?: ID;    @Index()    @ManyToOne(type => ProductVariant, productVariant => productVa
...
```

---

## Channel

**URL:** https://docs.vendure.io/reference/typescript-api/entities/channel

**Contents:**
- Channel
- Channel‚Äã
  - constructor‚Äã
  - code‚Äã
  - token‚Äã
  - description‚Äã
  - seller‚Äã
  - sellerId‚Äã
  - defaultLanguageCode‚Äã
  - availableLanguageCodes‚Äã

A Channel represents a distinct sales channel and configures defaults for that channel.

In Vendure, Channels have a number of different uses, such as:

The name of the Channel. For example "US Webstore" or "German Webstore".

A unique token (string) used to identify the Channel in the vendure-token header of the GraphQL API requests.

Specifies the default value for inventory tracking for ProductVariants. Can be overridden per ProductVariant, but this value determines the default if not otherwise specified.

Specifies the value of stockOnHand at which a given ProductVariant is considered out of stock.

**Examples:**

Example 1 (ts):
```ts
class Channel extends VendureEntity {    constructor(input?: DeepPartial<Channel>)    @Column({ unique: true })    code: string;    @Column({ unique: true })    token: string;    @Column({ default: '', nullable: true })    description: string;    @Index()    @ManyToOne(type => Seller, seller => seller.channels)    seller?: Seller;    @EntityId({ nullable: true })    sellerId?: ID;    @Column('varchar') defaultLanguageCode: LanguageCode;    @Column({ type: 'simple-array', nullable: true })    availableLanguageCodes: LanguageCode[];    @Index()    @ManyToOne(type => Zone, zone => zone.defaultTax
...
```

---

## EntityOptions

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/entity-options

**Contents:**
- EntityOptions
- EntityOptions‚Äã
  - entityIdStrategy‚Äã
  - entityDuplicators‚Äã
  - moneyStrategy‚Äã
  - channelCacheTtl‚Äã
  - zoneCacheTtl‚Äã
  - taxRateCacheTtl‚Äã
  - metadataModifiers‚Äã
  - slugStrategy‚Äã

Options relating to the internal handling of entities.

Defines the strategy used for both storing the primary keys of entities in the database, and the encoding & decoding of those ids when exposing entities via the API. The default uses a simple auto-increment integer strategy.

Note: changing from an integer-based strategy to a uuid-based strategy on an existing Vendure database will lead to problems with broken foreign-key references. To change primary key types like this, you'll need to start with a fresh database.

An array of EntityDuplicator instances which are used to duplicate entities when using the duplicateEntity mutation.

Defines the strategy used to store and round monetary values.

Channels get cached in-memory as they are accessed very frequently. This setting determines how long the cache lives (in ms) until it is considered stale and refreshed. For multi-instance deployments (e.g. serverless, load-balanced), a smaller value here will prevent data inconsistencies between instances.

Zones get cached in-memory as they are accessed very frequently. This setting determines how long the cache lives (in ms) until it is considered stale and refreshed. For multi-instance deployments (e.g. serverless, load-balanced), a smaller value here will prevent data inconsistencies between instances.

TaxRates get cached in-memory as they are accessed very frequently. This setting determines how long the cache lives (in ms) until it is considered stale and refreshed. For multi-instance deployments (e.g. serverless, load-balanced), a smaller value here will prevent data inconsistencies between instances.

Allows the metadata of the built-in TypeORM entities to be manipulated. This allows you to do things like altering data types, adding indices etc. This is an advanced feature which should be used with some caution as it will result in DB schema changes. For examples see EntityMetadataModifier.

Defines the strategy for generating slugs from input strings. Slugs are URL-friendly versions of text commonly used for entity identifiers in URLs.

A function which allows TypeORM entity metadata to be manipulated prior to the DB schema being generated during bootstrap.

Certain DB schema modifications will result in auto-generated migrations which will lead to data loss. For instance, changing the data type of a column will drop the column & data and then re-create it. To avoid loss of important data, always check and modify your migration scripts as needed.

**Examples:**

Example 1 (ts):
```ts
interface EntityOptions {    entityIdStrategy?: EntityIdStrategy<any>;    entityDuplicators?: Array<EntityDuplicator<any>>;    moneyStrategy?: MoneyStrategy;    channelCacheTtl?: number;    zoneCacheTtl?: number;    taxRateCacheTtl?: number;    metadataModifiers?: EntityMetadataModifier[];    slugStrategy?: SlugStrategy;}
```

Example 2 (ts):
```ts
import { Index } from 'typeorm';import { EntityMetadataModifier, ProductVariant } from '@vendure/core';// Adds a unique index to the ProductVariant.sku columnexport const addSkuUniqueIndex: EntityMetadataModifier = metadata => {  const instance = new ProductVariant();  Index({ unique: true })(instance, 'sku');};
```

Example 3 (ts):
```ts
import { Column } from 'typeorm';import { EntityMetadataModifier, ProductTranslation } from '@vendure/core';// Use the "mediumtext" datatype for the Product's description rather than// the default "text" type.export const makeProductDescriptionMediumText: EntityMetadataModifier = metadata => {    const descriptionColumnIndex = metadata.columns.findIndex(        col => col.propertyName === 'description' && col.target === ProductTranslation,    );    if (-1 < descriptionColumnIndex) {        // First we need to remove the existing column definition        // from the metadata.        metadata.co
...
```

Example 4 (ts):
```ts
type EntityMetadataModifier = (metadata: MetadataArgsStorage) => void | Promise<void>
```

---

## AdminUiPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/admin-ui-plugin/

**Contents:**
- AdminUiPlugin
- AdminUiPlugin‚Äã
- Installation‚Äã
- Metrics‚Äã
  - constructor‚Äã
  - init‚Äã
  - configure‚Äã

From Vendure v3.5.0, the Angular-based Admin UI has been replaced by the new React Admin Dashboard. The Angular Admin UI will not be maintained after July 2026. Until then, we will continue patching critical bugs and security issues. Community contributions will always be merged and released.

This plugin starts a static server for the Admin UI app, and proxies it via the /admin/ path of the main Vendure server.

The Admin UI allows you to administer all aspects of your store, from inventory management to order tracking. It is the tool used by store administrators on a day-to-day basis for the management of the store.

yarn add @vendure/admin-ui-plugin

npm install @vendure/admin-ui-plugin

This plugin also defines a metricSummary query which is used by the Admin UI to display the order metrics on the dashboard.

If you are building a stand-alone version of the Admin UI app, and therefore don't need this plugin to server the Admin UI, you can still use the metricSummary query by adding the AdminUiPlugin to the plugins array, but without calling the init() method:

Set the plugin options

**Examples:**

Example 1 (ts):
```ts
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    AdminUiPlugin.init({ port: 3002 }),  ],};
```

Example 2 (ts):
```ts
import { AdminUiPlugin } from '@vendure/admin-ui-plugin';const config: VendureConfig = {  plugins: [    AdminUiPlugin, // <-- no call to .init()  ],  // ...};
```

Example 3 (ts):
```ts
class AdminUiPlugin implements NestModule {    constructor(configService: ConfigService, processContext: ProcessContext)    init(options: AdminUiPluginOptions) => Type<AdminUiPlugin>;    configure(consumer: MiddlewareConsumer) => ;}
```

---

## OrderPlacedStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-placed-strategy/

**Contents:**
- OrderPlacedStrategy
- OrderPlacedStrategy‚Äã
  - shouldSetAsPlaced‚Äã

This strategy is responsible for deciding at which stage in the order process the Order will be set as "placed" (i.e. the Customer has checked out, and next it must be processed by an Administrator).

By default, the order is set as "placed" when it transitions from 'ArrangingPayment' to either 'PaymentAuthorized' or 'PaymentSettled'.

This is configured via the orderOptions.orderPlacedStrategy property of your VendureConfig.

This method is called whenever an active Order transitions from one state to another. If it resolves to true, then the Order will be set as "placed", which means:

**Examples:**

Example 1 (ts):
```ts
interface OrderPlacedStrategy extends InjectableStrategy {    shouldSetAsPlaced(        ctx: RequestContext,        fromState: OrderState,        toState: OrderState,        order: Order,    ): boolean | Promise<boolean>;}
```

---

## VendureEntity

**URL:** https://docs.vendure.io/reference/typescript-api/entities/vendure-entity/

**Contents:**
- VendureEntity
- VendureEntity‚Äã
  - constructor‚Äã
  - id‚Äã
  - createdAt‚Äã
  - updatedAt‚Äã

This is the base class from which all entities inherit. The type of the id property is defined by the EntityIdStrategy.

**Examples:**

Example 1 (ts):
```ts
class VendureEntity {    constructor(input?: DeepPartial<VendureEntity>)    @PrimaryGeneratedId()    id: ID;    @CreateDateColumn() createdAt: Date;    @UpdateDateColumn() updatedAt: Date;}
```

---

## ListQueryBuilder

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/list-query-builder

**Contents:**
- ListQueryBuilder
- ListQueryBuilder‚Äã
  - constructor‚Äã
  - filterObjectHasProperty‚Äã
  - build‚Äã
- ExtendedListQueryOptions‚Äã
  - relations‚Äã
  - channelId‚Äã
  - where‚Äã
  - orderBy‚Äã

This helper class is used when fetching entities the database from queries which return a PaginatedList type. These queries all follow the same format:

In the GraphQL definition, they return a type which implements the Node interface, and the query returns a type which implements the PaginatedList interface:

When Vendure bootstraps, it will find the BlogPostListOptions input and, because it is used in a query returning a PaginatedList type, it knows that it should dynamically generate this input. This means all primitive field of the BlogPost type (namely, "published", "title" and "body") will have filter and sort inputs created for them, as well a skip and take fields for pagination.

Your resolver function will then look like this:

and the corresponding service will use the ListQueryBuilder:

Used to determine whether a list query filter object contains the given property, either at the top level or nested inside a boolean _and or _or expression.

This is useful when a custom property map is used to map a filter field to a related entity, and we need to determine whether the filter object contains that property, which then means we would need to join that relation.

Options which can be passed to the ListQueryBuilder's build() method.

Allows you to specify the alias used for the entity T in the generated SQL query. Defaults to the entity class name lower-cased, i.e. ProductVariant -> 'productvariant'.

When a RequestContext is passed, then the query will be executed as part of any outer transaction.

One of the main tasks of the ListQueryBuilder is to auto-generate filter and sort queries based on the available columns of a given entity. However, it may also be sometimes desirable to allow filter/sort on a property of a relation. In this case, the customPropertyMap can be used to define a property of the options.sort or options.filter which does not correspond to a direct column of the current entity, and then provide a mapping to the related property to be sorted/filtered.

Example: we want to allow sort/filter by and Order's customerLastName. The actual lastName property is not a column in the Order table, it exists on the Customer entity, and Order has a relation to Customer via Order.customer. Therefore, we can define a customPropertyMap like this:

We can now use the customerLastName property to filter or sort on the list query:

When set to true, the configured shopListQueryLimit and adminListQueryLimit values will be ignored, allowing unlimite

*[Content truncated]*

**Examples:**

Example 1 (graphql):
```graphql
type BlogPost implements Node {  id: ID!  published: DateTime!  title: String!  body: String!}type BlogPostList implements PaginatedList {  items: [BlogPost!]!  totalItems: Int!}# Generated at run-time by Vendureinput BlogPostListOptionsextend type Query {   blogPosts(options: BlogPostListOptions): BlogPostList!}
```

Example 2 (ts):
```ts
@Resolver()export class BlogPostResolver  constructor(private blogPostService: BlogPostService) {}  @Query()  async blogPosts(    @Ctx() ctx: RequestContext,    @Args() args: any,  ): Promise<PaginatedList<BlogPost>> {    return this.blogPostService.findAll(ctx, args.options || undefined);  }}
```

Example 3 (ts):
```ts
@Injectable()export class BlogPostService {  constructor(private listQueryBuilder: ListQueryBuilder) {}  findAll(ctx: RequestContext, options?: ListQueryOptions<BlogPost>) {    return this.listQueryBuilder      .build(BlogPost, options)      .getManyAndCount()      .then(async ([items, totalItems]) => {        return { items, totalItems };      });  }}
```

Example 4 (ts):
```ts
class ListQueryBuilder implements OnApplicationBootstrap {    constructor(connection: TransactionalConnection, configService: ConfigService)    filterObjectHasProperty(filterObject: FP | NullOptionals<FP> | null | undefined, property: keyof FP) => boolean;    build(entity: Type<T>, options: ListQueryOptions<T> = {}, extendedOptions: ExtendedListQueryOptions<T> = {}) => SelectQueryBuilder<T>;}
```

---

## React Extensions

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/

**Contents:**
- React Extensions
- üìÑÔ∏è ReactCustomDetailComponentConfig
- üìÑÔ∏è ReactDataTableComponentConfig
- üìÑÔ∏è RegisterReactCustomDetailComponent
- üìÑÔ∏è RegisterReactDataTableComponent
- üìÑÔ∏è RegisterReactFormInputComponent
- üìÑÔ∏è RegisterReactRouteComponentOptions
- üìÑÔ∏è RegisterReactRouteComponent

ReactCustomDetailComponentConfig

ReactDataTableComponentConfig

registerReactCustomDetailComponent

registerReactDataTableComponent

registerReactFormInputComponent

RegisterReactRouteComponentOptions

registerReactRouteComponent

---

## DefaultSchedulerPlugin

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/default-scheduler-plugin

**Contents:**
- DefaultSchedulerPlugin
- DefaultSchedulerPlugin‚Äã
  - options‚Äã
  - init‚Äã
- DefaultSchedulerPluginOptions‚Äã
  - defaultTimeout‚Äã
  - manualTriggerCheckInterval‚Äã

This plugin configures a default scheduling strategy that executes scheduled tasks using the database to ensure that each task is executed exactly once at the scheduled time, even if there are multiple instances of the worker running.

The options for the DefaultSchedulerPlugin.

The default timeout for scheduled tasks.

The interval at which the plugin will check for manually triggered tasks.

**Examples:**

Example 1 (ts):
```ts
import { DefaultSchedulerPlugin, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  plugins: [    DefaultSchedulerPlugin.init({      // The default is 60s, but you can override it here      defaultTimeout: '10s',    }),  ],};
```

Example 2 (ts):
```ts
class DefaultSchedulerPlugin {    static options: DefaultSchedulerPluginOptions = {        defaultTimeout: DEFAULT_TIMEOUT,        manualTriggerCheckInterval: DEFAULT_MANUAL_TRIGGER_CHECK_INTERVAL,    };    init(config?: DefaultSchedulerPluginOptions) => ;}
```

Example 3 (ts):
```ts
interface DefaultSchedulerPluginOptions {    defaultTimeout?: string | number;    manualTriggerCheckInterval?: string | number;}
```

---

## TestServer

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-server

**Contents:**
- TestServer
- TestServer‚Äã
  - app‚Äã
  - constructor‚Äã
  - init‚Äã
  - bootstrap‚Äã
  - destroy‚Äã

A real Vendure server against which the e2e tests should be run.

Bootstraps an instance of Vendure server and populates the database according to the options passed in. Should be called in the beforeAll function.

The populated data is saved into an .sqlite file for each test file. On subsequent runs, this file is loaded so that the populate step can be skipped, which speeds up the tests significantly.

Bootstraps a Vendure server instance. Generally the .init() method should be used, as that will also populate the test data. However, the bootstrap() method is sometimes useful in tests which need to start and stop a Vendure instance multiple times without re-populating data.

Destroy the Vendure server instance and clean up all resources. Should be called after all tests have run, e.g. in an afterAll function.

**Examples:**

Example 1 (ts):
```ts
class TestServer {    public app: INestApplication;    constructor(vendureConfig: Required<VendureConfig>)    init(options: TestServerOptions) => Promise<void>;    bootstrap() => ;    destroy() => ;}
```

---

## SharpAssetPreviewStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/sharp-asset-preview-strategy

**Contents:**
- SharpAssetPreviewStrategy
- SharpAssetPreviewStrategy‚Äã
  - constructor‚Äã
  - generatePreviewImage‚Äã
- SharpAssetPreviewConfig‚Äã
  - maxHeight‚Äã
  - maxWidth‚Äã
  - jpegOptions‚Äã
  - pngOptions‚Äã
  - webpOptions‚Äã

This AssetPreviewStrategy uses the Sharp library to generate preview images of uploaded binary files. For non-image binaries, a generic "file" icon with the mime type overlay will be generated.

By default, this strategy will produce previews up to maximum dimensions of 1600 x 1600 pixels. The created preview images will match the input format - so a source file in jpeg format will output a jpeg preview, a webp source file will output a webp preview, and so on.

The settings for the outputs will default to Sharp's defaults (https://sharp.pixelplumbing.com/api-output). However, it is possible to pass your own configurations to control the output of each format:

This AssetPreviewStrategy uses the Sharp library to generate preview images of uploaded binary files. For non-image binaries, a generic "file" icon with the mime type overlay will be generated.

The max height in pixels of a generated preview image.

The max width in pixels of a generated preview image.

Set Sharp's options for encoding jpeg files: https://sharp.pixelplumbing.com/api-output#jpeg

Set Sharp's options for encoding png files: https://sharp.pixelplumbing.com/api-output#png

Set Sharp's options for encoding webp files: https://sharp.pixelplumbing.com/api-output#webp

Set Sharp's options for encoding gif files: https://sharp.pixelplumbing.com/api-output#gif

Set Sharp's options for encoding avif files: https://sharp.pixelplumbing.com/api-output#avif

**Examples:**

Example 1 (ts):
```ts
AssetServerPlugin.init({  previewStrategy: new SharpAssetPreviewStrategy({    jpegOptions: { quality: 95 },    webpOptions: { quality: 95 },  }),}),
```

Example 2 (ts):
```ts
class SharpAssetPreviewStrategy implements AssetPreviewStrategy {    constructor(config?: SharpAssetPreviewConfig)    generatePreviewImage(ctx: RequestContext, mimeType: string, data: Buffer) => Promise<Buffer>;}
```

Example 3 (ts):
```ts
interface SharpAssetPreviewConfig {    maxHeight?: number;    maxWidth?: number;    jpegOptions?: sharp.JpegOptions;    pngOptions?: sharp.PngOptions;    webpOptions?: sharp.WebpOptions;    gifOptions?: sharp.GifOptions;    avifOptions?: sharp.AvifOptions;}
```

---

## PromotionOptions

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/promotion-options/

**Contents:**
- PromotionOptions
- PromotionOptions‚Äã
  - promotionConditions‚Äã
  - promotionActions‚Äã

An array of conditions which can be used to construct Promotions

An array of actions which can be used to construct Promotions

**Examples:**

Example 1 (ts):
```ts
interface PromotionOptions {    promotionConditions?: Array<PromotionCondition<any>>;    promotionActions?: Array<PromotionAction<any>>;}
```

---

## VendureWorker

**URL:** https://docs.vendure.io/reference/typescript-api/worker/vendure-worker

**Contents:**
- VendureWorker
- VendureWorker‚Äã
  - app‚Äã
  - constructor‚Äã
  - startJobQueue‚Äã
  - startHealthCheckServer‚Äã

This object is created by calling the bootstrapWorker function.

A reference to the INestApplicationContext object, which represents the NestJS standalone application instance.

Starts the job queues running so that the worker can handle background jobs.

Starts a simple http server which can be used as a health check on the worker instance. This endpoint can be used by container orchestration services such as Kubernetes to verify whether the worker is running.

**Examples:**

Example 1 (ts):
```ts
class VendureWorker {    public app: INestApplicationContext;    constructor(app: INestApplicationContext)    startJobQueue() => Promise<VendureWorker>;    startHealthCheckServer(healthCheckConfig: WorkerHealthCheckConfig) => Promise<VendureWorker>;}
```

---

## EntityOptions

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/entity-options/

**Contents:**
- EntityOptions
- EntityOptions‚Äã
  - entityIdStrategy‚Äã
  - entityDuplicators‚Äã
  - moneyStrategy‚Äã
  - channelCacheTtl‚Äã
  - zoneCacheTtl‚Äã
  - taxRateCacheTtl‚Äã
  - metadataModifiers‚Äã
  - slugStrategy‚Äã

Options relating to the internal handling of entities.

Defines the strategy used for both storing the primary keys of entities in the database, and the encoding & decoding of those ids when exposing entities via the API. The default uses a simple auto-increment integer strategy.

Note: changing from an integer-based strategy to a uuid-based strategy on an existing Vendure database will lead to problems with broken foreign-key references. To change primary key types like this, you'll need to start with a fresh database.

An array of EntityDuplicator instances which are used to duplicate entities when using the duplicateEntity mutation.

Defines the strategy used to store and round monetary values.

Channels get cached in-memory as they are accessed very frequently. This setting determines how long the cache lives (in ms) until it is considered stale and refreshed. For multi-instance deployments (e.g. serverless, load-balanced), a smaller value here will prevent data inconsistencies between instances.

Zones get cached in-memory as they are accessed very frequently. This setting determines how long the cache lives (in ms) until it is considered stale and refreshed. For multi-instance deployments (e.g. serverless, load-balanced), a smaller value here will prevent data inconsistencies between instances.

TaxRates get cached in-memory as they are accessed very frequently. This setting determines how long the cache lives (in ms) until it is considered stale and refreshed. For multi-instance deployments (e.g. serverless, load-balanced), a smaller value here will prevent data inconsistencies between instances.

Allows the metadata of the built-in TypeORM entities to be manipulated. This allows you to do things like altering data types, adding indices etc. This is an advanced feature which should be used with some caution as it will result in DB schema changes. For examples see EntityMetadataModifier.

Defines the strategy for generating slugs from input strings. Slugs are URL-friendly versions of text commonly used for entity identifiers in URLs.

A function which allows TypeORM entity metadata to be manipulated prior to the DB schema being generated during bootstrap.

Certain DB schema modifications will result in auto-generated migrations which will lead to data loss. For instance, changing the data type of a column will drop the column & data and then re-create it. To avoid loss of important data, always check and modify your migration scripts as needed.

**Examples:**

Example 1 (ts):
```ts
interface EntityOptions {    entityIdStrategy?: EntityIdStrategy<any>;    entityDuplicators?: Array<EntityDuplicator<any>>;    moneyStrategy?: MoneyStrategy;    channelCacheTtl?: number;    zoneCacheTtl?: number;    taxRateCacheTtl?: number;    metadataModifiers?: EntityMetadataModifier[];    slugStrategy?: SlugStrategy;}
```

Example 2 (ts):
```ts
import { Index } from 'typeorm';import { EntityMetadataModifier, ProductVariant } from '@vendure/core';// Adds a unique index to the ProductVariant.sku columnexport const addSkuUniqueIndex: EntityMetadataModifier = metadata => {  const instance = new ProductVariant();  Index({ unique: true })(instance, 'sku');};
```

Example 3 (ts):
```ts
import { Column } from 'typeorm';import { EntityMetadataModifier, ProductTranslation } from '@vendure/core';// Use the "mediumtext" datatype for the Product's description rather than// the default "text" type.export const makeProductDescriptionMediumText: EntityMetadataModifier = metadata => {    const descriptionColumnIndex = metadata.columns.findIndex(        col => col.propertyName === 'description' && col.target === ProductTranslation,    );    if (-1 < descriptionColumnIndex) {        // First we need to remove the existing column definition        // from the metadata.        metadata.co
...
```

Example 4 (ts):
```ts
type EntityMetadataModifier = (metadata: MetadataArgsStorage) => void | Promise<void>
```

---

## PageLocationId

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/page-location-id

**Contents:**
- PageLocationId
- PageLocationId‚Äã

The valid locationIds for registering action bar items or tabs.

**Examples:**

Example 1 (ts):
```ts
type PageLocationId = | 'administrator-detail'    | 'administrator-list'    | 'asset-detail'    | 'asset-list'    | 'channel-detail'    | 'channel-list'    | 'collection-detail'    | 'collection-list'    | 'country-detail'    | 'country-list'    | 'customer-detail'    | 'customer-list'    | 'customer-group-list'    | 'customer-group-detail'    | 'draft-order-detail'    | 'facet-detail'    | 'facet-list'    | 'global-setting-detail'    | 'system-status'    | 'job-list'    | 'order-detail'    | 'order-list'    | 'modify-order'    | 'payment-method-detail'    | 'payment-method-list'    | 'product
...
```

---

## AdminUiExtension

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/admin-ui-extension

**Contents:**
- AdminUiExtension
- AdminUiExtension‚Äã
  - id‚Äã
  - extensionPath‚Äã
  - ngModules‚Äã
  - providers‚Äã
  - routes‚Äã
  - pathAlias‚Äã
  - exclude‚Äã
- TranslationExtension‚Äã

Defines extensions to the Admin UI application by specifying additional Angular NgModules which are compiled into the application.

See Extending the Admin UI for detailed instructions.

An optional ID for the extension module. Only used internally for generating import paths to your module. If not specified, a unique hash will be used as the id.

The path to the directory containing the extension module(s). The entire contents of this directory will be copied into the Admin UI app, including all TypeScript source files, html templates, scss style sheets etc.

One or more Angular modules which extend the default Admin UI.

Defines the paths to a file that exports an array of shared providers such as nav menu items, custom form inputs, custom detail components, action bar items, custom history entry components.

Defines routes that will be lazy-loaded at the /extensions/ route. The filePath should point to a file relative to the extensionPath which exports an array of Angular route definitions.

An optional alias for the module so it can be referenced by other UI extension modules.

By default, Angular modules declared in an AdminUiExtension do not have access to code outside the directory defined by the extensionPath. A scenario in which that can be useful though is in a monorepo codebase where a common NgModule is shared across different plugins, each defined in its own package. An example can be found below - note that the main tsconfig.json also maps the target module but using a path relative to the project's root folder. The UI module is not part of the main TypeScript build task as explained in Extending the Admin UI but having paths properly configured helps with usual IDE code editing features such as code completion and quick navigation, as well as linting.

Optional array specifying filenames or glob patterns that should be skipped when copying the directory defined by extensionPath.

Defines extensions to the Admin UI translations. Can be used as a stand-alone extension definition which only adds translations without adding new UI functionality, or as part of a full AdminUiExtension.

Optional object defining any translation files for the Admin UI. The value should be an object with the key as a 2-character ISO 639-1 language code, and the value being a glob for any relevant translation files in JSON format.

Defines extensions which copy static assets to the custom Admin UI application source asset directory.

Optional array of paths to static 

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
interface AdminUiExtension extends Partial<TranslationExtension>,        Partial<StaticAssetExtension>,        Partial<GlobalStylesExtension> {    id?: string;    extensionPath: string;    ngModules?: Array<AdminUiExtensionSharedModule | AdminUiExtensionLazyModule>;    providers?: string[];    routes?: UiExtensionRouteDefinition[];    pathAlias?: string;    exclude?: string[];}
```

Example 2 (ts):
```ts
import { NgModule } from '@angular/core';import { SharedModule } from '@vendure/admin-ui/core';import { CommonUiComponent } from './components/common-ui/common-ui.component';export { CommonUiComponent };@NgModule({ imports: [SharedModule], exports: [CommonUiComponent], declarations: [CommonUiComponent],})export class CommonSharedUiModule {}
```

Example 3 (ts):
```ts
import path from 'path';import { AdminUiExtension } from '@vendure/ui-devkit/compiler';export const uiExtensions: AdminUiExtension = {  pathAlias: '@common-ui-module',     // this is the important part  extensionPath: path.join(__dirname, 'ui'),  ngModules: [    {      type: 'shared' as const,      ngModuleFileName: 'ui-shared.module.ts',      ngModuleName: 'CommonSharedUiModule',    },  ],};
```

Example 4 (json):
```json
{  "compilerOptions": {    "baseUrl": ".",    "paths": {      "@common-ui-module/*": ["packages/common-ui-module/src/ui/*"]    }  }}
```

---

## PaymentStates

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-states

**Contents:**
- PaymentStates
- PaymentStates‚Äã

An interface to extend standard PaymentState.

**Examples:**

Example 1 (ts):
```ts
interface PaymentStates {}
```

---

## OrderCodeStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-code-strategy

**Contents:**
- OrderCodeStrategy
- OrderCodeStrategy‚Äã
  - generate‚Äã
- DefaultOrderCodeStrategy‚Äã
  - generate‚Äã

The OrderCodeStrategy determines how Order codes are generated. A custom strategy can be defined which e.g. integrates with an existing system to generate a code:

This is configured via the orderOptions.orderCodeStrategy property of your VendureConfig.

Generates the order code.

The default OrderCodeStrategy generates a random string consisting of 16 uppercase letters and numbers.

**Examples:**

Example 1 (ts):
```ts
class MyOrderCodeStrategy implements OrderCodeStrategy {  // Some imaginary service which calls out to an existing external  // order management system.  private mgmtService: ExternalOrderManagementService;  init(injector: Injector) {    this.mgmtService = injector.get(ExternalOrderManagementService);  }  async generate(ctx: RequestContext) {    const result = await this.mgmtService.getAvailableOrderParams();    return result.code;  }}
```

Example 2 (ts):
```ts
interface OrderCodeStrategy extends InjectableStrategy {    generate(ctx: RequestContext): string | Promise<string>;}
```

Example 3 (ts):
```ts
class DefaultOrderCodeStrategy implements OrderCodeStrategy {    generate(ctx: RequestContext) => string;}
```

---

## ConfigArgType

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/config-arg-type

**Contents:**
- ConfigArgType
- ConfigArgType‚Äã

Certain entities (those which implement ConfigurableOperationDef) allow arbitrary configuration arguments to be specified which can then be set in the admin-ui and used in the business logic of the app. These are the valid data types of such arguments. The data type influences:

**Examples:**

Example 1 (ts):
```ts
type ConfigArgType = 'string' | 'int' | 'float' | 'boolean' | 'datetime' | 'ID'
```

---

## OrderHistoryEntry

**URL:** https://docs.vendure.io/reference/typescript-api/entities/order-history-entry

**Contents:**
- OrderHistoryEntry
- OrderHistoryEntry‚Äã
  - constructor‚Äã
  - order‚Äã

Represents an event in the history of a particular Order.

**Examples:**

Example 1 (ts):
```ts
class OrderHistoryEntry extends HistoryEntry {    constructor(input: DeepPartial<OrderHistoryEntry>)    @Index()    @ManyToOne(type => Order, { onDelete: 'CASCADE' })    order: Order;}
```

---

## BullMQJobQueuePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/job-queue-plugin/bull-mqjob-queue-plugin/

**Contents:**
- BullMQJobQueuePlugin
- BullMQJobQueuePlugin‚Äã
- Advantages over the DefaultJobQueuePlugin‚Äã
- Installation‚Äã
  - Running Redis locally‚Äã
- Concurrency‚Äã
- Removing old jobs‚Äã
- Job Priority‚Äã
- Setting Redis Prefix‚Äã
  - options‚Äã

This plugin is a drop-in replacement of the DefaultJobQueuePlugin, which implements a push-based job queue strategy built on top of the popular BullMQ library.

The advantage of this approach is that jobs are stored in Redis rather than in the database. For more complex applications with many job queues and/or multiple worker instances, this can massively reduce the load on the DB server. The reason for this is that the DefaultJobQueuePlugin uses polling to check for new jobs. By default it will poll every 200ms. A typical Vendure instance uses at least 3 queues (handling emails, collections, search index), so even with a single worker instance this results in 15 queries per second to the DB constantly. Adding more custom queues and multiple worker instances can easily result in 50 or 100 queries per second. At this point performance may be impacted.

Using this plugin, no polling is needed, as BullMQ will push jobs to the worker(s) as and when they are added to the queue. This results in significantly more scalable performance characteristics, as well as lower latency in processing jobs.

Note: To use this plugin, you need to manually install the bullmq package:

Note: The v1.x version of this plugin is designed to work with bullmq v1.x, etc.

To develop with this plugin, you'll need an instance of Redis to connect to. Here's a docker-compose config that will set up Redis as well as Redis Commander, which is a web-based UI for interacting with Redis:

The default concurrency of a single worker is 3, i.e. up to 3 jobs will be processed at the same time. You can change the concurrency in the workerOptions passed to the init() method:

By default, BullMQ will keep completed jobs in the completed set and failed jobs in the failed set. Over time, these sets can grow very large. Since Vendure v2.1, the default behaviour is to remove jobs from these sets after 30 days or after a maximum of 5,000 completed or failed jobs.

This can be configured using the removeOnComplete and removeOnFail options:

The count option specifies the maximum number of jobs to keep in the set, while the age option specifies the maximum age of a job in seconds. If both options are specified, then the jobs kept will be the ones that satisfy both properties.

Some jobs are more important than others. For example, sending out a timely email after a customer places an order is probably more important than a routine data import task. Sometimes you can get the situation where lower-priority j

*[Content truncated]*

**Examples:**

Example 1 (shell):
```shell
npm install bullmq@^5.4.2
```

Example 2 (ts):
```ts
import { BullMQJobQueuePlugin } from '@vendure/job-queue-plugin/package/bullmq';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    // DefaultJobQueuePlugin should be removed from the plugins array    BullMQJobQueuePlugin.init({      connection: {        port: 6379      }    }),  ],};
```

Example 3 (yaml):
```yaml
version: "3"services:  redis:    image: redis:7.4    hostname: redis    container_name: redis    ports:      - "6379:6379"  redis-commander:    container_name: redis-commander    hostname: redis-commander    image: rediscommander/redis-commander:latest    environment:      - REDIS_HOSTS=local:redis:6379    ports:      - "8085:8081"
```

Example 4 (ts):
```ts
const config: VendureConfig = {  plugins: [    BullMQJobQueuePlugin.init({      workerOptions: {        concurrency: 10,      },    }),  ],};
```

---

## CreateErrorResultGuard

**URL:** https://docs.vendure.io/reference/typescript-api/testing/create-error-result-guard

**Contents:**
- CreateErrorResultGuard
- createErrorResultGuard‚Äã
  - testFn‚Äã

Convenience method for creating an ErrorResultGuard. Takes a predicate function which tests whether the input is considered successful (true) or an error result (false).

Note that the resulting variable must still be type annotated in order for the TypeScript type inference to work as expected:

**Examples:**

Example 1 (ts):
```ts
const orderResultGuard: ErrorResultGuard<AddItemToOrderResult>  = createErrorResultGuard(order => !!order.lines);
```

Example 2 (ts):
```ts
function createErrorResultGuard<T>(testFn: (input: T) => boolean): ErrorResultGuard<T>
```

---

## StockDisplayStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/stock-display-strategy

**Contents:**
- StockDisplayStrategy
- StockDisplayStrategy‚Äã
  - getStockLevel‚Äã

Defines how the ProductVariant.stockLevel value is obtained. It is usually not desirable to directly expose stock levels over a public API, as this could be considered a leak of sensitive information. However, the storefront will usually want to display some indication of whether a given ProductVariant is in stock.

This is configured via the catalogOptions.stockDisplayStrategy property of your VendureConfig.

Returns a string representing the stock level, which will be used directly in the GraphQL ProductVariant.stockLevel field.

**Examples:**

Example 1 (ts):
```ts
interface StockDisplayStrategy extends InjectableStrategy {    getStockLevel(        ctx: RequestContext,        productVariant: ProductVariant,        saleableStockLevel: number,    ): string | Promise<string>;}
```

---

## CollectionService

**URL:** https://docs.vendure.io/reference/typescript-api/services/collection-service

**Contents:**
- CollectionService
- CollectionService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findByIds‚Äã
  - findOneBySlug‚Äã
  - getAvailableFilters‚Äã
  - getParent‚Äã
  - getChildren‚Äã

Contains methods relating to Collection entities.

Returns all configured CollectionFilters, as specified by the CatalogOptions.

Returns all child Collections of the Collection with the given id.

Returns an array of name/id pairs representing all ancestor Collections up to the Root Collection.

Returns all Collections which are associated with the given Product ID.

Returns the descendants of a Collection as a flat array. The depth of the traversal can be limited with the maxDepth argument. So to get only the immediate children, set maxDepth = 1.

Gets the ancestors of a given collection. Note that since ProductCategories are implemented as an adjacency list, this method will produce more queries the deeper the collection is in the tree.

Moves a Collection by specifying the parent Collection ID, and an index representing the order amongst its siblings.

By default, whenever product data is updated (as determined by subscribing to the ProductEvent and ProductVariantEvent events), the CollectionFilters are re-applied to all Collections.

In certain scenarios, such as when a large number of products are updated at once due to bulk data import, this can be inefficient. In such cases, you can disable this behaviour for the duration of the import process by calling this method with false, and then re-enable it by calling with true.

Afterward, you can call the triggerApplyFiltersJob method to manually re-apply the filters.

Triggers the creation of an apply-collection-filters job which will cause the contents of the specified collections to be re-evaluated against their filters.

If no collectionIds option is passed, then all collections will be re-evaluated.

Assigns Collections to the specified Channel

Remove Collections from the specified Channel

**Examples:**

Example 1 (ts):
```ts
class CollectionService implements OnModuleInit {    constructor(connection: TransactionalConnection, channelService: ChannelService, assetService: AssetService, listQueryBuilder: ListQueryBuilder, translatableSaver: TranslatableSaver, eventBus: EventBus, jobQueueService: JobQueueService, configService: ConfigService, slugValidator: SlugValidator, configArgService: ConfigArgService, customFieldRelationService: CustomFieldRelationService, translator: TranslatorService, roleService: RoleService, requestContextService: RequestContextService)    findAll(ctx: RequestContext, options?: ListQueryOpti
...
```

---

## AssetService

**URL:** https://docs.vendure.io/reference/typescript-api/services/asset-service

**Contents:**
- AssetService
- AssetService‚Äã
  - constructor‚Äã
  - findOne‚Äã
  - findAll‚Äã
  - getFeaturedAsset‚Äã
  - getEntityAssets‚Äã
  - updateFeaturedAsset‚Äã
  - updateEntityAssets‚Äã
  - create‚Äã

Contains methods relating to Asset entities.

Returns the Assets of an entity which has a well-ordered list of Assets, such as Product, ProductVariant or Collection.

Updates the assets / featuredAsset of an entity, ensuring that only valid assetIds are used.

Create an Asset based on a file uploaded via the GraphQL API. The file should be uploaded using the GraphQL multipart request specification, e.g. using the apollo-upload-client npm package.

See the Uploading Files docs for an example of usage.

Updates the name, focalPoint, tags & custom fields of an Asset.

Deletes an Asset after performing checks to ensure that the Asset is not currently in use by a Product, ProductVariant or Collection.

Create an Asset from a file stream, for example to create an Asset during data import.

Certain entities (Product, ProductVariant, Collection) use this interface to model a featured asset and then a list of assets with a defined order.

Used when updating entities which implement EntityWithAssets.

**Examples:**

Example 1 (ts):
```ts
class AssetService {    constructor(connection: TransactionalConnection, configService: ConfigService, listQueryBuilder: ListQueryBuilder, eventBus: EventBus, tagService: TagService, channelService: ChannelService, roleService: RoleService, customFieldRelationService: CustomFieldRelationService)    findOne(ctx: RequestContext, id: ID, relations?: RelationPaths<Asset>) => Promise<Asset | undefined>;    findAll(ctx: RequestContext, options?: AssetListOptions, relations?: RelationPaths<Asset>) => Promise<PaginatedList<Asset>>;    getFeaturedAsset(ctx: RequestContext, entity: T) => Promise<Asset |
...
```

Example 2 (ts):
```ts
interface EntityWithAssets extends VendureEntity {    featuredAsset: Asset | null;    assets: OrderableAsset[];}
```

Example 3 (ts):
```ts
interface EntityAssetInput {    assetIds?: ID[] | null;    featuredAssetId?: ID | null;}
```

---

## NoopSessionCacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/noop-session-cache-strategy

**Contents:**
- NoopSessionCacheStrategy
- NoopSessionCacheStrategy‚Äã
  - clear‚Äã
  - delete‚Äã
  - get‚Äã
  - set‚Äã

A cache that doesn't cache. The cache lookup will miss every time so the session will always be taken from the database.

**Examples:**

Example 1 (ts):
```ts
class NoopSessionCacheStrategy implements SessionCacheStrategy {    clear() => ;    delete(sessionToken: string) => ;    get(sessionToken: string) => ;    set(session: CachedSession) => ;}
```

---

## Health Check

**URL:** https://docs.vendure.io/reference/typescript-api/health-check/

**Contents:**
- Health Check
- üìÑÔ∏è HealthCheckRegistryService
- üìÑÔ∏è HealthCheckStrategy
- üìÑÔ∏è HttpHealthCheckStrategy
- üìÑÔ∏è TypeORMHealthCheckStrategy

HealthCheckRegistryService

HttpHealthCheckStrategy

TypeORMHealthCheckStrategy

---

## SchedulerOptions

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/scheduler-options

**Contents:**
- SchedulerOptions
- SchedulerOptions‚Äã
  - schedulerStrategy‚Äã
  - tasks‚Äã
  - runTasksInWorkerOnly‚Äã

Options related to scheduled tasks..

The strategy used to execute scheduled tasks. If you are using the DefaultSchedulerPlugin (which is recommended) then this will be set to the DefaultSchedulerStrategy.

The tasks to be executed.

Whether to run tasks only in the worker process. Generally this should be left as true, since tasks may involve expensive operations that should not be allowed to interfere with the server responsiveness.

This option mainly exists for testing purposes.

**Examples:**

Example 1 (ts):
```ts
interface SchedulerOptions {    schedulerStrategy?: SchedulerStrategy;    tasks?: ScheduledTask[];    runTasksInWorkerOnly?: boolean;}
```

---

## ModalService

**URL:** https://docs.vendure.io/reference/admin-ui-api/services/modal-service

**Contents:**
- ModalService
- ModalService‚Äã
  - constructor‚Äã
  - fromComponent‚Äã
  - dialog‚Äã
- Dialog‚Äã
  - resolveWith‚Äã
- DialogConfig‚Äã
  - title‚Äã
  - body‚Äã

This service is responsible for instantiating a ModalDialog component and embedding the specified component within.

Create a modal from a component. The component must implement the Dialog interface. Additionally, the component should include templates for the title and the buttons to be displayed in the modal dialog. See example:

Displays a modal dialog with the provided title, body and buttons.

Any component intended to be used with the ModalService.fromComponent() method must implement this interface.

Function to be invoked in order to close the dialog when the action is complete. The Observable returned from the .fromComponent() method will emit the value passed to this method and then complete.

Configures a generic modal dialog.

Options to configure the behaviour of the modal.

Sets the width of the dialog

Sets the vertical alignment of the dialog

When true, the "x" icon is shown and clicking it or the mask will close the dialog

Values to be passed directly to the component being instantiated inside the dialog.

**Examples:**

Example 1 (ts):
```ts
class ModalService {    constructor(overlayHostService: OverlayHostService)    fromComponent(component: Type<T> & Type<Dialog<R>>, options?: ModalOptions<T>) => Observable<R | undefined>;    dialog(config: DialogConfig<T>) => Observable<T | undefined>;}
```

Example 2 (ts):
```ts
class MyDialog implements Dialog { resolveWith: (result?: any) => void; okay() {   doSomeWork().subscribe(result => {     this.resolveWith(result);   }) } cancel() {   this.resolveWith(false); }}
```

Example 3 (html):
```html
<ng-template vdrDialogTitle>Title of the modal</ng-template><p>  My Content</p><ng-template vdrDialogButtons>  <button type="button"          class="btn"          (click)="cancel()">Cancel</button>  <button type="button"          class="btn btn-primary"          (click)="okay()">Okay</button></ng-template>
```

Example 4 (ts):
```ts
interface Dialog<R = any> {    resolveWith: (result?: R) => void;}
```

---

## DataService

**URL:** https://docs.vendure.io/reference/admin-ui-api/services/data-service

**Contents:**
- DataService
- DataService‚Äã
  - query‚Äã
  - mutate‚Äã
- QueryResult‚Äã
  - constructor‚Äã
  - refetchOnChannelChange‚Äã
  - refetchOnCustomFieldsChange‚Äã
  - single$‚Äã
  - stream$‚Äã

Used to interact with the Admin API via GraphQL queries. Internally this service uses the Apollo Client, which means it maintains a normalized entity cache. For this reason, it is advisable to always select the id field of any entity, which will allow the returned data to be effectively cached.

Perform a GraphQL query. Returns a QueryResult which allows further control over they type of result returned, e.g. stream of values, single value etc.

Perform a GraphQL mutation.

This class wraps the Apollo Angular QueryRef object and exposes some getters for convenience.

Re-fetch this query whenever the active Channel changes.

Re-fetch this query whenever the custom fields change, updating the query to include the specified custom fields.

Returns an Observable which emits a single result and then completes.

Returns an Observable which emits until unsubscribed.

Returns a single-result Observable after applying the map function.

Returns a multiple-result Observable after applying the map function.

Signals to the internal Observable subscriptions that they should complete.

**Examples:**

Example 1 (ts):
```ts
class DataService {    query(query: DocumentNode | TypedDocumentNode<T, V>, variables?: V, fetchPolicy: WatchQueryFetchPolicy = 'cache-and-network', options: ExtendedQueryOptions = {}) => QueryResult<T, V>;    mutate(mutation: DocumentNode | TypedDocumentNode<T, V>, variables?: V, update?: MutationUpdaterFunction<T, V, any, any>, options: ExtendedQueryOptions = {}) => Observable<T>;}
```

Example 2 (ts):
```ts
const result$ = this.dataService.query(gql`  query MyQuery($id: ID!) {    product(id: $id) {      id      name      slug    }  },  { id: 123 },).mapSingle(data => data.product);
```

Example 3 (ts):
```ts
const result$ = this.dataService.mutate(gql`  mutation MyMutation($Codegen.UpdateEntityInput!) {    updateEntity(input: $input) {      id      name    }  },  { Codegen.updateEntityInput },);
```

Example 4 (ts):
```ts
class QueryResult<T, V extends Record<string, any> = Record<string, any>> {    constructor(queryRef: QueryRef<T, V>, apollo: Apollo, customFieldMap: Map<string, CustomFieldConfig[]>)    refetchOnChannelChange() => QueryResult<T, V>;    refetchOnCustomFieldsChange(customFieldsToInclude$: Observable<string[]>) => QueryResult<T, V>;    single$: Observable<T>    stream$: Observable<T>    ref: QueryRef<T, V>    mapSingle(mapFn: (item: T) => R) => Observable<R>;    mapStream(mapFn: (item: T) => R) => Observable<R>;    destroy() => ;}
```

---

## BraintreePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/payments-plugin/braintree-plugin/

**Contents:**
- BraintreePlugin
- BraintreePlugin‚Äã
- Requirements‚Äã
- Setup‚Äã
- Storefront usage‚Äã
- Storing payment details (vaulting)‚Äã
  - options‚Äã
  - init‚Äã
- BraintreePluginOptions‚Äã
  - environment‚Äã

This plugin enables payments to be processed by Braintree, a popular payment provider.

The plugin is designed to work with the Braintree drop-in UI. This is a library provided by Braintree which will handle the payment UI for you. You can install it in your storefront project with:

The high-level workflow is:

Here is an example of how your storefront code will look. Note that this example is attempting to be framework-agnostic, so you'll need to adapt it to fit to your framework of choice.

Braintree has a vault feature which allows the secure storage of customer's payment information. Using the vault allows you to offer a faster checkout for repeat customers without needing to worry about how to securely store payment details.

To enable this feature, set the storeCustomersInBraintree option to true.

Since v1.8, it is possible to override vaulting on a per-payment basis by passing includeCustomerId: false to the generateBraintreeClientToken mutation:

as well as in the metadata of the addPaymentToOrder mutation:

Options for the Braintree plugin.

The Braintree environment being targeted, e.g. sandbox or production.

If set to true, a Customer object will be created in Braintree, which allows the secure storage ("vaulting") of previously-used payment methods. This is done by adding a custom field to the Customer entity to store the Braintree customer ID, so switching this on will require a database migration / synchronization.

Since v1.8, it is possible to override vaulting on a per-payment basis by passing includeCustomerId: false to the generateBraintreeClientToken mutation.

Allows you to configure exactly what information from the Braintree Transaction object (which is returned by the transaction.sale() method of the SDK) should be persisted to the resulting Payment entity metadata.

By default, the built-in extraction function will return a metadata object that looks like this:

**Examples:**

Example 1 (shell):
```shell
yarn add @vendure/payments-plugin braintreeyarn add -D @types/braintree
```

Example 2 (shell):
```shell
npm install @vendure/payments-plugin braintreenpm install -D @types/braintree
```

Example 3 (ts):
```ts
import { BraintreePlugin } from '@vendure/payments-plugin/package/braintree';import { Environment } from 'braintree';// ...plugins: [  BraintreePlugin.init({    environment: Environment.Sandbox,    // This allows saving customer payment    // methods with Braintree (see "vaulting"    // section below for details)    storeCustomersInBraintree: true,  }),]
```

Example 4 (shell):
```shell
yarn add braintree-web-drop-in# ornpm install braintree-web-drop-in
```

---

## DefaultJobQueuePlugin

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/default-job-queue-plugin/

**Contents:**
- DefaultJobQueuePlugin
- DefaultJobQueuePlugin‚Äã
- Configuration‚Äã
  - pollInterval‚Äã
  - concurrency‚Äã
  - backoffStrategy‚Äã
  - Removing old jobs‚Äã
  - init‚Äã
- cleanJobsTask‚Äã
- DefaultJobQueueOptions‚Äã

A plugin which configures Vendure to use the SQL database to persist the JobQueue jobs using the SqlJobQueueStrategy. If you add this plugin to an existing Vendure installation, you'll need to run a database migration, since this plugin will add a new "job_record" table to the database.

It is possible to configure the behaviour of the SqlJobQueueStrategy by passing options to the static init() function:

The interval in ms between polling for new jobs. The default is 200ms. Using a longer interval reduces load on the database but results in a slight delay in processing jobs. For more control, it is possible to supply a function which can specify a pollInterval based on the queue name:

The number of jobs to process concurrently per worker. Defaults to 1.

Defines the backoff strategy used when retrying failed jobs. In other words, if a job fails and is configured to be re-tried, how long should we wait before the next attempt?

By default, a job will be retried as soon as possible, but in some cases this is not desirable. For example, a job may interact with an unreliable 3rd-party API which is sensitive to too many requests. In this case, an exponential backoff may be used which progressively increases the delay between each subsequent retry.

Since v3.3, the job queue will automatically remove old jobs from the database. This is done by a scheduled task which runs every 2 hours by default. The number of jobs to keep in the database can be configured using the keepJobsCount option. The default is 1000.

A ScheduledTask that cleans up old jobs from the database when using the DefaultJobQueuePlugin. You can configure the settings & schedule of the task via the DefaultJobQueuePlugin options.

Configuration options for the DefaultJobQueuePlugin. These values get passed into the SqlJobQueueStrategy.

The interval in ms between polling the database for new jobs. If many job queues are active, the polling may cause undue load on the database, in which case this value should be increased to e.g. 1000.

How many jobs from a given queue to process concurrently.

The strategy used to decide how long to wait before retrying a failed job.

When a job is added to the JobQueue using JobQueue.add(), the calling code may specify the number of retries in case of failure. This option allows you to override that number and specify your own number of retries based on the job being added.

If set to true, the database will be used to store buffered jobs. This is recommended f

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { DefaultJobQueuePlugin, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    DefaultJobQueuePlugin,  ],};
```

Example 2 (ts):
```ts
export const config: VendureConfig = {  plugins: [    DefaultJobQueuePlugin.init({      pollInterval: queueName => {        if (queueName === 'cart-recovery-email') {          // This queue does not need to be polled so frequently,          // so we set a longer interval in order to reduce load          // on the database.          return 10000;        }        return 200;      },    }),  ],};
```

Example 3 (ts):
```ts
export const config: VendureConfig = {  plugins: [    DefaultJobQueuePlugin.init({      pollInterval: 5000,      concurrency: 2      backoffStrategy: (queueName, attemptsMade, job) => {        if (queueName === 'transcode-video') {          // exponential backoff example          return (attemptsMade ** 2) * 1000;        }        // A default delay for all other queues        return 1000;      },      setRetries: (queueName, job) => {        if (queueName === 'send-email') {          // Override the default number of retries          // for the 'send-email' job because we have          // a ve
...
```

Example 4 (ts):
```ts
export const config: VendureConfig = {  plugins: [    DefaultJobQueuePlugin.init({      // The number of completed/failed/cancelled      // jobs to keep in the database. The default is 1000.      keepJobsCount: 100,      // The interval at which to run the clean-up task.      // This can be a standard cron expression or a function      // that returns a cron expression. The default is every 2 hours.      cleanJobsSchedule: cron => cron.every(5).hours(),    }),  ],};
```

---

## AssetGallery

**URL:** https://docs.vendure.io/reference/dashboard/components/asset-gallery

**Contents:**
- AssetGallery
- AssetGallery‚Äã
  - props‚Äã
- AssetGalleryProps‚Äã
  - onSelect‚Äã
  - selectable‚Äã
  - multiSelect‚Äã
  - initialSelectedAssets‚Äã
  - pageSize‚Äã
  - fixedHeight‚Äã

A component for displaying a gallery of assets.

Props for the AssetGallery component.

Defines whether multiple assets can be selected.

If set to 'auto', the asset selection will be toggled when the user clicks on an asset. If set to 'manual', multiple selection will occur only if the user holds down the control/cmd key.

The initial assets that should be selected.

The number of assets to display per page.

Whether the gallery should have a fixed height.

Whether the gallery should show a header.

The class name to apply to the gallery.

The function to call when files are dropped.

The bulk actions to display in the gallery.

Whether the gallery should display bulk actions.

The function to call when the page size changes.

**Examples:**

Example 1 (tsx):
```tsx
<AssetGallery  onSelect={handleAssetSelect}  multiSelect="manual"  initialSelectedAssets={initialSelectedAssets}  fixedHeight={false}  displayBulkActions={false}  />
```

Example 2 (ts):
```ts
function AssetGallery(props: AssetGalleryProps): void
```

Example 3 (ts):
```ts
interface AssetGalleryProps {    onSelect?: (assets: Asset[]) => void;    selectable?: boolean;    multiSelect?: 'auto' | 'manual';    initialSelectedAssets?: Asset[];    pageSize?: number;    fixedHeight?: boolean;    showHeader?: boolean;    className?: string;    onFilesDropped?: (files: File[]) => void;    bulkActions?: AssetBulkAction[];    displayBulkActions?: boolean;    onPageSizeChange?: (pageSize: number) => void;}
```

---

## RegisterPageTab

**URL:** https://docs.vendure.io/reference/admin-ui-api/tabs/register-page-tab/

**Contents:**
- RegisterPageTab
- registerPageTab‚Äã
  - config‚Äã

Add a tab to an existing list or detail page.

**Examples:**

Example 1 (ts):
```ts
import { registerPageTab } from '@vendure/admin-ui/core';import { DeletedProductListComponent } from './components/deleted-product-list/deleted-product-list.component';export default [    registerPageTab({        location: 'product-list',        tab: 'Deleted Products',        route: 'deleted',        component: DeletedProductListComponent,    }),];
```

Example 2 (ts):
```ts
function registerPageTab(config: PageTabConfig): void
```

---

## Payments Plugin

**URL:** https://docs.vendure.io/reference/core-plugins/payments-plugin/

**Contents:**
- Payments Plugin
- üìÑÔ∏è BraintreePlugin
- üìÑÔ∏è Payments Plugin
- üìÑÔ∏è MolliePlugin
- üìÑÔ∏è StripePlugin

---

## FulfillmentProcess

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/fulfillment-process

**Contents:**
- FulfillmentProcess
- defaultFulfillmentProcess‚Äã
- FulfillmentProcess‚Äã
  - transitions‚Äã
  - onTransitionStart‚Äã
  - onTransitionEnd‚Äã
  - onTransitionError‚Äã

The default FulfillmentProcess. This process includes the following actions:

A FulfillmentProcess is used to define the way the fulfillment process works as in: what states a Fulfillment can be in, and how it may transition from one state to another. Using the onTransitionStart() hook, a FulfillmentProcess can perform checks before allowing a state transition to occur, and the onTransitionEnd() hook allows logic to be executed after a state change.

For detailed description of the interface members, see the StateMachineConfig docs.

**Examples:**

Example 1 (ts):
```ts
interface FulfillmentProcess<State extends keyof CustomFulfillmentStates | string> extends InjectableStrategy {    transitions?: Transitions<State, State | FulfillmentState> &        Partial<Transitions<FulfillmentState | State>>;    onTransitionStart?: OnTransitionStartFn<State | FulfillmentState, FulfillmentTransitionData>;    onTransitionEnd?: OnTransitionEndFn<State | FulfillmentState, FulfillmentTransitionData>;    onTransitionError?: OnTransitionErrorFn<State | FulfillmentState>;}
```

---

## Surcharge

**URL:** https://docs.vendure.io/reference/typescript-api/entities/surcharge

**Contents:**
- Surcharge
- Surcharge‚Äã
  - constructor‚Äã
  - description‚Äã
  - listPrice‚Äã
  - listPriceIncludesTax‚Äã
  - sku‚Äã
  - taxLines‚Äã
  - order‚Äã
  - orderModification‚Äã

A Surcharge represents an arbitrary extra item on an Order which is not a ProductVariant. It can be used to e.g. represent payment-related surcharges.

**Examples:**

Example 1 (ts):
```ts
class Surcharge extends VendureEntity {    constructor(input?: DeepPartial<Surcharge>)    @Column()    description: string;    @Money()    listPrice: number;    @Column()    listPriceIncludesTax: boolean;    @Column()    sku: string;    @Column('simple-json')    taxLines: TaxLine[];    @Index()    @ManyToOne(type => Order, order => order.surcharges, { onDelete: 'CASCADE' })    order: Order;    @Index()    @ManyToOne(type => OrderModification, orderModification => orderModification.surcharges)    orderModification: OrderModification;    price: number    priceWithTax: number    taxRate: number}
```

---

## UiExtensionCompilerProcessArgument

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/ui-extension-compiler-process-argument

**Contents:**
- UiExtensionCompilerProcessArgument
- UiExtensionCompilerProcessArgument‚Äã

Argument to configure process (watch or compile)

**Examples:**

Example 1 (ts):
```ts
type UiExtensionCompilerProcessArgument = string | [string, any]
```

---

## Order

**URL:** https://docs.vendure.io/reference/typescript-api/entities/order

**Contents:**
- Order
- Order‚Äã
  - constructor‚Äã
  - type‚Äã
  - sellerOrders‚Äã
  - aggregateOrder‚Äã
  - aggregateOrderId‚Äã
  - code‚Äã
  - state‚Äã
  - active‚Äã

An Order is created whenever a Customer adds an item to the cart. It contains all the information required to fulfill an order: which ProductVariants in what quantities; the shipping address and price; any applicable promotions; payments etc.

An Order exists in a well-defined state according to the OrderState type. A state machine is used to govern the transition from one state to another.

Extends: VendureEntity

Implements: ChannelAware, HasCustomFields

A unique code for the Order, generated according to the OrderCodeStrategy. This should be used as an order reference for Customers, rather than the Order's id.

Whether the Order is considered "active", meaning that the Customer can still make changes to it and has not yet completed the checkout process. This is governed by the OrderPlacedStrategy.

The date & time that the Order was placed, i.e. the Customer completed the checkout and the Order is no longer "active". This is governed by the OrderPlacedStrategy.

Surcharges are arbitrary modifications to the Order total which are neither ProductVariants nor discounts resulting from applied Promotions. For example, one-off discounts based on customer interaction, or surcharges based on payment methods.

An array of all coupon codes applied to the Order.

Promotions applied to the order. Only gets populated after the payment process has completed, i.e. the Order is no longer active.

The subTotal is the total of all OrderLines in the Order. This figure also includes any Order-level discounts which have been prorated (proportionally distributed) amongst the OrderItems. To get a total of all OrderLines which does not account for prorated discounts, use the sum of OrderLine's discountedLinePrice values.

Same as subTotal, but inclusive of tax.

The shipping charges applied to this order.

The total of all the shippingLines.

Equal to subTotal plus shipping

The final payable amount. Equal to subTotalWithTax plus shippingWithTax.

A summary of the taxes being applied to this Order.

**Examples:**

Example 1 (ts):
```ts
class Order extends VendureEntity implements ChannelAware, HasCustomFields {    constructor(input?: DeepPartial<Order>)    @Column('varchar', { default: OrderType.Regular })    type: OrderType;    @OneToMany(type => Order, sellerOrder => sellerOrder.aggregateOrder)    sellerOrders: Order[];    @Index()    @ManyToOne(type => Order, aggregateOrder => aggregateOrder.sellerOrders)    aggregateOrder?: Order;    @EntityId({ nullable: true })    aggregateOrderId?: ID;    @Column()    @Index({ unique: true })    code: string;    @Column('varchar') state: OrderState;    @Column({ default: true })    ac
...
```

---

## ProductVariantPriceSelectionStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/product-variant-price-selection-strategy

**Contents:**
- ProductVariantPriceSelectionStrategy
- ProductVariantPriceSelectionStrategy‚Äã
  - selectPrice‚Äã
- DefaultProductVariantPriceSelectionStrategy‚Äã
  - selectPrice‚Äã

The strategy for selecting the price for a ProductVariant in a given Channel.

This is configured via the catalogOptions.productVariantPriceSelectionStrategy property of your VendureConfig.

The default strategy for selecting the price for a ProductVariant in a given Channel. It first filters all available prices to those which are in the current Channel, and then selects the first price which matches the current currency.

**Examples:**

Example 1 (ts):
```ts
interface ProductVariantPriceSelectionStrategy extends InjectableStrategy {    selectPrice(        ctx: RequestContext,        prices: ProductVariantPrice[],    ): ProductVariantPrice | undefined | Promise<ProductVariantPrice | undefined>;}
```

Example 2 (ts):
```ts
class DefaultProductVariantPriceSelectionStrategy implements ProductVariantPriceSelectionStrategy {    selectPrice(ctx: RequestContext, prices: ProductVariantPrice[]) => ;}
```

---

## SuperadminCredentials

**URL:** https://docs.vendure.io/reference/typescript-api/auth/superadmin-credentials

**Contents:**
- SuperadminCredentials
- SuperadminCredentials‚Äã
  - identifier‚Äã
  - password‚Äã

These credentials will be used to create the Superadmin user & administrator when Vendure first bootstraps.

The identifier to be used to create a superadmin account

The password to be used to create a superadmin account

**Examples:**

Example 1 (ts):
```ts
interface SuperadminCredentials {    identifier: string;    password: string;}
```

---

## AlertContext

**URL:** https://docs.vendure.io/reference/admin-ui-api/alerts/alert-context

**Contents:**
- AlertContext
- AlertContext‚Äã
  - injector‚Äã
  - dataService‚Äã
  - notificationService‚Äã
  - modalService‚Äã

The context object which is passed to the check, isAlert, label and action functions of an AlertConfig object.

The Angular Injector which can be used to get instances of services and other providers available in the application.

The DataService, which provides methods for querying the server-side data.

The NotificationService, which provides methods for displaying notifications to the user.

The ModalService, which provides methods for opening modal dialogs.

**Examples:**

Example 1 (ts):
```ts
interface AlertContext {    injector: Injector;    dataService: DataService;    notificationService: NotificationService;    modalService: ModalService;}
```

---

## HistoryEntryConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-history-entry-components/history-entry-config

**Contents:**
- HistoryEntryConfig
- HistoryEntryConfig‚Äã
  - type‚Äã
  - component‚Äã

Configuration for registering a custom HistoryEntryComponent.

The type should correspond to the custom HistoryEntryType string.

The component to be rendered for this history entry type.

**Examples:**

Example 1 (ts):
```ts
interface HistoryEntryConfig {    type: string;    component: Type<HistoryEntryComponent>;}
```

---

## Populator

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/populator

**Contents:**
- Populator
- Populator‚Äã
  - populateInitialData‚Äã
  - populateCollections‚Äã

Responsible for populating the database with InitialData, i.e. non-product data such as countries, tax rates, shipping methods, payment methods & roles.

Should be run before populating the products, so that there are TaxRates by which product prices can be set. If the channel argument is set, then any ChannelAwareentities will be assigned to that Channel.

Should be run after the products have been populated, otherwise the expected FacetValues will not yet exist.

**Examples:**

Example 1 (ts):
```ts
class Populator {    populateInitialData(data: InitialData, channel?: Channel) => ;    populateCollections(data: InitialData, channel?: Channel) => ;}
```

---

## MergeConfig

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/merge-config

**Contents:**
- MergeConfig
- mergeConfig‚Äã
  - target‚Äã
  - source‚Äã
  - depth‚Äã

Performs a deep merge of two VendureConfig objects. Unlike Object.assign() the target object is not mutated, instead the function returns a new object which is the result of deeply merging the values of source into target.

Arrays do not get merged, they are treated as a single value that will be replaced. So if merging the plugins array, you must explicitly concatenate the array.

**Examples:**

Example 1 (ts):
```ts
const result = mergeConfig(defaultConfig, {  assetOptions: {    uploadMaxFileSize: 5000,  },  plugins: [    ...defaultConfig.plugins,    MyPlugin,  ]};
```

Example 2 (ts):
```ts
function mergeConfig<T extends VendureConfig>(target: T, source: PartialVendureConfig, depth:  = 0): T
```

---

## EntityId Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/entity-id-decorator

**Contents:**
- EntityId Decorator
- EntityId‚Äã
  - options‚Äã

Decorates a property which points to another entity by ID. This custom decorator is needed because we do not know the data type of the ID column until runtime, when we have access to the configured EntityIdStrategy.

**Examples:**

Example 1 (ts):
```ts
function EntityId(options?: IdColumnOptions): void
```

---

## DefaultAssetNamingStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/assets/default-asset-naming-strategy

**Contents:**
- DefaultAssetNamingStrategy
- DefaultAssetNamingStrategy‚Äã
  - generateSourceFileName‚Äã
  - generatePreviewFileName‚Äã

The default strategy normalizes the file names to remove unwanted characters and in the case of conflicts, increments a counter suffix.

**Examples:**

Example 1 (ts):
```ts
class DefaultAssetNamingStrategy implements AssetNamingStrategy {    generateSourceFileName(ctx: RequestContext, originalFileName: string, conflictFileName?: string) => string;    generatePreviewFileName(ctx: RequestContext, sourceFileName: string, conflictFileName?: string) => string;}
```

---

## AddNavMenuItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/nav-menu/add-nav-menu-item/

**Contents:**
- AddNavMenuItem
- addNavMenuItem‚Äã
  - config‚Äã
  - sectionId‚Äã
  - before‚Äã

Add a menu item to an existing section specified by sectionId. The id of the section can be found by inspecting the DOM and finding the data-section-id attribute. Providing the before argument will move the item before any existing item with the specified id. If omitted (or if the name is not found) the item will be appended to the end of the section.

This should be used in the NgModule providers array of your ui extension module.

**Examples:**

Example 1 (ts):
```ts
import { addNavMenuItem } from '@vendure/admin-ui/core';export default [    addNavMenuItem({        id: 'reviews',        label: 'Product Reviews',        routerLink: ['/extensions/reviews'],        icon: 'star',    },    'marketing'),];
```

Example 2 (ts):
```ts
function addNavMenuItem(config: NavMenuItem, sectionId: string, before?: string): void
```

---

## ShippingEligibilityCheckerConfig

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-eligibility-checker-config

**Contents:**
- ShippingEligibilityCheckerConfig
- ShippingEligibilityCheckerConfig‚Äã
  - check‚Äã
  - shouldRunCheck‚Äã

Configuration passed into the constructor of a ShippingEligibilityChecker to configure its behavior.

**Examples:**

Example 1 (ts):
```ts
interface ShippingEligibilityCheckerConfig<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {    check: CheckShippingEligibilityCheckerFn<T>;    shouldRunCheck?: ShouldRunCheckFn<T>;}
```

---

## TypeORMHealthCheckStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/health-check/type-ormhealth-check-strategy

**Contents:**
- TypeORMHealthCheckStrategy
- TypeORMHealthCheckStrategy‚Äã
  - constructor‚Äã
  - init‚Äã
  - getHealthIndicator‚Äã

A HealthCheckStrategy used to check the health of the database. This health check is included by default, but can be customized by explicitly adding it to the systemOptions.healthChecks array:

**Examples:**

Example 1 (ts):
```ts
import { TypeORMHealthCheckStrategy } from '@vendure/core';export const config = {  // ...  systemOptions: {    healthChecks:[        // The default key is "database" and the default timeout is 1000ms        // Sometimes this is too short and leads to false negatives in the        // /health endpoint.        new TypeORMHealthCheckStrategy({ key: 'postgres-db', timeout: 5000 }),    ]  }}
```

Example 2 (ts):
```ts
class TypeORMHealthCheckStrategy implements HealthCheckStrategy {    constructor(options?: TypeORMHealthCheckOptions)    init(injector: Injector) => ;    getHealthIndicator() => HealthIndicatorFunction;}
```

---

## Custom Input Components

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-input-components/

**Contents:**
- Custom Input Components
- üìÑÔ∏è Default Inputs
- üìÑÔ∏è FormInputComponent
- üìÑÔ∏è RegisterFormInputComponent

BooleanFormInputComponent

registerFormInputComponent

---

## ErrorResultUnion

**URL:** https://docs.vendure.io/reference/typescript-api/errors/error-result-union

**Contents:**
- ErrorResultUnion
- ErrorResultUnion‚Äã

Used to construct a TypeScript return type for a query or mutation which, in the GraphQL schema, returns a union type composed of a success result (e.g. Order) plus one or more ErrorResult types.

Since the TypeScript entities do not correspond 1-to-1 with their GraphQL type counterparts, we use this type to substitute them.

**Examples:**

Example 1 (ts):
```ts
type UpdateOrderItemsResult = Order | OrderModificationError | OrderLimitError | NegativeQuantityError;type T1 = ErrorResultUnion<UpdateOrderItemsResult, VendureEntityOrder>;// T1 = VendureEntityOrder | OrderModificationError | OrderLimitError | NegativeQuantityError;
```

Example 2 (ts):
```ts
type ErrorResultUnion<T extends GraphQLErrorResult | U, E extends VendureEntity, U = any> = | JustErrorResults<T>    | E
```

---

## ID

**URL:** https://docs.vendure.io/reference/typescript-api/common/id

**Contents:**
- ID
- ID‚Äã

An entity ID. Depending on the configured EntityIdStrategy, it will be either a string or a number;

**Examples:**

Example 1 (ts):
```ts
type ID = string | number
```

---

## EntityHydrator

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/entity-hydrator/

**Contents:**
- EntityHydrator
- EntityHydrator‚Äã
  - constructor‚Äã
  - hydrate‚Äã

This is a helper class which is used to "hydrate" entity instances, which means to populate them with the specified relations. This is useful when writing plugin code which receives an entity, and you need to ensure that one or more relations are present.

In this above example, the product instance will now have the facetValues relation available, and those FacetValues will have their facet relations joined too.

This hydrate method will also automatically take care or translating any translatable entities (e.g. Product, Collection, Facet), and if the applyProductVariantPrices options is used (see HydrateOptions), any related ProductVariant will have the correct Channel-specific prices applied to them.

Custom field relations may also be hydrated:

Hydrates (joins) the specified relations to the target entity instance. This method mutates the target entity.

**Examples:**

Example 1 (ts):
```ts
import { Injectable } from '@nestjs/common';import { ID, RequestContext, EntityHydrator, ProductVariantService } from '@vendure/core';@Injectable()export class MyService {  constructor(     private entityHydrator: EntityHydrator,     private productVariantService: ProductVariantService,  ) {}  myMethod(ctx: RequestContext, variantId: ID) {    const product = await this.productVariantService      .getProductForVariant(ctx, variantId);    // at this stage, we don't know which of the Product relations    // will be joined at runtime.    await this.entityHydrator      .hydrate(ctx, product, { rela
...
```

Example 2 (ts):
```ts
const customer = await this.customerService  .findOne(ctx, id);await this.entityHydrator  .hydrate(ctx, customer, { relations: ['customFields.avatar' ]});
```

Example 3 (ts):
```ts
class EntityHydrator {    constructor(connection: TransactionalConnection, productPriceApplicator: ProductPriceApplicator, translator: TranslatorService)    hydrate(ctx: RequestContext, target: Entity, options: HydrateOptions<Entity>) => Promise<Entity>;}
```

Example 4 (ts):
```ts
await this.entityHydrator.hydrate(ctx, product, {  relations: [    'variants.stockMovements'    'optionGroups.options',    'featuredAsset',  ],  applyProductVariantPrices: true,});
```

---

## VendurePluginMetadata

**URL:** https://docs.vendure.io/reference/typescript-api/plugin/vendure-plugin-metadata/

**Contents:**
- VendurePluginMetadata
- VendurePluginMetadata‚Äã
  - configuration‚Äã
  - shopApiExtensions‚Äã
  - adminApiExtensions‚Äã
  - entities‚Äã
  - dashboard‚Äã
  - compatibility‚Äã
- APIExtensionDefinition‚Äã
  - schema‚Äã

Defines the metadata of a Vendure plugin. This interface is an superset of the Nestjs ModuleMetadata (which allows the definition of imports, exports, providers and controllers), which means that any Nestjs Module is a valid Vendure plugin. In addition, the VendurePluginMetadata allows the definition of extra properties specific to Vendure.

A function which can modify the VendureConfig object before the server bootstraps.

The plugin may extend the default Vendure GraphQL shop api by providing extended schema definitions and any required resolvers.

The plugin may extend the default Vendure GraphQL admin api by providing extended schema definitions and any required resolvers.

The plugin may define custom TypeORM database entities.

The plugin should define a valid semver version string to indicate which versions of Vendure core it is compatible with. Attempting to use a plugin with an incompatible version of Vendure will result in an error and the server will be unable to bootstrap.

If a plugin does not define this property, a message will be logged on bootstrap that the plugin is not guaranteed to be compatible with the current version of Vendure.

To effectively disable this check for a plugin, you can use an overly-permissive string such as >0.0.0.

Since Vendure v3.1.0, it is possible to ignore compatibility errors for specific plugins by passing the ignoreCompatibilityErrorsForPlugins option to the bootstrap function.

An object which allows a plugin to extend the Vendure GraphQL API.

Extensions to the schema. Passes the current schema as an optional argument, allowing the extension to be based on the existing schema.

An array of resolvers for the schema extensions. Should be defined as Nestjs GraphQL resolver classes, i.e. using the Nest @Resolver() decorator etc.

A map of GraphQL scalar types which should correspond to any custom scalars defined in your schema. Read more about defining custom scalars in the Apollo Server Custom Scalars docs

This method is called before the app bootstraps and should be used to perform any needed modifications to the VendureConfig.

**Examples:**

Example 1 (ts):
```ts
interface VendurePluginMetadata extends ModuleMetadata {    configuration?: PluginConfigurationFn;    shopApiExtensions?: APIExtensionDefinition;    adminApiExtensions?: APIExtensionDefinition;    entities?: Array<Type<any>> | (() => Array<Type<any>>);    dashboard?: DashboardExtension;    compatibility?: string;}
```

Example 2 (ts):
```ts
compatibility: '^3.0.0'
```

Example 3 (ts):
```ts
interface APIExtensionDefinition {    schema?: DocumentNode | ((schema?: GraphQLSchema) => DocumentNode | undefined);    resolvers?: Array<Type<any>> | (() => Array<Type<any>>);    scalars?: Record<string, GraphQLScalarType> | (() => Record<string, GraphQLScalarType>);}
```

Example 4 (ts):
```ts
const schema = gql`extend type SearchReindexResponse {    timeTaken: Int!    indexedItemCount: Int!}`;
```

---

## Helpers

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/helpers

**Contents:**
- Helpers
- setBranding‚Äã
  - options‚Äã

A helper function to simplify the process of setting custom branding images.

**Examples:**

Example 1 (ts):
```ts
compileUiExtensions({  outputPath: path.join(__dirname, '../admin-ui'),  extensions: [    setBranding({      // This is used as the branding in the top-left above the navigation      smallLogoPath: path.join(__dirname, 'images/my-logo-sm.png'),      // This is used on the login page      largeLogoPath: path.join(__dirname, 'images/my-logo-lg.png'),      faviconPath: path.join(__dirname, 'images/my-favicon.ico'),    }),  ],});
```

Example 2 (ts):
```ts
function setBranding(options: BrandingOptions): StaticAssetExtension
```

---

## CheckboxInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/checkbox-input

**Contents:**
- CheckboxInput
- CheckboxInput‚Äã
  - props‚Äã

Displays a boolean value as a checkbox.

**Examples:**

Example 1 (ts):
```ts
function CheckboxInput(props: Readonly<DashboardFormComponentProps>): void
```

---

## CompileUiExtensions

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/compile-ui-extensions/

**Contents:**
- CompileUiExtensions
- compileUiExtensions‚Äã
  - options‚Äã

Compiles the Admin UI app with the specified extensions.

**Examples:**

Example 1 (ts):
```ts
function compileUiExtensions(options: UiExtensionCompilerOptions): AdminUiAppConfig | AdminUiAppDevModeConfig
```

---

## AuthOptions

**URL:** https://docs.vendure.io/reference/typescript-api/auth/auth-options

**Contents:**
- AuthOptions
- AuthOptions‚Äã
  - disableAuth‚Äã
  - tokenMethod‚Äã
  - cookieOptions‚Äã
  - authTokenHeaderKey‚Äã
  - sessionDuration‚Äã
  - sessionCacheStrategy‚Äã
  - sessionCacheTTL‚Äã
  - requireVerification‚Äã

The AuthOptions define how authentication and authorization is managed.

Disable authentication & permissions checks. NEVER set the to true in production. It exists only to aid certain development tasks.

Sets the method by which the session token is delivered and read.

Note that if the bearer method is used, Vendure will automatically expose the configured authTokenHeaderKey in the server's CORS configuration (adding Access-Control-Expose-Headers: vendure-auth-token by default).

From v1.2.0 it is possible to specify both methods as a tuple: ['cookie', 'bearer'].

Options related to the handling of cookies when using the 'cookie' tokenMethod.

Sets the header property which will be used to send the auth token when using the 'bearer' method.

Session duration, i.e. the time which must elapse from the last authenticated request after which the user must re-authenticate.

If passed as a number should represent milliseconds and if passed as a string describes a time span per zeit/ms. Eg: 60, '2 days', '10h', '7d'

This strategy defines how sessions will be cached. By default, since v3.1.0, sessions are cached using the underlying cache strategy defined in the SystemOptions.cacheStrategy.

The "time to live" of a given item in the session cache. This determines the length of time that a cache entry is kept before being considered "stale" and being replaced with fresh data taken from the database.

If passed as a number should represent seconds and if passed as a string describes a time span per zeit/ms. Eg: 60, '2 days', '10h', '7d'

Determines whether new User accounts require verification of their email address.

If set to "true", the customer will be required to verify their email address using a verification token they receive in their email. See the registerCustomerAccount mutation for more details on the verification behavior.

Sets the length of time that a verification token is valid for, after which the verification token must be refreshed.

If passed as a number should represent milliseconds and if passed as a string describes a time span per zeit/ms. Eg: 60, '2 days', '10h', '7d'

Configures the credentials to be used to create a superadmin

Configures one or more AuthenticationStrategies which defines how authentication is handled in the Shop API.

Configures one or more AuthenticationStrategy which defines how authentication is handled in the Admin API.

Allows custom Permissions to be defined, which can be used to restrict access to custom GraphQL resolvers and REST controllers. This is done using the `PermissionDefinition` class in conjunction with the `@Allow` decorator.

Custom permissions are defined using `PermissionDefinition` and then added to this array. For example:

```typescript
import { PermissionDefinition } from '@vendure/core';

const syncPermission = new PermissionDefinition({
  name: 'SyncInventory',
  description: 'Allows syncing stock levels via Admin API'
});

const config: VendureConfig = {
  authOptions: {
    customPermissions: [syncPermission],
  },
}
```

Then use the permission in your resolver:

```typescript
@Resolver()
export class InventorySyncResolver {
  @Allow(syncPermission.Permission)
  @Mutation()
  syncInventory() {
    // Only users with the SyncInventory permission can execute this
  }
}
```

**Examples:**

Example 1 (ts):
```ts
interface AuthOptions {    disableAuth?: boolean;    tokenMethod?: 'cookie' | 'bearer' | ReadonlyArray<'cookie' | 'bearer'>;    cookieOptions?: CookieOptions;    authTokenHeaderKey?: string;    sessionDuration?: string | number;    sessionCacheStrategy?: SessionCacheStrategy;    sessionCacheTTL?: string | number;    requireVerification?: boolean;    verificationTokenDuration?: string | number;    superadminCredentials?: SuperadminCredentials;    shopAuthenticationStrategy?: AuthenticationStrategy[];    adminAuthenticationStrategy?: AuthenticationStrategy[];    customPermissions?: PermissionDef
...
```

Example 2 (ts):
```ts
{  passwordValidationStrategy: new DefaultPasswordValidationStrategy({    // Minimum eight characters, at least one letter and one number    regexp: /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/,  }),}
```

---

## Bulk Actions

**URL:** https://docs.vendure.io/reference/admin-ui-api/bulk-actions/

**Contents:**
- Bulk Actions
- üìÑÔ∏è BulkAction
- üìÑÔ∏è RegisterBulkAction

---

## ImageTransformStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/image-transform-strategy

**Contents:**
- ImageTransformStrategy
- ImageTransformStrategy‚Äã
  - getImageTransformParameters‚Äã
- ImageTransformParameters‚Äã
  - width‚Äã
  - height‚Äã
  - mode‚Äã
  - quality‚Äã
  - format‚Äã
  - fpx‚Äã

An injectable strategy which is used to determine the parameters for transforming an image. This can be used to implement custom image transformation logic, for example to limit transform parameters to a known set of presets.

This is set via the imageTransformStrategy option in the AssetServerOptions. Multiple strategies can be defined and will be executed in the order in which they are defined.

If a strategy throws an error, the image transformation will be aborted and the error will be logged, with an HTTP 400 response sent to the client.

Given the input parameters, return the parameters which should be used to transform the image.

Parameters which are used to transform the image.

The arguments passed to the getImageTransformParameters method of an ImageTransformStrategy.

**Examples:**

Example 1 (ts):
```ts
interface ImageTransformStrategy extends InjectableStrategy {    getImageTransformParameters(        args: GetImageTransformParametersArgs,    ): Promise<ImageTransformParameters> | ImageTransformParameters;}
```

Example 2 (ts):
```ts
interface ImageTransformParameters {    width: number | undefined;    height: number | undefined;    mode: ImageTransformMode | undefined;    quality: number | undefined;    format: ImageTransformFormat | undefined;    fpx: number | undefined;    fpy: number | undefined;    preset: string | undefined;}
```

Example 3 (ts):
```ts
interface GetImageTransformParametersArgs {    req: Request;    availablePresets: ImageTransformPreset[];    input: ImageTransformParameters;}
```

---

## RegisterDashboardWidget

**URL:** https://docs.vendure.io/reference/admin-ui-api/dashboard-widgets/register-dashboard-widget

**Contents:**
- RegisterDashboardWidget
- registerDashboardWidget‚Äã
  - id‚Äã
  - config‚Äã

Registers a dashboard widget. Once registered, the widget can be set as part of the default (using setDashboardWidgetLayout).

**Examples:**

Example 1 (ts):
```ts
function registerDashboardWidget(id: string, config: DashboardWidgetConfig): void
```

---

## Core Plugins

**URL:** https://docs.vendure.io/reference/core-plugins/

**Contents:**
- Core Plugins
- üóÉÔ∏è AdminUiPlugin
- üóÉÔ∏è AssetServerPlugin
- üóÉÔ∏è DashboardPlugin
- üóÉÔ∏è ElasticsearchPlugin
- üóÉÔ∏è EmailPlugin
- üóÉÔ∏è GraphiQLPlugin
- üóÉÔ∏è HardenPlugin
- üóÉÔ∏è JobQueuePlugin
- üóÉÔ∏è PaymentsPlugin

---

## Assets

**URL:** https://docs.vendure.io/reference/typescript-api/assets/

**Contents:**
- Assets
- üìÑÔ∏è AssetNamingStrategy
- üìÑÔ∏è AssetOptions
- üìÑÔ∏è AssetPreviewStrategy
- üìÑÔ∏è AssetStorageStrategy
- üìÑÔ∏è DefaultAssetNamingStrategy

DefaultAssetNamingStrategy

---

## SqlJobQueueStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/sql-job-queue-strategy

**Contents:**
- SqlJobQueueStrategy
- SqlJobQueueStrategy‚Äã
  - init‚Äã
  - destroy‚Äã
  - add‚Äã
  - next‚Äã
  - update‚Äã
  - findMany‚Äã
  - findOne‚Äã
  - findManyById‚Äã

A JobQueueStrategy which uses the configured SQL database to persist jobs in the queue. This strategy is used by the DefaultJobQueuePlugin.

Extends: PollingJobQueueStrategy

Implements: InspectableJobQueueStrategy

**Examples:**

Example 1 (ts):
```ts
class SqlJobQueueStrategy extends PollingJobQueueStrategy implements InspectableJobQueueStrategy {    init(injector: Injector) => ;    destroy() => ;    add(job: Job<Data>, jobOptions?: JobQueueStrategyJobOptions<Data>) => Promise<Job<Data>>;    next(queueName: string) => Promise<Job | undefined>;    update(job: Job<any>) => Promise<void>;    findMany(options?: JobListOptions) => Promise<PaginatedList<Job>>;    findOne(id: ID) => Promise<Job | undefined>;    findManyById(ids: ID[]) => Promise<Job[]>;    removeSettledJobs(queueNames: string[] = [], olderThan?: Date) => ;}
```

---

## UsePageMetadata

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-page-metadata

**Contents:**
- UsePageMetadata
- usePageMetadata‚Äã

Provides functions for setting the current page title and breadcrumb.

**Examples:**

Example 1 (ts):
```ts
import { usePageMetadata } from '@vendure/admin-ui/react';import { useEffect } from 'react';export const MyComponent = () => {    const { setTitle, setBreadcrumb } = usePageMetadata();    useEffect(() => {        setTitle('My Page');        setBreadcrumb([            { link: ['./parent'], label: 'Parent Page' },            { link: ['./'], label: 'This Page' },        ]);    }, []);    // ...    return <div>...</div>;}
```

Example 2 (ts):
```ts
function usePageMetadata(): void
```

---

## TaxLineCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/tax/tax-line-calculation-strategy

**Contents:**
- TaxLineCalculationStrategy
- TaxLineCalculationStrategy‚Äã
  - calculate‚Äã
- CalculateTaxLinesArgs‚Äã
  - ctx‚Äã
  - order‚Äã
  - orderLine‚Äã
  - applicableTaxRate‚Äã

This strategy defines how the TaxLines on OrderItems are calculated. By default, the DefaultTaxLineCalculationStrategy is used, which directly applies a single TaxLine based on the applicable TaxRate.

However, custom strategies may use any suitable method for calculating TaxLines. For example, a third-party tax API or a lookup of a custom tax table may be used.

This is configured via the taxOptions.taxLineCalculationStrategy property of your VendureConfig.

This method is called when calculating the Order prices. Since it will be called whenever an Order is modified in some way (adding/removing items, applying promotions, setting ShippingMethod etc), care should be taken so that calling the function does not adversely impact overall performance. For example, by using caching and only calling external APIs when absolutely necessary.

**Examples:**

Example 1 (ts):
```ts
interface TaxLineCalculationStrategy extends InjectableStrategy {    calculate(args: CalculateTaxLinesArgs): TaxLine[] | Promise<TaxLine[]>;}
```

Example 2 (ts):
```ts
interface CalculateTaxLinesArgs {    ctx: RequestContext;    order: Order;    orderLine: OrderLine;    applicableTaxRate: TaxRate;}
```

---

## CustomDetailComponentConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-detail-components/custom-detail-component-config

**Contents:**
- CustomDetailComponentConfig
- CustomDetailComponentConfig‚Äã
  - locationId‚Äã
  - component‚Äã
  - providers‚Äã

Configures a CustomDetailComponent to be placed in the given location.

**Examples:**

Example 1 (ts):
```ts
interface CustomDetailComponentConfig {    locationId: CustomDetailComponentLocationId;    component: Type<CustomDetailComponent>;    providers?: Provider[];}
```

---

## ActiveOrderStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/active-order-strategy

**Contents:**
- ActiveOrderStrategy
- ActiveOrderStrategy‚Äã
  - name‚Äã
  - defineInputType‚Äã
  - createActiveOrder‚Äã
  - determineActiveOrder‚Äã

This strategy is used to determine the active Order for all order-related operations in the Shop API. By default, all the Shop API operations that relate to the active Order (e.g. activeOrder, addItemToOrder, applyCouponCode etc.) will implicitly create a new Order and set it on the current Session, and then read the session to obtain the active Order. This behaviour is defined by the DefaultActiveOrderStrategy.

The InputType generic argument should correspond to the input type defined by the defineInputType() method.

When defineInputType() is used, then the following Shop API operations will receive an additional activeOrderInput argument allowing the active order input to be specified:

The name of the strategy, e.g. "orderByToken", which will also be used as the field name in the ActiveOrderInput type.

Defines the type of the GraphQL Input object expected by the activeOrderInput input argument.

For example, given the following:

assuming the strategy name is "orderByToken", then the resulting call to activeOrder (or any of the other affected Shop API operations) would look like:

Note: if more than one graphql input type is being defined (as in a nested input type), then the first input will be assumed to be the top-level input.

Certain mutations such as addItemToOrder can automatically create a new Order if one does not exist. In these cases, this method will be called to create the new Order.

If automatic creation of an Order does not make sense in your strategy, then leave this method undefined. You'll then need to take care of creating an order manually by defining a custom mutation.

This method is used to determine the active Order based on the current RequestContext in addition to any input values provided, as defined by the defineInputType method of this strategy.

Note that this method is invoked frequently, so you should aim to keep it efficient. The returned Order, for example, does not need to have its various relations joined.

**Examples:**

Example 1 (graphql):
```graphql
mutation AddItemToOrder {  addItemToOrder(    productVariantId: 42,    quantity: 1,    activeOrderInput: { token: "123456" }  ) {    ...on Order {      id      # ...etc    }  }}
```

Example 2 (ts):
```ts
import { ID } from '@vendure/common/lib/shared-types';import {  ActiveOrderStrategy,  CustomerService,  idsAreEqual,  Injector,  Order,  OrderService,  RequestContext,  TransactionalConnection,} from '@vendure/core';import gql from 'graphql-tag';// This strategy assumes a "orderToken" custom field is defined on the Order// entity, and uses that token to perform a lookup to determine the active Order.//// Additionally, it does _not_ define a `createActiveOrder()` method, which// means that a custom mutation would be required to create the initial Order in// the first place and set the "orderTok
...
```

Example 3 (ts):
```ts
interface ActiveOrderStrategy<InputType extends Record<string, any> | void = void> extends InjectableStrategy {    readonly name: string;    defineInputType?: () => DocumentNode;    createActiveOrder?: (ctx: RequestContext, input: InputType) => Promise<Order>;    determineActiveOrder(ctx: RequestContext, input: InputType): Promise<Order | undefined>;}
```

Example 4 (ts):
```ts
defineInputType() {  return gql`     input OrderTokenInput {       token: String!     }  `;}
```

---

## RefundTransitionData

**URL:** https://docs.vendure.io/reference/typescript-api/payment/refund-transition-data

**Contents:**
- RefundTransitionData
- RefundTransitionData‚Äã
  - ctx‚Äã
  - order‚Äã
  - refund‚Äã

The data which is passed to the state transition handler of the RefundStateMachine.

**Examples:**

Example 1 (ts):
```ts
interface RefundTransitionData {    ctx: RequestContext;    order: Order;    refund: Refund;}
```

---

## DataTableComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/data-table-component

**Contents:**
- DataTableComponent
- DataTableComponent‚Äã
  - items‚Äã
  - itemsPerPage‚Äã
  - currentPage‚Äã
  - totalItems‚Äã
  - emptyStateLabel‚Äã
  - selectionManager‚Äã
  - pageChange‚Äã
  - itemsPerPageChange‚Äã

A table for displaying PaginatedList results. It is designed to be used inside components which extend the BaseListComponent class.

Deprecated This component is deprecated. Use the DataTable2Component instead.

**Examples:**

Example 1 (html):
```html
<vdr-data-table  [items]="items$ | async"  [itemsPerPage]="itemsPerPage$ | async"  [totalItems]="totalItems$ | async"  [currentPage]="currentPage$ | async"  (pageChange)="setPageNumber($event)"  (itemsPerPageChange)="setItemsPerPage($event)">  <!-- The header columns are defined first -->  <vdr-dt-column>{{ 'common.name' | translate }}</vdr-dt-column>  <vdr-dt-column></vdr-dt-column>  <vdr-dt-column></vdr-dt-column>  <!-- Then we define how a row is rendered -->  <ng-template let-taxRate="item">    <td class="left align-middle">{{ taxRate.name }}</td>    <td class="left align-middle">{{ taxRat
...
```

Example 2 (ts):
```ts
class DataTableComponent<T> implements AfterContentInit, OnChanges, OnInit, OnDestroy {    @Input() items: T[];    @Input() itemsPerPage: number;    @Input() currentPage: number;    @Input() totalItems: number;    @Input() emptyStateLabel: string;    @Input() selectionManager?: SelectionManager<T>;    @Output() pageChange = new EventEmitter<number>();    @Output() itemsPerPageChange = new EventEmitter<number>();    @Input() allSelected: boolean;    @Input() isRowSelectedFn: ((item: T) => boolean) | undefined;    @Output() allSelectChange = new EventEmitter<void>();    @Output() rowSelectChange
...
```

---

## Api Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/api-decorator

**Contents:**
- Api Decorator
- Api‚Äã

Resolver param decorator which returns which Api the request came though. This is useful because sometimes the same resolver will have different behaviour depending whether it is being called from the shop API or the admin API.

Returns a string of type ApiType.

**Examples:**

Example 1 (ts):
```ts
@Query() getAdministrators(@Api() apiType: ApiType) {   if (apiType === 'admin') {     // ...   } }
```

---

## BaseListComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/base-list-component/

**Contents:**
- BaseListComponent
- BaseListComponent‚Äã
  - searchTermControl‚Äã
  - selectionManager‚Äã
  - result$‚Äã
  - items$‚Äã
  - totalItems$‚Äã
  - itemsPerPage$‚Äã
  - currentPage$‚Äã
  - destroy$‚Äã

This is a base class which implements the logic required to fetch and manipulate a list of data from a query which returns a PaginatedList type.

It is normally used in combination with the DataTable2Component.

Sets the fetch function for the list being implemented.

Accepts a list of Observables which will trigger a refresh of the list when any of them emit.

Sets the current page number in the url.

Sets the number of items per page in the url.

Re-fetch the current page of results.

**Examples:**

Example 1 (ts):
```ts
class BaseListComponent<ResultType, ItemType, VariableType extends Record<string, any> = any> implements OnInit, OnDestroy {    searchTermControl = new FormControl('');    selectionManager = new SelectionManager<any>({        multiSelect: true,        itemsAreEqual: (a, b) => a.id === b.id,        additiveMode: true,    });    result$: Observable<ResultType>;    items$: Observable<ItemType[]>;    totalItems$: Observable<number>;    itemsPerPage$: Observable<number>;    currentPage$: Observable<number>;    protected destroy$ = new Subject<void>();    protected refresh$ = new BehaviorSubject<und
...
```

---

## ProductOption

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product-option/

**Contents:**
- ProductOption
- ProductOption‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - code‚Äã
  - translations‚Äã
  - group‚Äã
  - groupId‚Äã
  - productVariants‚Äã

A ProductOption is used to differentiate ProductVariants from one another.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class ProductOption extends VendureEntity implements Translatable, HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<ProductOption>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    @Column() code: string;    @OneToMany(type => ProductOptionTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<ProductOption>>;    @Index()    @ManyToOne(type => ProductOptionGroup, group => group.options)    group: ProductOptionGroup;    @EntityId()    groupId: ID;    @ManyToMany(type => ProductVariant, v
...
```

---

## ProvinceService

**URL:** https://docs.vendure.io/reference/typescript-api/services/province-service

**Contents:**
- ProvinceService
- ProvinceService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã

Contains methods relating to Province entities.

**Examples:**

Example 1 (ts):
```ts
class ProvinceService {    constructor(connection: TransactionalConnection, listQueryBuilder: ListQueryBuilder, translatableSaver: TranslatableSaver, eventBus: EventBus, translator: TranslatorService)    findAll(ctx: RequestContext, options?: ListQueryOptions<Province>, relations: RelationPaths<Province> = []) => Promise<PaginatedList<Translated<Province>>>;    findOne(ctx: RequestContext, provinceId: ID, relations: RelationPaths<Province> = []) => Promise<Translated<Province> | undefined>;    create(ctx: RequestContext, input: CreateProvinceInput) => Promise<Translated<Province>>;    update(c
...
```

---

## UsePaginatedList

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-paginated-list

**Contents:**
- UsePaginatedList
- usePaginatedList‚Äã

Returns the context for the paginated list data table. Must be used within a PaginatedListDataTable.

**Examples:**

Example 1 (ts):
```ts
const { refetchPaginatedList } = usePaginatedList();const mutation = useMutation({    mutationFn: api.mutate(updateFacetValueDocument),    onSuccess: () => {        refetchPaginatedList();    },});
```

Example 2 (ts):
```ts
function usePaginatedList(): void
```

---

## AuthenticatedSession

**URL:** https://docs.vendure.io/reference/typescript-api/entities/authenticated-session

**Contents:**
- AuthenticatedSession
- AuthenticatedSession‚Äã
  - constructor‚Äã
  - user‚Äã
  - authenticationStrategy‚Äã

An AuthenticatedSession is created upon successful authentication.

The User who has authenticated to create this session.

The name of the AuthenticationStrategy used when authenticating to create this session.

**Examples:**

Example 1 (ts):
```ts
class AuthenticatedSession extends Session {    constructor(input: DeepPartial<AuthenticatedSession>)    @Index()    @ManyToOne(type => User, user => user.sessions)    user: User;    @Column()    authenticationStrategy: string;}
```

---

## SettingsStoreRegistration

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/settings-store-registration

**Contents:**
- SettingsStoreRegistration
- SettingsStoreRegistration‚Äã
  - namespace‚Äã
  - fields‚Äã

Configuration for registering a namespace of settings store fields.

The namespace for these fields (e.g., 'dashboard', 'payment'). Field names will be prefixed with this namespace.

Array of field configurations for this namespace.

**Examples:**

Example 1 (ts):
```ts
interface SettingsStoreRegistration {    namespace: string;    fields: SettingsStoreFieldConfig[];}
```

---

## LogLevel

**URL:** https://docs.vendure.io/reference/typescript-api/logger/log-level

**Contents:**
- LogLevel
- LogLevel‚Äã

An enum of valid logging levels.

**Examples:**

Example 1 (ts):
```ts
enum LogLevel {    // Log Errors only. These are usually indicative of some potentiallyserious issue, so should be acted upon.    Error = 0    // Warnings indicate that some situation may require investigationand handling. But not as serious as an Error.    Warn = 1    // Logs general information such as startup messages.    Info = 2    // Logs additional information    Verbose = 3    // Logs detailed info useful in debug scenarios, including stack traces forall errors. In production this would probably generate too much noise.    Debug = 4}
```

---

## JobQueueStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job-queue-strategy/

**Contents:**
- JobQueueStrategy
- JobQueueStrategy‚Äã
  - add‚Äã
  - start‚Äã
  - stop‚Äã

Defines how the jobs in the JobQueueService are persisted and accessed. Custom strategies can be defined to make use of external services such as Redis.

This is configured via the jobQueueOptions.jobQueueStrategy property of your VendureConfig.

Add a new job to the queue.

Stops a queue from running. Its not guaranteed to stop immediately.

**Examples:**

Example 1 (ts):
```ts
interface JobQueueStrategy extends InjectableStrategy {    add<Data extends JobData<Data> = object>(job: Job<Data>, jobOptions?: JobQueueStrategyJobOptions<Data>): Promise<Job<Data>>;    start<Data extends JobData<Data> = object>(        queueName: string,        process: (job: Job<Data>) => Promise<any>,    ): Promise<void>;    stop<Data extends JobData<Data> = object>(        queueName: string,        process: (job: Job<Data>) => Promise<any>,    ): Promise<void>;}
```

---

## TestServerOptions

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-server-options

**Contents:**
- TestServerOptions
- TestServerOptions‚Äã
  - productsCsvPath‚Äã
  - initialData‚Äã
  - customerCount‚Äã
  - logging‚Äã

Configuration options used to initialize an instance of the TestServer.

The path to an optional CSV file containing product data to import.

An object containing non-product data which is used to populate the database.

The number of fake Customers to populate into the database.

Set this to true to log some information about the database population process.

**Examples:**

Example 1 (ts):
```ts
interface TestServerOptions {    productsCsvPath?: string;    initialData: InitialData;    customerCount?: number;    logging?: boolean;}
```

---

## PageTabConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/tabs/page-tab-config

**Contents:**
- PageTabConfig
- PageTabConfig‚Äã
  - location‚Äã
  - tabIcon‚Äã
  - route‚Äã
  - tab‚Äã
  - priority‚Äã
  - component‚Äã
  - routeConfig‚Äã

The object used to configure a new page tab.

A valid location representing a list or detail page.

An optional icon to display in the tab. The icon should be a valid shape name from the Clarity Icons set.

The route path to the tab. This will be appended to the route of the parent page.

The name of the tab to display in the UI.

The priority of the tab. Tabs with a lower priority will be displayed first.

The component to render at the route of the tab.

You can optionally provide any native Angular route configuration options here. Any values provided here will take precedence over the values generated by the route and component properties.

**Examples:**

Example 1 (ts):
```ts
interface PageTabConfig {    location: PageLocationId;    tabIcon?: string;    route: string;    tab: string;    priority?: number;    component: Type<any> | ReturnType<typeof detailComponentWithResolver>;    routeConfig?: Route;}
```

---

## EntityIdStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/entity-id-strategy

**Contents:**
- EntityIdStrategy
- AutoIncrementIdStrategy‚Äã
  - primaryKeyType‚Äã
  - decodeId‚Äã
  - encodeId‚Äã
- EntityIdStrategy‚Äã
  - primaryKeyType‚Äã
  - encodeId‚Äã
  - decodeId‚Äã
- UuidIdStrategy‚Äã

An id strategy which uses auto-increment integers as primary keys for all entities. This is the default strategy used by Vendure.

The EntityIdStrategy determines how entity IDs are generated and stored in the database, as well as how they are transformed when being passed from the API to the service layer and vice versa.

Vendure ships with two strategies: AutoIncrementIdStrategy and UuidIdStrategy, but custom strategies can be used, e.g. to apply some custom encoding to the ID before exposing it in the GraphQL API.

This is configured via the entityOptions.entityIdStrategy property of your VendureConfig.

Note: changing from an integer-based strategy to a uuid-based strategy on an existing Vendure database will lead to problems with broken foreign-key references. To change primary key types like this, you'll need to start with a fresh database.

Defines how the primary key will be stored in the database - either 'increment' for auto-increment integer IDs, or 'uuid' for a unique string ID.

Allows the raw ID from the database to be transformed in some way before exposing it in the GraphQL API.

For example, you may need to use auto-increment integer IDs due to some business constraint, but you may not want to expose this data publicly in your API. In this case, you can use the encode/decode methods to obfuscate the ID with some kind of encoding scheme, such as base64 (or something more sophisticated).

Reverses the transformation performed by the encodeId method in order to get back to the raw ID value.

An id strategy which uses string uuids as primary keys for all entities. This strategy can be configured with the entityIdStrategy property of the entityOptions property of VendureConfig.

**Examples:**

Example 1 (ts):
```ts
class AutoIncrementIdStrategy implements EntityIdStrategy<'increment'> {    readonly primaryKeyType = 'increment';    decodeId(id: string) => number;    encodeId(primaryKey: number) => string;}
```

Example 2 (ts):
```ts
interface EntityIdStrategy<T extends 'increment' | 'uuid'> extends InjectableStrategy {    readonly primaryKeyType: T;    encodeId: (primaryKey: PrimaryKeyType<T>) => string;    decodeId: (id: string) => PrimaryKeyType<T>;}
```

Example 3 (ts):
```ts
import { UuidIdStrategy, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  entityOptions: {    entityIdStrategy: new UuidIdStrategy(),    // ...  }}
```

Example 4 (ts):
```ts
class UuidIdStrategy implements EntityIdStrategy<'uuid'> {    readonly primaryKeyType = 'uuid';    decodeId(id: string) => string;    encodeId(primaryKey: string) => string;}
```

---

## PaymentMethodHandler

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-method-handler

**Contents:**
- PaymentMethodHandler
- PaymentMethodHandler‚Äã
  - constructor‚Äã

A PaymentMethodHandler contains the code which is used to generate a Payment when a call to the addPaymentToOrder mutation is made. It contains any necessary steps of interfacing with a third-party payment gateway before the Payment is created and can also define actions to fire when the state of the payment is changed.

PaymentMethodHandlers are instantiated using a PaymentMethodConfigOptions object, which configures the business logic used to create, settle and refund payments.

**Examples:**

Example 1 (ts):
```ts
import { PaymentMethodHandler, CreatePaymentResult, SettlePaymentResult, LanguageCode } from '@vendure/core';// A mock 3rd-party payment SDKimport gripeSDK from 'gripe';export const examplePaymentHandler = new PaymentMethodHandler({  code: 'example-payment-provider',  description: [{    languageCode: LanguageCode.en,    value: 'Example Payment Provider',  }],  args: {    apiKey: { type: 'string' },  },  createPayment: async (ctx, order, amount, args, metadata): Promise<CreatePaymentResult> => {    try {      const result = await gripeSDK.charges.create({        amount,        apiKey: args.apiK
...
```

Example 2 (ts):
```ts
class PaymentMethodHandler<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: PaymentMethodConfigOptions<T>)}
```

---

## Types

**URL:** https://docs.vendure.io/reference/graphql-api/shop/object-types/

**Contents:**
- Types
- ActiveOrderResult‚Äã
- AddPaymentToOrderResult‚Äã
- Address‚Äã
- Adjustment‚Äã
- AlreadyLoggedInError‚Äã
- ApplyCouponCodeResult‚Äã
- Asset‚Äã
- AssetList‚Äã
- AuthenticationMethod‚Äã

---

## EmailSender

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-sender

**Contents:**
- EmailSender
- EmailSender‚Äã
  - send‚Äã
- NodemailerEmailSender‚Äã
  - send‚Äã

An EmailSender is responsible for sending the email, e.g. via an SMTP connection or using some other mail-sending API. By default, the EmailPlugin uses the NodemailerEmailSender, but it is also possible to supply a custom implementation:

Uses the configured transport to send the generated email.

**Examples:**

Example 1 (ts):
```ts
const sgMail = require('@sendgrid/mail');sgMail.setApiKey(process.env.SENDGRID_API_KEY);class SendgridEmailSender implements EmailSender {  async send(email: EmailDetails) {    await sgMail.send({      to: email.recipient,      from: email.from,      subject: email.subject,      html: email.body,    });  }}const config: VendureConfig = {  logger: new DefaultLogger({ level: LogLevel.Debug })  // ...  plugins: [    EmailPlugin.init({       // ... template, handler config omitted      transport: { type: 'none' },       emailSender: new SendgridEmailSender(),    }),  ],};
```

Example 2 (ts):
```ts
interface EmailSender extends InjectableStrategy {    send: (email: EmailDetails, options: EmailTransportOptions) => void | Promise<void>;}
```

Example 3 (ts):
```ts
class NodemailerEmailSender implements EmailSender {    send(email: EmailDetails, options: EmailTransportOptions) => ;}
```

---

## AssetStorageStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/assets/asset-storage-strategy

**Contents:**
- AssetStorageStrategy
- AssetStorageStrategy‚Äã
  - writeFileFromBuffer‚Äã
  - writeFileFromStream‚Äã
  - readFileToBuffer‚Äã
  - readFileToStream‚Äã
  - deleteFile‚Äã
  - fileExists‚Äã
  - toAbsoluteUrl‚Äã

The AssetPersistenceStrategy determines how Asset files are physically stored and retrieved.

This is configured via the assetOptions.assetStorageStrategy property of your VendureConfig.

Writes a buffer to the store and returns a unique identifier for that file such as a file path or a URL.

Writes a readable stream to the store and returns a unique identifier for that file such as a file path or a URL.

Reads a file based on an identifier which was generated by the writeFile method, and returns the as a Buffer.

Reads a file based on an identifier which was generated by the writeFile method, and returns the file as a Stream.

Deletes a file from the storage.

Check whether a file with the given name already exists. Used to avoid naming conflicts before saving the file.

Convert an identifier as generated by the writeFile... methods into an absolute url (if it is not already in that form). If no conversion step is needed (i.e. the identifier is already an absolute url) then this method should not be implemented.

**Examples:**

Example 1 (ts):
```ts
interface AssetStorageStrategy extends InjectableStrategy {    writeFileFromBuffer(fileName: string, data: Buffer): Promise<string>;    writeFileFromStream(fileName: string, data: Stream): Promise<string>;    readFileToBuffer(identifier: string): Promise<Buffer>;    readFileToStream(identifier: string): Promise<Stream>;    deleteFile(identifier: string): Promise<void>;    fileExists(fileName: string): Promise<boolean>;    toAbsoluteUrl?(request: Request, identifier: string): string;}
```

---

## DefaultGuestCheckoutStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/default-guest-checkout-strategy

**Contents:**
- DefaultGuestCheckoutStrategy
- DefaultGuestCheckoutStrategy‚Äã
  - init‚Äã
  - constructor‚Äã
  - setCustomerForOrder‚Äã
- DefaultGuestCheckoutStrategyOptions‚Äã
  - allowGuestCheckouts‚Äã
  - allowGuestCheckoutForRegisteredCustomers‚Äã

The default implementation of the GuestCheckoutStrategy. This strategy allows guest checkouts by default, but can be configured to disallow them.

Options available for the DefaultGuestCheckoutStrategy.

Whether to allow guest checkouts.

Whether to allow guest checkouts for customers who already have an account. Note that when this is enabled, the details provided in the CreateCustomerInput will overwrite the existing customer details of the registered customer.

**Examples:**

Example 1 (ts):
```ts
import { DefaultGuestCheckoutStrategy, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  orderOptions: {    guestCheckoutStrategy: new DefaultGuestCheckoutStrategy({      allowGuestCheckouts: false,      allowGuestCheckoutForRegisteredCustomers: false,    }),  },  // ...};
```

Example 2 (ts):
```ts
class DefaultGuestCheckoutStrategy implements GuestCheckoutStrategy {    init(injector: Injector) => ;    constructor(options?: DefaultGuestCheckoutStrategyOptions)    setCustomerForOrder(ctx: RequestContext, order: Order, input: CreateCustomerInput) => Promise<ErrorResultUnion<SetCustomerForOrderResult, Customer>>;}
```

Example 3 (ts):
```ts
interface DefaultGuestCheckoutStrategyOptions {    allowGuestCheckouts?: boolean;    allowGuestCheckoutForRegisteredCustomers?: boolean;}
```

---

## AuthenticationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/authentication-strategy/

**Contents:**
- AuthenticationStrategy
- AuthenticationStrategy‚Äã
  - name‚Äã
  - defineInputType‚Äã
  - authenticate‚Äã
  - onLogOut‚Äã

An AuthenticationStrategy defines how a User (which can be a Customer in the Shop API or and Administrator in the Admin API) may be authenticated.

Real-world examples can be found in the Authentication guide.

This is configured via the authOptions.shopAuthenticationStrategy and authOptions.adminAuthenticationStrategy properties of your VendureConfig.

The name of the strategy, for example 'facebook', 'google', 'keycloak'.

Defines the type of the GraphQL Input object expected by the authenticate mutation. The final input object will be a map, with the key being the name of the strategy. The shape of the input object should match the generic Data type argument.

For example, given the following:

assuming the strategy name is "my_auth", then the resulting call to authenticate would look like:

Note: if more than one graphql input type is being defined (as in a nested input type), then the first input will be assumed to be the top-level input.

Used to authenticate a user with the authentication provider. This method will implement the provider-specific authentication logic, and should resolve to either a User object on success, or false | string on failure. A string return could be used to describe what error happened, otherwise false to an unknown error.

Called when a user logs out, and may perform any required tasks related to the user logging out with the external provider.

**Examples:**

Example 1 (ts):
```ts
interface AuthenticationStrategy<Data = unknown> extends InjectableStrategy {    readonly name: string;    defineInputType(): DocumentNode;    authenticate(ctx: RequestContext, data: Data): Promise<User | false | string>;    onLogOut?(ctx: RequestContext, user: User): Promise<void>;}
```

Example 2 (ts):
```ts
defineInputType() {  return gql`     input MyAuthInput {       token: String!     }  `;}
```

Example 3 (graphql):
```graphql
authenticate(input: {  my_auth: {    token: "foo"  }}) {  # ...}
```

---

## PageLocationId

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/page-location-id/

**Contents:**
- PageLocationId
- PageLocationId‚Äã

The valid locationIds for registering action bar items or tabs.

**Examples:**

Example 1 (ts):
```ts
type PageLocationId = | 'administrator-detail'    | 'administrator-list'    | 'asset-detail'    | 'asset-list'    | 'channel-detail'    | 'channel-list'    | 'collection-detail'    | 'collection-list'    | 'country-detail'    | 'country-list'    | 'customer-detail'    | 'customer-list'    | 'customer-group-list'    | 'customer-group-detail'    | 'draft-order-detail'    | 'facet-detail'    | 'facet-list'    | 'global-setting-detail'    | 'system-status'    | 'job-list'    | 'order-detail'    | 'order-list'    | 'modify-order'    | 'payment-method-detail'    | 'payment-method-list'    | 'product
...
```

---

## OrderCalculator

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/order-calculator

**Contents:**
- OrderCalculator
- OrderCalculator‚Äã
  - constructor‚Äã
  - applyPriceAdjustments‚Äã
  - calculateOrderTotals‚Äã

This helper is used when making changes to an Order, to apply all applicable price adjustments to that Order, including:

Applies taxes and promotions to an Order. Mutates the order object. Returns an array of any OrderItems which had new adjustments applied, either tax or promotions.

Sets the totals properties on an Order by summing each OrderLine, and taking into account any Surcharges and ShippingLines. Does not save the Order, so the entity must be persisted to the DB after calling this method.

Note that this method does not evaluate any taxes or promotions. It assumes that has already been done and is solely responsible for summing the totals.

**Examples:**

Example 1 (ts):
```ts
class OrderCalculator {    constructor(configService: ConfigService, zoneService: ZoneService, taxRateService: TaxRateService, shippingMethodService: ShippingMethodService, shippingCalculator: ShippingCalculator, requestContextCache: RequestContextCacheService)    applyPriceAdjustments(ctx: RequestContext, order: Order, promotions: Promotion[], updatedOrderLines: OrderLine[] = [], options?: { recalculateShipping?: boolean }) => Promise<Order>;    calculateOrderTotals(order: Order) => ;}
```

---

## TrustProxyOptions

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/trust-proxy-options

**Contents:**
- TrustProxyOptions
- TrustProxyOptions‚Äã

Configures Express trust proxy settings when running behind a reverse proxy (usually the case with most hosting services). Setting trustProxy allows you to retrieve the original IP address from the X-Forwarded-For header.

See the express documentation for more details.

**Examples:**

Example 1 (ts):
```ts
type TrustProxyOptions = boolean | number | string | string[] | ((ip: string) => boolean)
```

---

## UsePermissions

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-permissions

**Contents:**
- UsePermissions
- usePermissions‚Äã

Returns a hasPermissions function that can be used to determine whether the active user has the given permissions on the active channel.

**Examples:**

Example 1 (tsx):
```tsx
const { hasPermissions } = usePermissions();const canReadChannel = hasPermissions(['ReadChannel']);
```

Example 2 (ts):
```ts
function usePermissions(): void
```

---

## OrderSellerStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-seller-strategy

**Contents:**
- OrderSellerStrategy
- OrderSellerStrategy‚Äã
  - setOrderLineSellerChannel‚Äã
  - splitOrder‚Äã
  - afterSellerOrdersCreated‚Äã
- DefaultOrderSellerStrategy‚Äã
- SplitOrderContents‚Äã
  - channelId‚Äã
  - state‚Äã
  - lines‚Äã

This strategy defines how an Order can be split into multiple sub-orders for the use-case of a multivendor application.

This is configured via the orderOptions.orderSellerStrategy property of your VendureConfig.

This method is called whenever a new OrderLine is added to the Order via the addItemToOrder mutation or the underlying addItemToOrder() method of the OrderService.

It should return the Channel to which this OrderLine will be assigned, which will be used to set the OrderLine sellerChannel property.

Upon checkout (by default, when the Order moves from "active" to "inactive" according to the OrderPlacedStrategy), this method will be called in order to split the Order into multiple Orders, one for each Seller.

This method is called after splitting the orders, including calculating the totals for each of the seller Orders. This method can be used to set platform fee surcharges on the seller Orders as well as perform any payment processing needed.

The DefaultOrderSellerStrategy treats the Order as single-vendor.

The contents of the aggregate Order which make up a single seller Order.

**Examples:**

Example 1 (ts):
```ts
interface OrderSellerStrategy extends InjectableStrategy {    setOrderLineSellerChannel?(        ctx: RequestContext,        orderLine: OrderLine,    ): Channel | undefined | Promise<Channel | undefined>;    splitOrder?(ctx: RequestContext, order: Order): SplitOrderContents[] | Promise<SplitOrderContents[]>;    afterSellerOrdersCreated?(        ctx: RequestContext,        aggregateOrder: Order,        sellerOrders: Order[],    ): void | Promise<void>;}
```

Example 2 (ts):
```ts
class DefaultOrderSellerStrategy implements OrderSellerStrategy {}
```

Example 3 (ts):
```ts
interface SplitOrderContents {    channelId: ID;    state: OrderState;    lines: OrderLine[];    shippingLines: ShippingLine[];}
```

---

## SettingsStoreScopes

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/settings-store-scopes

**Contents:**
- SettingsStoreScopes
- SettingsStoreScopes‚Äã

Pre-built scope functions for common scoping patterns.

**Examples:**

Example 1 (ts):
```ts
const config: VendureConfig = {  settingsStoreFields: {    dashboard: [      {        name: 'theme',        scope: SettingsStoreScopes.user, // User-specific      },      {        name: 'currency',        scope: SettingsStoreScopes.channel, // Channel-specific      },      {        name: 'tableFilters',        scope: SettingsStoreScopes.userAndChannel, // User-specific per channel      }    ]  }};
```

---

## ErrorHandlerStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/errors/error-handler-strategy

**Contents:**
- ErrorHandlerStrategy
- ErrorHandlerStrategy‚Äã
  - handleServerError‚Äã
  - handleWorkerError‚Äã

This strategy defines logic for handling errors thrown during on both the server and the worker. It can be used for additional logging & monitoring, or for sending error reports to external services.

This is configured via the systemOptions.errorHandlers property of your VendureConfig.

This method will be invoked for any error thrown during the execution of the server.

This method will be invoked for any error thrown during the execution of a job on the worker.

**Examples:**

Example 1 (ts):
```ts
import { ArgumentsHost, ExecutionContext } from '@nestjs/common';import { GqlContextType, GqlExecutionContext } from '@nestjs/graphql';import { ErrorHandlerStrategy, I18nError, Injector, Job, LogLevel } from '@vendure/core';import { MonitoringService } from './monitoring.service';export class CustomErrorHandlerStrategy implements ErrorHandlerStrategy {    private monitoringService: MonitoringService;    init(injector: Injector) {        this.monitoringService = injector.get(MonitoringService);    }    handleServerError(error: Error, { host }: { host: ArgumentsHost }) {         const errorConte
...
```

Example 2 (ts):
```ts
interface ErrorHandlerStrategy extends InjectableStrategy {    handleServerError(exception: Error, context: { host: ArgumentsHost }): void | Promise<void>;    handleWorkerError(exception: Error, context: { job: Job }): void | Promise<void>;}
```

---

## StellatePluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/stellate-plugin/stellate-plugin-options

**Contents:**
- StellatePluginOptions
- StellatePluginOptions‚Äã
  - serviceName‚Äã
  - apiToken‚Äã
  - purgeRules‚Äã
  - defaultBufferTimeMs‚Äã
  - devMode‚Äã
  - debugLogging‚Äã

Configuration options for the StellatePlugin.

The Stellate service name, i.e. <service-name>.stellate.sh

The Stellate Purging API token. For instructions on how to generate the token, see the Stellate docs

An array of PurgeRule instances which are used to define how the plugin will respond to Vendure events in order to trigger calls to the Stellate Purging API.

When events are published, the PurgeRules will buffer those events in order to efficiently batch requests to the Stellate Purging API. You may wish to change the default, e.g. if you are running in a serverless environment and cannot introduce pauses after the main request has completed.

When set to true, calls will not be made to the Stellate Purge API.

If set to true, the plugin will log the calls that would be made to the Stellate Purge API. Note, this generates a lot of debug-level logging.

**Examples:**

Example 1 (ts):
```ts
interface StellatePluginOptions {    serviceName: string;    apiToken: string;    purgeRules: PurgeRule[];    defaultBufferTimeMs?: number;    devMode?: boolean;    debugLogging?: boolean;}
```

---

## OrphanedSettingsStoreEntry

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/orphaned-settings-store-entry

**Contents:**
- OrphanedSettingsStoreEntry
- OrphanedSettingsStoreEntry‚Äã
  - key‚Äã
  - scope‚Äã
  - updatedAt‚Äã
  - valuePreview‚Äã

Represents an orphaned settings store entry that no longer has a corresponding field definition in the configuration.

The scope of the orphaned entry.

When the entry was last updated.

Preview of the stored value (truncated for large values).

**Examples:**

Example 1 (ts):
```ts
interface OrphanedSettingsStoreEntry {    key: string;    scope: string;    updatedAt: Date;    valuePreview: string;}
```

---

## InMemoryJobQueueStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/in-memory-job-queue-strategy/

**Contents:**
- InMemoryJobQueueStrategy
- InMemoryJobQueueStrategy‚Äã
  - jobs‚Äã
  - unsettledJobs‚Äã
  - init‚Äã
  - destroy‚Äã
  - add‚Äã
  - findOne‚Äã
  - findMany‚Äã
  - findManyById‚Äã

An in-memory JobQueueStrategy. This is the default strategy if not using a dedicated JobQueue plugin (e.g. DefaultJobQueuePlugin). Not recommended for production, since the queue will be cleared when the server stops, and can only be used when the JobQueueService is started from the main server process:

Attempting to use this strategy when running the worker in a separate process (using bootstrapWorker()) will result in an error on startup.

Completed jobs will be evicted from the store every 2 hours to prevent a memory leak.

Extends: PollingJobQueueStrategy

Implements: InspectableJobQueueStrategy

**Examples:**

Example 1 (ts):
```ts
bootstrap(config)  .then(app => app.get(JobQueueService).start());
```

Example 2 (ts):
```ts
class InMemoryJobQueueStrategy extends PollingJobQueueStrategy implements InspectableJobQueueStrategy {    protected jobs = new Map<ID, Job>();    protected unsettledJobs: { [queueName: string]: Array<{ job: Job; updatedAt: Date }> } = {};    init(injector: Injector) => ;    destroy() => ;    add(job: Job<Data>) => Promise<Job<Data>>;    findOne(id: ID) => Promise<Job | undefined>;    findMany(options?: JobListOptions) => Promise<PaginatedList<Job>>;    findManyById(ids: ID[]) => Promise<Job[]>;    next(queueName: string, waitingJobs: Job[] = []) => Promise<Job | undefined>;    update(job: Job
...
```

---

## Promotion Action

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/promotion-action

**Contents:**
- Promotion Action
- PromotionAction‚Äã
  - priorityValue‚Äã
  - constructor‚Äã
- PromotionItemAction‚Äã
  - constructor‚Äã
- PromotionOrderAction‚Äã
  - constructor‚Äã
- PromotionShippingAction‚Äã
  - constructor‚Äã

An abstract class which is extended by PromotionItemAction, PromotionOrderAction, and PromotionShippingAction.

Used to determine the order of application of multiple Promotions on the same Order. See the Promotion priorityScore field for more information.

Represents a PromotionAction which applies to individual OrderLines.

Represents a PromotionAction which applies to the Order as a whole.

Represents a PromotionAction which applies to the shipping cost of an Order.

The function which is used by a PromotionItemAction to calculate the discount on the OrderLine for each item.

The function which is used by a PromotionLineAction to calculate the discount on the OrderLine.

The function which is used by a PromotionOrderAction to calculate the discount on the Order.

The function which is used by a PromotionOrderAction to calculate the discount on the Order.

The signature of a PromotionAction's side-effect functions onActivate and onDeactivate.

Configuration for all types of PromotionAction.

Used to determine the order of application of multiple Promotions on the same Order. See the Promotion priorityScore field for more information.

Allows PromotionActions to define one or more PromotionConditions as dependencies. Having a PromotionCondition as a dependency has the following consequences:

An optional side effect function which is invoked when the promotion becomes active. It can be used for things like adding a free gift to the order or other side effects that are unrelated to price calculations.

If used, make sure to use the corresponding onDeactivate function to clean up or reverse any side effects as needed.

Used to reverse or clean up any side effects executed as part of the onActivate function.

Configuration for a PromotionItemAction

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount the OrderLine, i.e. the number should be negative.

Configuration for a PromotionLineAction

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount the OrderLine, i.e. the number should be negative.

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount the Order, i.e. the number should be negative.

The function which contains the promotion calculation logic. Should resolve to a number which represents the amount by which to discount.

**Promotion Action Types:**

- **PromotionItemAction**: Applies discounts to individual OrderLines on a per-item basis
- **PromotionLineAction**: Similar to PromotionItemAction but applies regardless of OrderLine quantity
- **PromotionOrderAction**: Applies discounts to the entire Order total
- **PromotionShippingAction**: Applies discounts specifically to shipping costs

**Execution Functions:**

Each action type requires an `execute` function:

- **PromotionItemActionConfig**: Receives OrderLine, returns negative number for per-item discount
- **PromotionOrderActionConfig**: Receives Order object, returns negative number for order-level discount
- **PromotionShippingActionConfig**: Receives ShippingLine and Order, returns negative number for shipping discount

All execute functions receive `ctx` (RequestContext), `args` (configuration arguments), `state` (condition results), and the `promotion` entity itself.

The `PromotionAction` class includes a `priorityValue` property (default: 0) used to determine application order when multiple promotions affect the same order.

**Examples:**

Example 1 (ts):
```ts
class PromotionAction<T extends ConfigArgs = ConfigArgs, U extends PromotionCondition[] | undefined = any> extends ConfigurableOperationDef<T> {    readonly priorityValue: number;    constructor(config: PromotionActionConfig<T, U>)}
```

Example 2 (ts):
```ts
// Applies a percentage discount to each OrderLineconst itemPercentageDiscount = new PromotionItemAction({    code: 'item_percentage_discount',    args: { discount: 'percentage' },    execute(ctx, orderLine, args) {        return -orderLine.unitPrice * (args.discount / 100);    },    description: 'Discount every item by { discount }%',});
```

Example 3 (ts):
```ts
class PromotionItemAction<T extends ConfigArgs = ConfigArgs, U extends Array<PromotionCondition<any>> = []> extends PromotionAction<T, U> {    constructor(config: PromotionItemActionConfig<T, U>)}
```

Example 4 (ts):
```ts
// Applies a percentage discount to the entire Orderconst orderPercentageDiscount = new PromotionOrderAction({    code: 'order_percentage_discount',    args: { discount: 'percentage' },    execute(ctx, order, args) {        return -order.subTotal * (args.discount / 100);    },    description: 'Discount order by { discount }%',});
```

---

## WorkerHealthCheckConfig

**URL:** https://docs.vendure.io/reference/typescript-api/worker/worker-health-check-config

**Contents:**
- WorkerHealthCheckConfig
- WorkerHealthCheckConfig‚Äã
  - port‚Äã
  - hostname‚Äã
  - route‚Äã

Specifies the configuration for the Worker's HTTP health check endpoint.

The port on which the worker will listen

The route at which the health check is available.

**Examples:**

Example 1 (ts):
```ts
interface WorkerHealthCheckConfig {    port: number;    hostname?: string;    route?: string;}
```

---

## OrderLine

**URL:** https://docs.vendure.io/reference/typescript-api/entities/order-line/

**Contents:**
- OrderLine
- OrderLine‚Äã
  - constructor‚Äã
  - sellerChannel‚Äã
  - sellerChannelId‚Äã
  - shippingLine‚Äã
  - shippingLineId‚Äã
  - productVariant‚Äã
  - productVariantId‚Äã
  - taxCategory‚Äã

A single line on an Order which contains information about the ProductVariant and quantity ordered, as well as the price and tax information.

Extends: VendureEntity

Implements: HasCustomFields

The Channel of the Seller for a multivendor setup.

The ShippingLine to which this line has been assigned. This is determined by the configured ShippingLineAssignmentStrategy.

The ProductVariant which is being ordered.

The quantity of this OrderLine at the time the order was placed (as per the OrderPlacedStrategy).

The price as calculated when the OrderLine was first added to the Order. Usually will be identical to the listPrice, except when the ProductVariant price has changed in the meantime and a re-calculation of the Order has been performed.

This is the price as listed by the ProductVariant (and possibly modified by the OrderItemPriceCalculationStrategy), which, depending on the current Channel, may or may not include tax.

Whether the listPrice includes tax, which depends on the settings of the current Channel.

The price of a single unit, excluding tax and discounts.

The price of a single unit, including tax but excluding discounts.

Non-zero if the unitPrice has changed since it was initially added to Order.

Non-zero if the unitPriceWithTax has changed since it was initially added to Order.

The price of a single unit including discounts, excluding tax.

If Order-level discounts have been applied, this will not be the actual taxable unit price (see proratedUnitPrice), but is generally the correct price to display to customers to avoid confusion about the internal handling of distributed Order-level discounts.

The price of a single unit including discounts and tax

The actual unit price, taking into account both item discounts and prorated (proportionally-distributed) Order-level discounts. This value is the true economic value of a single unit in this OrderLine, and is used in tax and refund calculations.

The proratedUnitPrice including tax.

The total price of the line excluding tax and discounts.

The total price of the line including tax but excluding discounts.

The price of the line including discounts, excluding tax.

The price of the line including discounts and tax.

The total tax on this line.

The actual line price, taking into account both item discounts and prorated (proportionally-distributed) Order-level discounts. This value is the true economic value of the OrderLine, and is used in tax and refund calculations.

The proratedLinePric

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
class OrderLine extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<OrderLine>)    @Index()    @ManyToOne(type => Channel, { nullable: true, onDelete: 'SET NULL' })    sellerChannel?: Channel;    @EntityId({ nullable: true })    sellerChannelId?: ID;    @Index()    @ManyToOne(type => ShippingLine, shippingLine => shippingLine.orderLines, {        nullable: true,        onDelete: 'SET NULL',    })    shippingLine?: ShippingLine;    @EntityId({ nullable: true })    shippingLineId?: ID;    @Index()    @ManyToOne(type => ProductVariant, productVariant => productVa
...
```

---

## Collection

**URL:** https://docs.vendure.io/reference/typescript-api/entities/collection/

**Contents:**
- Collection
- Collection‚Äã
  - constructor‚Äã
  - isRoot‚Äã
  - position‚Äã
  - isPrivate‚Äã
  - name‚Äã
  - description‚Äã
  - slug‚Äã
  - translations‚Äã

A Collection is a grouping of Products based on various configurable criteria.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware, Orderable

**Examples:**

Example 1 (ts):
```ts
class Collection extends VendureEntity implements Translatable, HasCustomFields, ChannelAware, Orderable {    constructor(input?: DeepPartial<Collection>)    @Column({ default: false })    isRoot: boolean;    @Column()    position: number;    @Column({ default: false })    isPrivate: boolean;    name: LocaleString;    description: LocaleString;    slug: LocaleString;    @OneToMany(type => CollectionTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<Collection>>;    @Index()    @ManyToOne(type => Asset, asset => asset.featuredInCollections, { onDel
...
```

---

## SellerService

**URL:** https://docs.vendure.io/reference/typescript-api/services/seller-service

**Contents:**
- SellerService
- SellerService‚Äã
  - constructor‚Äã
  - initSellers‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã

Contains methods relating to Seller entities.

**Examples:**

Example 1 (ts):
```ts
class SellerService {    constructor(connection: TransactionalConnection, listQueryBuilder: ListQueryBuilder, eventBus: EventBus, customFieldRelationService: CustomFieldRelationService)    initSellers() => ;    findAll(ctx: RequestContext, options?: ListQueryOptions<Seller>) => Promise<PaginatedList<Seller>>;    findOne(ctx: RequestContext, sellerId: ID) => Promise<Seller | undefined>;    create(ctx: RequestContext, input: CreateSellerInput) => ;    update(ctx: RequestContext, input: UpdateSellerInput) => ;    delete(ctx: RequestContext, id: ID) => Promise<DeletionResponse>;}
```

---

## CleanSessionsTask

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/clean-sessions-task

**Contents:**
- CleanSessionsTask
- cleanSessionsTask‚Äã

A ScheduledTask that cleans expired & inactive sessions from the database.

**Examples:**

Example 1 (ts):
```ts
import { cleanSessionsTask, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  // ...  schedulerOptions: {    tasks: [      // Use the task as is      cleanSessionsTask,      // or configure the task      cleanSessionsTask.configure({        // Run the task every day at 3:00am        // The default schedule is every day at 00:00am        schedule: cron => cron.everyDayAt(3, 0),        params: {          // How many sessions to process in each batch          // Default: 1000          batchSize: 5_000,        },      }),    ],  },};
```

---

## PaginatedListDataTable

**URL:** https://docs.vendure.io/reference/dashboard/list-views/paginated-list-data-table

**Contents:**
- PaginatedListDataTable
- PaginatedListDataTable‚Äã
  - props‚Äã
- PaginatedListDataTableProps‚Äã
  - listQuery‚Äã
  - deleteMutation‚Äã
  - transformQueryKey‚Äã
  - transformVariables‚Äã
  - customizeColumns‚Äã
  - additionalColumns‚Äã

A wrapper around the DataTable component, which automatically configures functionality common to list queries that implement the PaginatedList interface, which is the common way of representing lists of data in Vendure.

Given a GraphQL query document node, the component will automatically configure the required columns with sorting & filtering functionality.

The automatic features can be further customized and enhanced using the many options available in the props.

Props to configure the PaginatedListDataTable component.

**Examples:**

Example 1 (tsx):
```tsx
import { Money } from '@/vdb/components/data-display/money.js';import { PaginatedListDataTable } from '@/vdb/components/shared/paginated-list-data-table.js';import { Badge } from '@/vdb/components/ui/badge.js';import { Button } from '@/vdb/components/ui/button.js';import { Link } from '@tanstack/react-router';import { ColumnFiltersState, SortingState } from '@tanstack/react-table';import { useState } from 'react';import { customerOrderListDocument } from '../customers.graphql.js';interface CustomerOrderTableProps {    customerId: string;}export function CustomerOrderTable({ customerId }: Reado
...
```

Example 2 (ts):
```ts
function PaginatedListDataTable<T extends TypedDocumentNode<U, V>, U extends Record<string, any> = any, V extends ListQueryOptionsShape = any, AC extends AdditionalColumns<T> = AdditionalColumns<T>>(props: Readonly<PaginatedListDataTableProps<T, U, V, AC>>): void
```

Example 3 (ts):
```ts
interface PaginatedListDataTableProps<T extends TypedDocumentNode<U, V>, U extends ListQueryShape, V extends ListQueryOptionsShape, AC extends AdditionalColumns<T>> {    listQuery: T;    deleteMutation?: TypedDocumentNode<any, any>;    transformQueryKey?: (queryKey: any[]) => any[];    transformVariables?: (variables: V) => V;    customizeColumns?: CustomizeColumnConfig<T>;    additionalColumns?: AC;    defaultColumnOrder?: (keyof ListQueryFields<T> | keyof AC | CustomFieldKeysOfItem<ListQueryFields<T>>)[];    defaultVisibility?: Partial<Record<AllItemFieldKeys<T>, boolean>>;    onSearchTermCh
...
```

---

## PermissionDefinition

**URL:** https://docs.vendure.io/reference/typescript-api/auth/permission-definition/

**Contents:**
- PermissionDefinition
- PermissionDefinition‚Äã
  - constructor‚Äã
  - Permission‚Äã
- CrudPermissionDefinition‚Äã
  - constructor‚Äã
  - Create‚Äã
  - Read‚Äã
  - Update‚Äã
  - Delete‚Äã

Defines a new Permission with which to control access to GraphQL resolvers & REST controllers. Used in conjunction with the Allow decorator (see example below).

Note: To define CRUD permissions, use the CrudPermissionDefinition.

Returns the permission defined by this definition, for use in the Allow decorator.

Defines a set of CRUD Permissions for the given name, i.e. a name of 'Wishlist' will create 4 Permissions: 'CreateWishlist', 'ReadWishlist', 'UpdateWishlist' & 'DeleteWishlist'.

Returns the 'Create' CRUD permission defined by this definition, for use in the Allow decorator.

Returns the 'Read' CRUD permission defined by this definition, for use in the Allow decorator.

Returns the 'Update' CRUD permission defined by this definition, for use in the Allow decorator.

Returns the 'Delete' CRUD permission defined by this definition, for use in the Allow decorator.

Defines a set of Read-Write Permissions for the given name, i.e. a name of 'DashboardSavedViews' will create 2 Permissions: 'ReadDashboardSavedViews' and 'WriteDashboardSavedViews'.

Returns the 'Read' permission defined by this definition, for use in the Allow decorator.

Returns the 'Write' permission defined by this definition, for use in the Allow decorator.

Configures a PermissionDefinition

The name of the permission. By convention this should be UpperCamelCased.

A description of the permission.

Whether this permission can be assigned to a Role. In general this should be left as the default true except in special cases.

Internal permissions are not exposed via the API and are reserved for special use-cases such at the Owner or Public permissions.

**Examples:**

Example 1 (ts):
```ts
export const sync = new PermissionDefinition({  name: 'SyncInventory',  description: 'Allows syncing stock levels via Admin API'});
```

Example 2 (ts):
```ts
const config: VendureConfig = {  authOptions: {    customPermissions: [sync],  },}
```

Example 3 (ts):
```ts
@Resolver()export class ExternalSyncResolver {  @Allow(sync.Permission)  @Mutation()  syncStockLevels() {    // ...  }}
```

Example 4 (ts):
```ts
class PermissionDefinition {    constructor(config: PermissionDefinitionConfig)    Permission: Permission}
```

---

## PageActionBar

**URL:** https://docs.vendure.io/reference/dashboard/page-layout/page-action-bar

**Contents:**
- PageActionBar
- PageActionBar‚Äã
  - props‚Äã
- PageActionBarLeft‚Äã
  - props‚Äã
- PageActionBarRight‚Äã
  - props‚Äã

A component for displaying the main actions for a page. This should be used inside the Page component. It should be used in conjunction with the PageActionBarLeft and PageActionBarRight components as direct children.

The PageActionBarLeft component should be used to display the left content of the action bar.

The PageActionBarRight component should be used to display the right content of the action bar.

**Examples:**

Example 1 (ts):
```ts
function PageActionBar(props: Readonly<{ children: React.ReactNode }>): void
```

Example 2 (ts):
```ts
function PageActionBarLeft(props: Readonly<{ children: React.ReactNode }>): void
```

Example 3 (ts):
```ts
function PageActionBarRight(props: Readonly<{    children: React.ReactNode;    dropdownMenuItems?: InlineDropdownItem[];}>): void
```

---

## RichTextEditorComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/rich-text-editor-component

**Contents:**
- RichTextEditorComponent
- RichTextEditorComponent‚Äã
  - label‚Äã
  - _readonly‚Äã
  - onChange‚Äã
  - onTouch‚Äã
  - constructor‚Äã
  - menuElement‚Äã
  - ngAfterViewInit‚Äã
  - ngOnDestroy‚Äã

A rich text (HTML) editor based on Prosemirror (https://prosemirror.net/)

**Examples:**

Example 1 (html):
```html
<vdr-rich-text-editor    [(ngModel)]="description"    label="Description"></vdr-rich-text-editor>
```

Example 2 (ts):
```ts
class RichTextEditorComponent implements ControlValueAccessor, AfterViewInit, OnDestroy {    @Input() label: string;    @HostBinding('class.readonly')    _readonly = false;    onChange: (val: any) => void;    onTouch: () => void;    constructor(changeDetector: ChangeDetectorRef, prosemirrorService: ProsemirrorService, viewContainerRef: ViewContainerRef, contextMenuService: ContextMenuService)    menuElement: HTMLDivElement | null    ngAfterViewInit() => ;    ngOnDestroy() => ;    registerOnChange(fn: any) => ;    registerOnTouched(fn: any) => ;    setDisabledState(isDisabled: boolean) => ;    
...
```

---

## InitialData

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/initial-data/

**Contents:**
- InitialData
- InitialData‚Äã
  - defaultLanguage‚Äã
  - defaultZone‚Äã
  - roles‚Äã
  - countries‚Äã
  - taxRates‚Äã
  - shippingMethods‚Äã
  - paymentMethods‚Äã
  - collections‚Äã

An object defining initial settings for a new Vendure installation.

**Examples:**

Example 1 (ts):
```ts
interface InitialData {    defaultLanguage: LanguageCode;    defaultZone: string;    roles?: RoleDefinition[];    countries: CountryDefinition[];    taxRates: Array<{ name: string; percentage: number }>;    shippingMethods: Array<{ name: string; price: number; taxRate?: number }>;    paymentMethods: Array<{ name: string; handler: ConfigurableOperationInput }>;    collections: CollectionDefinition[];}
```

---

## Interfaces

**URL:** https://docs.vendure.io/reference/typescript-api/entities/interfaces/

**Contents:**
- Interfaces
- ChannelAware‚Äã
  - channels‚Äã
- SoftDeletable‚Äã
  - deletedAt‚Äã
- Orderable‚Äã
  - position‚Äã
- Taggable‚Äã
  - tags‚Äã
- Translatable‚Äã

Entities which can be assigned to Channels should implement this interface.

Entities which can be soft deleted should implement this interface.

Entities which can be ordered relative to their siblings in a list.

Entities which can have Tags applied to them.

Entities which have localizable string properties should implement this type.

**Examples:**

Example 1 (ts):
```ts
interface ChannelAware {    channels: Channel[];}
```

Example 2 (ts):
```ts
interface SoftDeletable {    deletedAt: Date | null;}
```

Example 3 (ts):
```ts
interface Orderable {    position: number;}
```

Example 4 (ts):
```ts
interface Taggable {    tags: Tag[];}
```

---

## TranslatorService

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/translator-service/

**Contents:**
- TranslatorService
- TranslatorService‚Äã
  - constructor‚Äã
  - translate‚Äã

The TranslatorService is used to translate entities into the current language.

**Examples:**

Example 1 (ts):
```ts
import { Injectable } from '@nestjs/common';import { ID, Product, RequestContext, TransactionalConnection, TranslatorService } from '@vendure/core';@Injectable()export class ProductService {    constructor(private connection: TransactionalConnection,                private translator: TranslatorService){}    async findOne(ctx: RequestContext, productId: ID): Promise<Product | undefined> {        const product = await this.connection.findOneInChannel(ctx, Product, productId, ctx.channelId, {            relations: {                 facetValues: {                     facet: true,                 
...
```

Example 2 (ts):
```ts
class TranslatorService {    constructor(configService: ConfigService)    translate(translatable: T, ctx: RequestContext, translatableRelations: DeepTranslatableRelations<T> = []) => ;}
```

---

## StockAllocationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/stock-allocation-strategy

**Contents:**
- StockAllocationStrategy
- StockAllocationStrategy‚Äã
  - shouldAllocateStock‚Äã

This strategy is responsible for deciding at which stage in the order process stock will be allocated.

This is configured via the orderOptions.stockAllocationStrategy property of your VendureConfig.

This method is called whenever an Order transitions from one state to another. If it resolves to true, then stock will be allocated for this order.

**Examples:**

Example 1 (ts):
```ts
interface StockAllocationStrategy extends InjectableStrategy {    shouldAllocateStock(        ctx: RequestContext,        fromState: OrderState,        toState: OrderState,        order: Order,    ): boolean | Promise<boolean>;}
```

---

## FulfillmentHandler

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/fulfillment-handler/

**Contents:**
- FulfillmentHandler
- FulfillmentHandler‚Äã
  - constructor‚Äã
- FulfillmentHandlerConfig‚Äã
  - createFulfillment‚Äã
  - onFulfillmentTransition‚Äã
- CreateFulfillmentFn‚Äã
- CreateFulfillmentResult‚Äã

A FulfillmentHandler is used when creating a new Fulfillment. When the addFulfillmentToOrder mutation is executed, the specified handler will be used and it's createFulfillment method is called. This method may perform async tasks such as calling a 3rd-party shipping API to register a new shipment and receive a tracking code. This data can then be returned and will be incorporated into the created Fulfillment.

If the args property is defined, this means that arguments passed to the addFulfillmentToOrder mutation will be passed through to the createFulfillment method as the last argument.

The configuration object used to instantiate a FulfillmentHandler.

Invoked when the addFulfillmentToOrder mutation is executed with this handler selected.

If an Error is thrown from within this function, no Fulfillment is created and the CreateFulfillmentError result will be returned.

This allows the handler to intercept state transitions of the created Fulfillment. This works much in the same way as the FulfillmentProcess onTransitionStart method (i.e. returning false or string will be interpreted as an error and prevent the state transition), except that it is only invoked on Fulfillments which were created with this particular FulfillmentHandler.

It can be useful e.g. to intercept Fulfillment cancellations and relay that information to a 3rd-party shipping API.

The function called when creating a new Fulfillment

**Examples:**

Example 1 (ts):
```ts
let shipomatic;export const shipomaticFulfillmentHandler = new FulfillmentHandler({  code: 'ship-o-matic',  description: [{    languageCode: LanguageCode.en,    value: 'Generate tracking codes via the Ship-o-matic API'  }],  args: {    preferredService: {      type: 'string',      ui: {        component: 'select-form-input',        options: [          { value: 'first_class' },          { value: 'priority'},          { value: 'standard' },        ],      },    }  },  init: () => {    // some imaginary shipping service    shipomatic = new ShipomaticClient(API_KEY);  },  createFulfillment: async 
...
```

Example 2 (ts):
```ts
class FulfillmentHandler<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: FulfillmentHandlerConfig<T>)}
```

Example 3 (ts):
```ts
interface FulfillmentHandlerConfig<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {    createFulfillment: CreateFulfillmentFn<T>;    onFulfillmentTransition?: OnTransitionStartFn<FulfillmentState, FulfillmentTransitionData>;}
```

Example 4 (ts):
```ts
type CreateFulfillmentFn<T extends ConfigArgs> = (    ctx: RequestContext,    orders: Order[],    lines: OrderLineInput[],    args: ConfigArgValues<T>,) => CreateFulfillmentResult | Promise<CreateFulfillmentResult>
```

---

## MoneyInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/money-input

**Contents:**
- MoneyInput
- MoneyInput‚Äã
  - props‚Äã

A component for displaying a money value. The currency can be specified, but otherwise will be taken from the active channel's default currency.

**Examples:**

Example 1 (ts):
```ts
function MoneyInput(props: Readonly<MoneyInputProps>): void
```

---

## UiDevkitClient

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/ui-devkit-client

**Contents:**
- UiDevkitClient
- setTargetOrigin‚Äã
  - value‚Äã
- getActivatedRoute‚Äã
- graphQlQuery‚Äã
  - document‚Äã
  - variables‚Äã
  - fetchPolicy‚Äã
- graphQlMutation‚Äã
  - document‚Äã

Set the window.postMessage API targetOrigin. The Vendure ui-devkit uses the postMessage API to enable cross-frame and cross-origin communication between the ui extension code and the Admin UI app. The targetOrigin is a security feature intended to provide control over where messages are sent.

Retrieves information about the current route of the host application, since it is not possible to otherwise get this information from within the child iframe.

Perform a GraphQL query and returns either an Observable or a Promise of the result.

Perform a GraphQL mutation and returns either an Observable or a Promise of the result.

Display a toast notification.

**Examples:**

Example 1 (ts):
```ts
function setTargetOrigin(value: string): void
```

Example 2 (ts):
```ts
import { getActivatedRoute } from '@vendure/ui-devkit';const route = await getActivatedRoute();const slug = route.params.slug;
```

Example 3 (ts):
```ts
function getActivatedRoute(): Promise<ActiveRouteData>
```

Example 4 (ts):
```ts
import { graphQlQuery } from '@vendure/ui-devkit';const productList = await graphQlQuery(`  query GetProducts($skip: Int, $take: Int) {      products(options: { skip: $skip, take: $take }) {          items { id, name, enabled },          totalItems      }  }`, {    skip: 0,    take: 10,  }).then(data => data.products);
```

---

## Custom History Entry Components

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-history-entry-components/

**Contents:**
- Custom History Entry Components
- üìÑÔ∏è CustomerHistoryEntryComponent
- üìÑÔ∏è HistoryEntryComponent
- üìÑÔ∏è HistoryEntryConfig
- üìÑÔ∏è OrderHistoryEntryComponent
- üìÑÔ∏è RegisterHistoryEntryComponent

CustomerHistoryEntryComponent

HistoryEntryComponent

OrderHistoryEntryComponent

registerHistoryEntryComponent

---

## Allow Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/allow-decorator

**Contents:**
- Allow Decorator
- Allow‚Äã
- Allow and Sessions‚Äã

Attaches metadata to the resolver defining which permissions are required to execute the operation, using one or more Permission values.

In a GraphQL context, it can be applied to top-level queries and mutations as well as field resolvers.

For REST controllers, it can be applied to route handler.

The @Allow() decorator is closely linked to the way Vendure manages sessions. For any operation or route that is decorated with @Allow(), there must be an authenticated session in progress, which would have been created during a prior authentication step.

The exception to this is when the operation is decorated with @Allow(Permission.Owner). This is a special permission which is designed to give access to certain resources to potentially un-authenticated users. For this reason, any operation decorated with this permission will always have an anonymous session created if no session is currently in progress.

For more information see Understanding Permission.Owner.

**Examples:**

Example 1 (ts):
```ts
@Allow(Permission.SuperAdmin) @Query() getAdministrators() {     // ... }
```

---

## FormField

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/form-field

**Contents:**
- FormField
- FormField‚Äã
  - props‚Äã

A wrapper around form fields which provides a label, tooltip and error message.

**Examples:**

Example 1 (ts):
```ts
import { FormField } from '@vendure/admin-ui/react';export function MyReactComponent() {    return (       <FormField label="My field" tooltip="This is a tooltip" invalid errorMessage="This field is invalid">           <input type="text" />       </FormField>    );}
```

Example 2 (ts):
```ts
function FormField(props: PropsWithChildren<{        for?: string;        label?: string;        tooltip?: string;        invalid?: boolean;        errorMessage?: string;    }>): void
```

---

## Refund

**URL:** https://docs.vendure.io/reference/typescript-api/entities/refund

**Contents:**
- Refund
- Refund‚Äã
  - constructor‚Äã
  - items‚Äã
  - shipping‚Äã
  - adjustment‚Äã
  - total‚Äã
  - method‚Äã
  - reason‚Äã
  - state‚Äã

A refund the belongs to an order

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Refund extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<Refund>)    @Money() items: number;    @Money() shipping: number;    @Money() adjustment: number;    @Money() total: number;    @Column() method: string;    @Column({ nullable: true }) reason: string;    @Column('varchar') state: RefundState;    @Column({ nullable: true }) transactionId: string;    @OneToMany(type => RefundLine, line => line.refund)    @JoinTable()    lines: RefundLine[];    @Index()    @ManyToOne(type => Payment, payment => payment.refunds)    @JoinColumn()    payment: Payment; 
...
```

---

## CustomFields

**URL:** https://docs.vendure.io/reference/typescript-api/custom-fields/

**Contents:**
- CustomFields
- CustomFields‚Äã

Most entities can have additional fields added to them by defining an array of CustomFieldConfigobjects on against the corresponding key.

**Examples:**

Example 1 (ts):
```ts
bootstrap({    // ...    customFields: {        Product: [            { name: 'infoUrl', type: 'string' },            { name: 'downloadable', type: 'boolean', defaultValue: false },            { name: 'shortName', type: 'localeString' },        ],        User: [            { name: 'socialLoginToken', type: 'string', public: false },        ],    },})
```

Example 2 (ts):
```ts
type CustomFields = {    Address?: CustomFieldConfig[];    Administrator?: CustomFieldConfig[];    Asset?: CustomFieldConfig[];    Channel?: CustomFieldConfig[];    Collection?: CustomFieldConfig[];    Customer?: CustomFieldConfig[];    CustomerGroup?: CustomFieldConfig[];    Facet?: CustomFieldConfig[];    FacetValue?: CustomFieldConfig[];    Fulfillment?: CustomFieldConfig[];    GlobalSettings?: CustomFieldConfig[];    HistoryEntry?: CustomFieldConfig[];    Order?: CustomFieldConfig[];    OrderLine?: CustomFieldConfig[];    Payment?: CustomFieldConfig[];    PaymentMethod?: CustomFieldConfig[
...
```

---

## ActiveOrderService

**URL:** https://docs.vendure.io/reference/typescript-api/orders/active-order-service

**Contents:**
- ActiveOrderService
- ActiveOrderService‚Äã
  - constructor‚Äã
  - getOrderFromContext‚Äã
  - getOrderFromContext‚Äã
  - getOrderFromContext‚Äã
  - getActiveOrder‚Äã
  - getActiveOrder‚Äã
  - getActiveOrder‚Äã

This helper class is used to get a reference to the active Order from the current RequestContext.

Gets the active Order object from the current Session. Optionally can create a new Order if no active Order exists.

Intended to be used at the Resolver layer for those resolvers that depend upon an active Order being present.

Retrieves the active Order based on the configured ActiveOrderStrategy.

**Examples:**

Example 1 (ts):
```ts
class ActiveOrderService {    constructor(sessionService: SessionService, orderService: OrderService, connection: TransactionalConnection, configService: ConfigService)    getOrderFromContext(ctx: RequestContext) => Promise<Order | undefined>;    getOrderFromContext(ctx: RequestContext, createIfNotExists: true) => Promise<Order>;    getOrderFromContext(ctx: RequestContext, createIfNotExists:  = false) => Promise<Order | undefined>;    getActiveOrder(ctx: RequestContext, input: { [strategyName: string]: any } | undefined) => Promise<Order | undefined>;    getActiveOrder(ctx: RequestContext, inp
...
```

---

## LocaleLanguageNamePipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/locale-language-name-pipe

**Contents:**
- LocaleLanguageNamePipe
- LocaleLanguageNamePipe‚Äã
  - constructor‚Äã
  - transform‚Äã

Displays a human-readable name for a given ISO 639-1 language code.

Extends: LocaleBasePipe

Implements: PipeTransform

**Examples:**

Example 1 (html):
```html
{{ 'zh_Hant' | localeLanguageName }}
```

Example 2 (ts):
```ts
class LocaleLanguageNamePipe extends LocaleBasePipe implements PipeTransform {    constructor(dataService?: DataService, changeDetectorRef?: ChangeDetectorRef)    transform(value: any, locale?: unknown) => string;}
```

---

## I18nService

**URL:** https://docs.vendure.io/reference/typescript-api/common/i18n-service/

**Contents:**
- I18nService
- I18nService‚Äã
  - addTranslationFile‚Äã
  - addTranslation‚Äã
- VendureTranslationResources‚Äã
  - error‚Äã
  - errorResult‚Äã
  - message‚Äã

Add a I18n translation by json file

Add a I18n translation (key-value) resource

I18n resources used for translations

**Examples:**

Example 1 (ts):
```ts
class I18nService implements OnModuleInit {    addTranslationFile(langKey: string, filePath: string) => void;    addTranslation(langKey: string, resources: VendureTranslationResources | any) => void;}
```

Example 2 (ts):
```ts
interface VendureTranslationResources {    error: any;    errorResult: any;    message: any;}
```

---

## Zone

**URL:** https://docs.vendure.io/reference/typescript-api/entities/zone

**Contents:**
- Zone
- Zone‚Äã
  - constructor‚Äã
  - name‚Äã
  - members‚Äã
  - customFields‚Äã
  - defaultShippingZoneChannels‚Äã
  - defaultTaxZoneChannels‚Äã
  - taxRates‚Äã

A Zone is a grouping of one or more Country entities. It is used for calculating applicable shipping and taxes.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Zone extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<Zone>)    @Column() name: string;    @ManyToMany(type => Region)    @JoinTable()    members: Region[];    @Column(type => CustomZoneFields)    customFields: CustomZoneFields;    @OneToMany(type => Channel, country => country.defaultShippingZone)    defaultShippingZoneChannels: Channel[];    @OneToMany(type => Channel, country => country.defaultTaxZone)    defaultTaxZoneChannels: Channel[];    @OneToMany(type => TaxRate, taxRate => taxRate.zone)    taxRates: TaxRate[];}
```

---

## RichTextInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/rich-text-input

**Contents:**
- RichTextInput
- RichTextInput‚Äã
  - props‚Äã

A component for displaying a rich text editor. Internally uses ProseMirror (rich text editor) under the hood.

**Examples:**

Example 1 (ts):
```ts
function RichTextInput(props: Readonly<DashboardFormComponentProps>): void
```

---

## ZoneService

**URL:** https://docs.vendure.io/reference/typescript-api/services/zone-service

**Contents:**
- ZoneService
- ZoneService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - getAllWithMembers‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã
  - addMembersToZone‚Äã

Contains methods relating to Zone entities.

**Examples:**

Example 1 (ts):
```ts
class ZoneService {    constructor(connection: TransactionalConnection, configService: ConfigService, eventBus: EventBus, translator: TranslatorService, listQueryBuilder: ListQueryBuilder)    findAll(ctx: RequestContext, options?: ListQueryOptions<Zone>) => Promise<PaginatedList<Zone>>;    findOne(ctx: RequestContext, zoneId: ID) => Promise<Zone | undefined>;    getAllWithMembers(ctx: RequestContext) => Promise<Zone[]>;    create(ctx: RequestContext, input: CreateZoneInput) => Promise<Zone>;    update(ctx: RequestContext, input: UpdateZoneInput) => Promise<Zone>;    delete(ctx: RequestContext,
...
```

---

## LocaleRegionNamePipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/locale-region-name-pipe

**Contents:**
- LocaleRegionNamePipe
- LocaleRegionNamePipe‚Äã
  - constructor‚Äã
  - transform‚Äã

Displays a human-readable name for a given region.

Extends: LocaleBasePipe

Implements: PipeTransform

**Examples:**

Example 1 (html):
```html
{{ 'GB' | localeRegionName }}
```

Example 2 (ts):
```ts
class LocaleRegionNamePipe extends LocaleBasePipe implements PipeTransform {    constructor(dataService?: DataService, changeDetectorRef?: ChangeDetectorRef)    transform(value: any, locale?: unknown) => string;}
```

---

## Permission

**URL:** https://docs.vendure.io/reference/typescript-api/common/permission/

**Contents:**
- Permission
- Permission‚Äã
- Understanding Permission.Owner‚Äã

Permissions for administrators and customers. Used to control access to GraphQL resolvers via the Allow decorator.

Permission.Owner is a special permission which is used in some Vendure resolvers to indicate that that resolver should only be accessible to the "owner" of that resource.

For example, the Shop API activeCustomer query resolver should only return the Customer object for the "owner" of that Customer, i.e. based on the activeUserId of the current session. As a result, the resolver code looks like this:

Here we can see that the "ownership" must be enforced by custom logic inside the resolver. Since "ownership" cannot be defined generally nor statically encoded at build-time, any resolvers using Permission.Owner must include logic to enforce that only the owner of the resource has access. If not, then it is the equivalent of using Permission.Public.

**Examples:**

Example 1 (typescript):
```typescript
@Query()@Allow(Permission.Owner)async activeCustomer(@Ctx() ctx: RequestContext): Promise<Customer | undefined> {  const userId = ctx.activeUserId;  if (userId) {    return this.customerService.findOneByUserId(ctx, userId);  }}
```

Example 2 (ts):
```ts
enum Permission {    Authenticated = 'Authenticated'    CreateAdministrator = 'CreateAdministrator'    CreateAsset = 'CreateAsset'    CreateCatalog = 'CreateCatalog'    CreateChannel = 'CreateChannel'    CreateCollection = 'CreateCollection'    CreateCountry = 'CreateCountry'    CreateCustomer = 'CreateCustomer'    CreateCustomerGroup = 'CreateCustomerGroup'    CreateFacet = 'CreateFacet'    CreateOrder = 'CreateOrder'    CreatePaymentMethod = 'CreatePaymentMethod'    CreateProduct = 'CreateProduct'    CreatePromotion = 'CreatePromotion'    CreateSeller = 'CreateSeller'    CreateSettings = 'Cr
...
```

---

## IfMultichannelDirective

**URL:** https://docs.vendure.io/reference/admin-ui-api/directives/if-multichannel-directive

**Contents:**
- IfMultichannelDirective
- IfMultichannelDirective‚Äã
  - constructor‚Äã

Structural directive that displays the given element if the Vendure instance has multiple channels configured.

**Examples:**

Example 1 (html):
```html
<div *vdrIfMultichannel class="channel-selector">  <!-- ... --></ng-container>
```

Example 2 (ts):
```ts
class IfMultichannelDirective extends IfDirectiveBase<[]> {    constructor(_viewContainer: ViewContainerRef, templateRef: TemplateRef<any>, dataService: DataService)}
```

---

## Plugin

**URL:** https://docs.vendure.io/reference/typescript-api/plugin/

**Contents:**
- Plugin
- üìÑÔ∏è PluginCommonModule
- üìÑÔ∏è Plugin Utilities
- üìÑÔ∏è VendurePluginMetadata
- üìÑÔ∏è VendurePlugin

VendurePluginMetadata

---

## TaxRateService

**URL:** https://docs.vendure.io/reference/typescript-api/services/tax-rate-service

**Contents:**
- TaxRateService
- TaxRateService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã
  - getApplicableTaxRate‚Äã

Contains methods relating to TaxRate entities.

Returns the applicable TaxRate based on the specified Zone and TaxCategory. Used when calculating Order prices.

**Examples:**

Example 1 (ts):
```ts
class TaxRateService {    constructor(connection: TransactionalConnection, eventBus: EventBus, listQueryBuilder: ListQueryBuilder, configService: ConfigService, customFieldRelationService: CustomFieldRelationService)    findAll(ctx: RequestContext, options?: ListQueryOptions<TaxRate>, relations?: RelationPaths<TaxRate>) => Promise<PaginatedList<TaxRate>>;    findOne(ctx: RequestContext, taxRateId: ID, relations?: RelationPaths<TaxRate>) => Promise<TaxRate | undefined>;    create(ctx: RequestContext, input: CreateTaxRateInput) => Promise<TaxRate>;    update(ctx: RequestContext, input: UpdateTax
...
```

---

## TestConfig

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-config/

**Contents:**
- TestConfig
- testConfig‚Äã
- Logging‚Äã

A VendureConfig object used for e2e tests. This configuration uses sqljs as the database and configures some special settings which are optimized for e2e tests:

By default, the testConfig does not output any log messages. This is most desirable to keep a clean CI output. However, for debugging purposes, it can make it hard to figure out why tests fail.

You can enable default logging behaviour with the environment variable LOG:

**Examples:**

Example 1 (text):
```text
LOG=true yarn e2e
```

---

## AddNavMenuSection

**URL:** https://docs.vendure.io/reference/admin-ui-api/nav-menu/add-nav-menu-section

**Contents:**
- AddNavMenuSection
- addNavMenuSection‚Äã
  - config‚Äã
  - before‚Äã

Add a section to the main nav menu. Providing the before argument will move the section before any existing section with the specified id. If omitted (or if the id is not found) the section will be appended to the existing set of sections. This should be used in the NgModule providers array of your ui extension module.

**Examples:**

Example 1 (ts):
```ts
import { addNavMenuSection } from '@vendure/admin-ui/core';export default [    addNavMenuSection({        id: 'reports',        label: 'Reports',        items: [{            // ...        }],    },    'settings'),];
```

Example 2 (ts):
```ts
function addNavMenuSection(config: NavMenuSection, before?: string): void
```

---

## CustomerGroup

**URL:** https://docs.vendure.io/reference/typescript-api/entities/customer-group/

**Contents:**
- CustomerGroup
- CustomerGroup‚Äã
  - constructor‚Äã
  - name‚Äã
  - customers‚Äã
  - customFields‚Äã
  - taxRates‚Äã

A grouping of Customers which enables features such as group-based promotions or tax rules.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class CustomerGroup extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<CustomerGroup>)    @Column() name: string;    @ManyToMany(type => Customer, customer => customer.groups)    customers: Customer[];    @Column(type => CustomCustomerGroupFields)    customFields: CustomCustomerGroupFields;    @OneToMany(type => TaxRate, taxRate => taxRate.zone)    taxRates: TaxRate[];}
```

---

## StockLevelService

**URL:** https://docs.vendure.io/reference/typescript-api/services/stock-level-service

**Contents:**
- StockLevelService
- StockLevelService‚Äã
  - constructor‚Äã
  - getStockLevel‚Äã
  - getStockLevelsForVariant‚Äã
  - getAvailableStock‚Äã
  - updateStockOnHandForLocation‚Äã
  - updateStockAllocatedForLocation‚Äã

The StockLevelService is responsible for managing the stock levels of ProductVariants. Whenever you need to adjust the stockOnHand or stockAllocated for a ProductVariant, you should use this service.

Returns the StockLevel for the given ProductVariant and StockLocation.

Returns the available stock (on hand and allocated) for the given ProductVariant. This is determined by the configured StockLocationStrategy.

Updates the stockOnHand for the given ProductVariant and StockLocation.

Updates the stockAllocated for the given ProductVariant and StockLocation.

**Examples:**

Example 1 (ts):
```ts
class StockLevelService {    constructor(connection: TransactionalConnection, stockLocationService: StockLocationService, configService: ConfigService)    getStockLevel(ctx: RequestContext, productVariantId: ID, stockLocationId: ID) => Promise<StockLevel>;    getStockLevelsForVariant(ctx: RequestContext, productVariantId: ID) => Promise<StockLevel[]>;    getAvailableStock(ctx: RequestContext, productVariantId: ID) => Promise<AvailableStock>;    updateStockOnHandForLocation(ctx: RequestContext, productVariantId: ID, stockLocationId: ID, change: number) => ;    updateStockAllocatedForLocation(ct
...
```

---

## Common

**URL:** https://docs.vendure.io/reference/typescript-api/common/

**Contents:**
- Common
- üóÉÔ∏è Admin Ui
- üìÑÔ∏è AsyncQueue
- üìÑÔ∏è Bootstrap
- üìÑÔ∏è CurrencyCode
- üìÑÔ∏è EntityRelationPaths
- üìÑÔ∏è I18nService
- üìÑÔ∏è ID
- üìÑÔ∏è InjectableStrategy
- üìÑÔ∏è Injector

PriceCalculationResult

---

## JobQueueService

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job-queue-service/

**Contents:**
- JobQueueService
- JobQueueService‚Äã
  - constructor‚Äã
  - createQueue‚Äã
  - start‚Äã
  - addBuffer‚Äã
  - removeBuffer‚Äã
  - bufferSize‚Äã
  - flush‚Äã
  - getJobQueues‚Äã

The JobQueueService is used to create new JobQueue instances and access existing jobs.

Configures and creates a new JobQueue instance.

Adds a JobBuffer, which will make it active and begin collecting jobs to buffer.

Removes a JobBuffer, prevent it from collecting and buffering any subsequent jobs.

Returns an object containing the number of buffered jobs arranged by bufferId. This can be used to decide whether a particular buffer has any jobs to flush.

Passing in JobBuffer instances or ids limits the results to the specified JobBuffers. If no argument is passed, sizes will be returned for all JobBuffers.

Flushes the specified buffers, which means that the buffer is cleared and the jobs get sent to the job queue for processing. Before sending the jobs to the job queue, they will be passed through each JobBuffer's reduce() method, which is can be used to optimize the amount of work to be done by e.g. de-duplicating identical jobs or aggregating data over the collected jobs.

Passing in JobBuffer instances or ids limits the action to the specified JobBuffers. If no argument is passed, all JobBuffers will be flushed.

Returns an array of all Jobs which were added to the job queue.

Returns an array of { name: string; running: boolean; } for each registered JobQueue.

**Examples:**

Example 1 (ts):
```ts
// A service which transcodes video filesclass VideoTranscoderService {  private jobQueue: JobQueue<{ videoId: string; }>;  async onModuleInit() {    // The JobQueue is created on initialization    this.jobQueue = await this.jobQueueService.createQueue({      name: 'transcode-video',      process: async job => {        return await this.transcodeVideo(job.data.videoId);      },    });  }  addToTranscodeQueue(videoId: string) {    this.jobQueue.add({ videoId, })  }  private async transcodeVideo(videoId: string) {    // e.g. call some external transcoding service  }}
```

Example 2 (ts):
```ts
class JobQueueService implements OnModuleDestroy {    constructor(configService: ConfigService, jobBufferService: JobBufferService)    createQueue(options: CreateQueueOptions<Data>) => Promise<JobQueue<Data>>;    start() => Promise<void>;    addBuffer(buffer: JobBuffer<any>) => ;    removeBuffer(buffer: JobBuffer<any>) => ;    bufferSize(forBuffers: Array<JobBuffer<any> | string>) => Promise<{ [bufferId: string]: number }>;    flush(forBuffers: Array<JobBuffer<any> | string>) => Promise<Job[]>;    getJobQueues() => GraphQlJobQueue[];}
```

Example 3 (ts):
```ts
const sizes = await this.jobQueueService.bufferSize('buffer-1', 'buffer-2');// sizes = { 'buffer-1': 12, 'buffer-2': 3 }
```

---

## ImageTransformMode

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/image-transform-mode

**Contents:**
- ImageTransformMode
- ImageTransformMode‚Äã

Specifies the way in which an asset preview image will be resized to fit in the proscribed dimensions:

**Examples:**

Example 1 (ts):
```ts
type ImageTransformMode = 'crop' | 'resize'
```

---

## TaxCategory

**URL:** https://docs.vendure.io/reference/typescript-api/entities/tax-category/

**Contents:**
- TaxCategory
- TaxCategory‚Äã
  - constructor‚Äã
  - name‚Äã
  - isDefault‚Äã
  - customFields‚Äã
  - productVariants‚Äã
  - taxRates‚Äã

A TaxCategory defines what type of taxes to apply to a ProductVariant.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class TaxCategory extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<TaxCategory>)    @Column() name: string;    @Column({ default: false }) isDefault: boolean;    @Column(type => CustomTaxCategoryFields)    customFields: CustomTaxCategoryFields;    @OneToMany(type => ProductVariant, productVariant => productVariant.taxCategory)    productVariants: ProductVariant[];    @OneToMany(type => TaxRate, taxRate => taxRate.category)    taxRates: TaxRate[];}
```

---

## RefundProcess

**URL:** https://docs.vendure.io/reference/typescript-api/payment/refund-process

**Contents:**
- RefundProcess
- RefundProcess‚Äã
  - transitions‚Äã
  - onTransitionStart‚Äã
  - onTransitionEnd‚Äã
  - onTransitionError‚Äã

A RefundProcess is used to define the way the refund process works as in: what states a Refund can be in, and how it may transition from one state to another. Using the onTransitionStart() hook, a RefundProcess can perform checks before allowing a state transition to occur, and the onTransitionEnd() hook allows logic to be executed after a state change.

For detailed description of the interface members, see the StateMachineConfig docs.

**Examples:**

Example 1 (ts):
```ts
interface RefundProcess<State extends keyof CustomRefundStates | string> extends InjectableStrategy {    transitions?: Transitions<State, State | RefundState> & Partial<Transitions<RefundState | State>>;    onTransitionStart?: OnTransitionStartFn<State | RefundState, RefundTransitionData>;    onTransitionEnd?: OnTransitionEndFn<State | RefundState, RefundTransitionData>;    onTransitionError?: OnTransitionErrorFn<State | RefundState>;}
```

---

## UseDetailComponentData

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-detail-component-data

**Contents:**
- UseDetailComponentData
- useDetailComponentData‚Äã

Provides the data available to React-based CustomDetailComponents.

**Examples:**

Example 1 (ts):
```ts
import { Card, useDetailComponentData } from '@vendure/admin-ui/react';import React from 'react';export function CustomDetailComponent(props: any) {    const { entity, detailForm } = useDetailComponentData();    const updateName = () => {        detailForm.get('name')?.setValue('New name');        detailForm.markAsDirty();    };    return (        <Card title={'Custom Detail Component'}>            <button className="button" onClick={updateName}>                Update name            </button>            <pre>{JSON.stringify(entity, null, 2)}</pre>        </Card>    );}
```

Example 2 (ts):
```ts
function useDetailComponentData<T = any>(): void
```

---

## Tag

**URL:** https://docs.vendure.io/reference/typescript-api/entities/tag

**Contents:**
- Tag
- Tag‚Äã
  - constructor‚Äã
  - value‚Äã

A tag is an arbitrary label which can be applied to certain entities. It is used to help organize and filter those entities.

**Examples:**

Example 1 (ts):
```ts
class Tag extends VendureEntity {    constructor(input?: DeepPartial<Tag>)    @Column()    value: string;}
```

---

## ShippingEligibilityChecker

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-eligibility-checker/

**Contents:**
- ShippingEligibilityChecker
- ShippingEligibilityChecker‚Äã
  - constructor‚Äã
  - init‚Äã
  - toJSON‚Äã

The ShippingEligibilityChecker class is used to check whether an order qualifies for a given ShippingMethod.

**Examples:**

Example 1 (ts):
```ts
const minOrderTotalEligibilityChecker = new ShippingEligibilityChecker({    code: 'min-order-total-eligibility-checker',    description: [{ languageCode: LanguageCode.en, value: 'Checks that the order total is above some minimum value' }],    args: {        orderMinimum: { type: 'int', ui: { component: 'currency-form-input' } },    },    check: (ctx, order, args) => {        return order.totalWithTax >= args.orderMinimum;    },});
```

Example 2 (ts):
```ts
class ShippingEligibilityChecker<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: ShippingEligibilityCheckerConfig<T>)    init(injector: Injector) => ;    toJSON() => ;}
```

---

## AlertConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/alerts/alert-config

**Contents:**
- AlertConfig
- AlertConfig‚Äã
  - id‚Äã
  - check‚Äã
  - recheck‚Äã
  - isAlert‚Äã
  - action‚Äã
  - label‚Äã
  - requiredPermissions‚Äã

A configuration object for an Admin UI alert.

A unique identifier for the alert.

A function which is gets the data used to determine whether the alert should be shown. Typically, this function will query the server or some other remote data source.

This function will be called once when the Admin UI app bootstraps, and can be also set to run at regular intervals by setting the recheckIntervalMs property.

A function which returns an Observable which is used to determine when to re-run the check function. Whenever the observable emits, the check function will be called again.

A basic time-interval-based recheck can be achieved by using the interval function from RxJS.

If this is not set, the check function will only be called once when the Admin UI app bootstraps.

A function which determines whether the alert should be shown based on the data returned by the check function.

A function which is called when the alert is clicked in the Admin UI.

A function which returns the text used in the UI to describe the alert.

A list of permissions which the current Administrator must have in order. If the current Administrator does not have these permissions, none of the other alert functions will be called.

**Examples:**

Example 1 (ts):
```ts
interface AlertConfig<T = any> {    id: string;    check: (context: AlertContext) => T | Promise<T> | Observable<T>;    recheck?: (context: AlertContext) => Observable<any>;    isAlert: (data: T, context: AlertContext) => boolean;    action: (data: T, context: AlertContext) => void;    label: (        data: T,        context: AlertContext,    ) => { text: string; translationVars?: { [key: string]: string | number } };    requiredPermissions?: Permission[];}
```

Example 2 (ts):
```ts
import { interval } from 'rxjs';// ...recheck: () => interval(60_000)
```

---

## WidgetLayoutDefinition

**URL:** https://docs.vendure.io/reference/admin-ui-api/dashboard-widgets/widget-layout-definition

**Contents:**
- WidgetLayoutDefinition
- WidgetLayoutDefinition‚Äã

A configuration object for the default dashboard widget layout.

**Examples:**

Example 1 (ts):
```ts
type WidgetLayoutDefinition = Array<{ id: string; width: DashboardWidgetWidth }>
```

---

## PaymentMethodHandler

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-method-handler/

**Contents:**
- PaymentMethodHandler
- PaymentMethodHandler‚Äã
  - constructor‚Äã

A PaymentMethodHandler contains the code which is used to generate a Payment when a call to the addPaymentToOrder mutation is made. It contains any necessary steps of interfacing with a third-party payment gateway before the Payment is created and can also define actions to fire when the state of the payment is changed.

PaymentMethodHandlers are instantiated using a PaymentMethodConfigOptions object, which configures the business logic used to create, settle and refund payments.

**Examples:**

Example 1 (ts):
```ts
import { PaymentMethodHandler, CreatePaymentResult, SettlePaymentResult, LanguageCode } from '@vendure/core';// A mock 3rd-party payment SDKimport gripeSDK from 'gripe';export const examplePaymentHandler = new PaymentMethodHandler({  code: 'example-payment-provider',  description: [{    languageCode: LanguageCode.en,    value: 'Example Payment Provider',  }],  args: {    apiKey: { type: 'string' },  },  createPayment: async (ctx, order, amount, args, metadata): Promise<CreatePaymentResult> => {    try {      const result = await gripeSDK.charges.create({        amount,        apiKey: args.apiK
...
```

Example 2 (ts):
```ts
class PaymentMethodHandler<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: PaymentMethodConfigOptions<T>)}
```

---

## RegisterRouteComponentOptions

**URL:** https://docs.vendure.io/reference/admin-ui-api/routes/register-route-component-options

**Contents:**
- RegisterRouteComponentOptions
- RegisterRouteComponentOptions‚Äã

Configuration for a route component.

**Examples:**

Example 1 (ts):
```ts
type RegisterRouteComponentOptions<Component extends any | BaseDetailComponent<Entity>, Entity extends { id: string; updatedAt?: string }, T extends DocumentNode | TypedDocumentNode<any, { id: string }>, Field extends keyof ResultOf<T>, R extends Field> = {    component: Type<Component> | Component;    title?: string;    locationId?: string;    description?: string;    breadcrumb?: BreadcrumbValue;    path?: string;    query?: T;    getBreadcrumbs?: (entity: Exclude<ResultOf<T>[R], 'Query'>) => BreadcrumbValue;    entityKey?: Component extends BaseDetailComponent<any> ? R : string;    variable
...
```

---

## RegisterInitializer

**URL:** https://docs.vendure.io/reference/typescript-api/testing/register-initializer

**Contents:**
- RegisterInitializer
- registerInitializer‚Äã
  - type‚Äã
  - initializer‚Äã

Registers a TestDbInitializer for the given database type. Should be called before invoking createTestEnvironment.

**Examples:**

Example 1 (ts):
```ts
function registerInitializer(type: DataSourceOptions['type'], initializer: TestDbInitializer<any>): void
```

---

## DataTable

**URL:** https://docs.vendure.io/reference/dashboard/list-views/data-table

**Contents:**
- DataTable
- DataTable‚Äã
  - props‚Äã
- DataTableProps‚Äã
  - children‚Äã
  - columns‚Äã
  - data‚Äã
  - totalItems‚Äã
  - isLoading‚Äã
  - page‚Äã

A data table which includes sorting, filtering, pagination, bulk actions, column controls etc.

This is the building block of all data tables in the Dashboard.

Props for configuring the DataTable.

This property allows full control over all features of TanStack Table when needed.

Allows you to define custom display components for specific columns in data tables. The pageId is already defined in the data table extension, so only the column name is needed.

The name of the column where this display component should be used.

The React component that will be rendered as the display. It should accept value and other standard display props.

**Examples:**

Example 1 (ts):
```ts
function DataTable<TData>(props: Readonly<DataTableProps<TData>>): void
```

Example 2 (ts):
```ts
interface DataTableProps<TData> {    children?: React.ReactNode;    columns: ColumnDef<TData, any>[];    data: TData[];    totalItems: number;    isLoading?: boolean;    page?: number;    itemsPerPage?: number;    sorting?: SortingState;    columnFilters?: ColumnFiltersState;    onPageChange?: (table: TableType<TData>, page: number, itemsPerPage: number) => void;    onSortChange?: (table: TableType<TData>, sorting: SortingState) => void;    onFilterChange?: (table: TableType<TData>, columnFilters: ColumnFilter[]) => void;    onColumnVisibilityChange?: (table: TableType<TData>, columnVisibility
...
```

Example 3 (ts):
```ts
interface DashboardDataTableDisplayComponent {    column: string;    component: React.ComponentType<DataDisplayComponentProps<CellContext<any, any>>>;}
```

---

## EmailPluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-plugin-options

**Contents:**
- EmailPluginOptions
- EmailPluginOptions‚Äã
  - templatePath‚Äã
  - templateLoader‚Äã
  - transport‚Äã
  - handlers‚Äã
  - globalTemplateVars‚Äã
  - emailSender‚Äã
  - emailGenerator‚Äã
- GlobalTemplateVarsFn‚Äã

Configuration for the EmailPlugin.

The path to the location of the email templates. In a default Vendure installation, the templates are installed to <project root>/vendure/email/templates.

An optional TemplateLoader which can be used to load templates from a custom location or async service. The default uses the FileBasedTemplateLoader which loads templates from <project root>/vendure/email/templates

Configures how the emails are sent.

An array of EmailEventHandlers which define which Vendure events will trigger emails, and how those emails are generated.

An object containing variables which are made available to all templates. For example, the storefront URL could be defined here and then used in the "email address verification" email. Use the GlobalTemplateVarsFn if you need to retrieve variables from Vendure or plugin services.

An optional allowed EmailSender, used to allow custom implementations of the send functionality while still utilizing the existing emailPlugin functionality.

An optional allowed EmailGenerator, used to allow custom email generation functionality to better match with custom email sending functionality.

Allows you to dynamically load the "globalTemplateVars" key async and access Vendure services to create the object. This is not a requirement. You can also specify a simple static object if your projects doesn't need to access async or dynamic values.

Configuration for running the EmailPlugin in development mode.

The path to which html email files will be saved rather than being sent.

The route to the dev mailbox server.

**Examples:**

Example 1 (ts):
```ts
interface EmailPluginOptions {    templatePath?: string;    templateLoader?: TemplateLoader;    transport:        | EmailTransportOptions        | ((              injector?: Injector,              ctx?: RequestContext,          ) => EmailTransportOptions | Promise<EmailTransportOptions>);    handlers: Array<EmailEventHandler<string, any>>;    globalTemplateVars?: { [key: string]: any } | GlobalTemplateVarsFn;    emailSender?: EmailSender;    emailGenerator?: EmailGenerator;}
```

Example 2 (ts):
```ts
EmailPlugin.init({   globalTemplateVars: async (ctx, injector) => {         const myAsyncService = injector.get(MyAsyncService);         const asyncValue = await myAsyncService.get(ctx);         const channel = ctx.channel;         const { primaryColor } = channel.customFields.theme;         const theme = {             primaryColor,             asyncValue,         };         return theme;     }  [...]})
```

Example 3 (ts):
```ts
type GlobalTemplateVarsFn = (    ctx: RequestContext,    injector: Injector,) => Promise<{ [key: string]: any }>
```

Example 4 (ts):
```ts
interface EmailPluginDevModeOptions extends Omit<EmailPluginOptions, 'transport'> {    devMode: true;    outputPath: string;    route: string;}
```

---

## AssetNamingStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/assets/asset-naming-strategy/

**Contents:**
- AssetNamingStrategy
- AssetNamingStrategy‚Äã
  - generateSourceFileName‚Äã
  - generatePreviewFileName‚Äã

The AssetNamingStrategy determines how file names are generated based on the uploaded source file name, as well as how to handle naming conflicts.

This is configured via the assetOptions.assetNamingStrategy property of your VendureConfig.

Given the original file name of the uploaded file, generate a file name to be stored on the server. Operations like normalization and time-stamping can be performed in this method.

The output will be checked for a naming conflict with an existing file. If a conflict exists, this method will be invoked again with the second argument passed in and a new, unique file name should then be generated. This process will repeat until a unique file name has been returned.

Given the source file name generated in the generateSourceFileName method, this method should generate the file name of the preview image.

The same mechanism of checking for conflicts is used as described above.

**Examples:**

Example 1 (ts):
```ts
interface AssetNamingStrategy extends InjectableStrategy {    generateSourceFileName(ctx: RequestContext, originalFileName: string, conflictFileName?: string): string;    generatePreviewFileName(ctx: RequestContext, sourceFileName: string, conflictFileName?: string): string;}
```

---

## Horizontal scaling

**URL:** https://docs.vendure.io/guides/deployment/horizontal-scaling

**Contents:**
- Horizontal scaling
- Multi-instance configuration‚Äã
- Using Docker or Kubernetes‚Äã
- Using PM2‚Äã

"Horizontal scaling" refers to increasing the performance capacity of your application by running multiple instances.

This type of scaling has two main advantages:

As discussed in the Server resource requirements guide, horizontal scaling can be the most cost-effective way of deploying your Vendure server due to the single-threaded nature of Node.js.

In Vendure, both the server and the worker can be scaled horizontally. Scaling the server will increase the throughput of the GraphQL APIs, whereas scaling the worker can increase the speed with which the job queue is processed by allowing more jobs to be run in parallel.

In order to run Vendure in a multi-instance configuration, there are some important configuration changes you'll need to make. The key consideration in configuring Vendure for this scenario is to ensure that any persistent state is managed externally from the Node process, and is shared by all instances. Namely:

One way of implementing horizontal scaling is to use Docker to wrap your Vendure server & worker in a container, which can then be run as multiple instances.

Some hosting providers allow you to provide a Docker image and will then run multiple instances of that image. Kubernetes can also be used to manage multiple instances of a Docker image.

For a more complete guide, see the Using Docker guide.

PM2 is a process manager which will spawn multiple instances of your server or worker, as well as re-starting any instances that crash. PM2 can be used on VPS hosts to manage multiple instances of Vendure without needing Docker or Kubernetes.

PM2 must be installed on your server:

Your processes can then be run in cluster mode with the following command:

The above command will start a cluster of 4 instances. You can also instruct PM2 to use the maximum number of available CPUs with -i max.

Note that if you are using pm2 inside a Docker container, you should use the pm2-runtime command:

**Examples:**

Example 1 (ts):
```ts
const config: VendureConfig = {  authOptions: {    cookieOptions: {      secret: 'some-secret'    }  }}
```

Example 2 (sh):
```sh
npm install pm2@latest -g
```

Example 3 (sh):
```sh
pm2 start ./dist/index.js -i 4
```

Example 4 (dockerfile):
```dockerfile
# ... your existing Dockerfile configRUN npm install pm2 -gCMD ["pm2-runtime", "app.js", "-i", "max"]
```

---

## SettingsStoreScopeFunction

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/settings-store-scope-function

**Contents:**
- SettingsStoreScopeFunction
- SettingsStoreScopeFunction‚Äã

A function that determines how a settings store entry should be scoped. Returns a string that will be used as the scope key for storage isolation.

**Examples:**

Example 1 (ts):
```ts
// User-specific scopingconst userScope: SettingsStoreScopeFunction = ({ ctx }) => ctx.activeUserId || '';// Channel-specific scopingconst channelScope: SettingsStoreScopeFunction = ({ ctx }) => ctx.channelId || '';// User and channel scopingconst userAndChannelScope: SettingsStoreScopeFunction = ({ ctx }) =>  `${ctx.activeUserId || ''}:${ctx.channelId || ''}`;
```

Example 2 (ts):
```ts
type SettingsStoreScopeFunction = (params: {    key: string;    value?: any;    ctx: RequestContext;}) => string
```

---

## ProcessContext

**URL:** https://docs.vendure.io/reference/typescript-api/common/process-context/

**Contents:**
- ProcessContext
- ProcessContext‚Äã
  - isServer‚Äã
  - isWorker‚Äã

The ProcessContext can be injected into your providers & modules in order to know whether it is being executed in the context of the main Vendure server or the worker.

**Examples:**

Example 1 (ts):
```ts
import { Injectable, OnApplicationBootstrap } from '@nestjs/common';import { ProcessContext } from '@vendure/core';@Injectable()export class MyService implements OnApplicationBootstrap {  constructor(private processContext: ProcessContext) {}  onApplicationBootstrap() {    if (this.processContext.isServer) {      // code which will only execute when running in      // the server process    }  }}
```

Example 2 (ts):
```ts
class ProcessContext {    isServer: boolean    isWorker: boolean}
```

---

## PaymentTransitionData

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-transition-data

**Contents:**
- PaymentTransitionData
- PaymentTransitionData‚Äã
  - ctx‚Äã
  - payment‚Äã
  - order‚Äã

The data which is passed to the onStateTransitionStart function configured when constructing a new PaymentMethodHandler

**Examples:**

Example 1 (ts):
```ts
interface PaymentTransitionData {    ctx: RequestContext;    payment: Payment;    order: Order;}
```

---

## TransactionalConnection

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/transactional-connection/

**Contents:**
- TransactionalConnection
- TransactionalConnection‚Äã
  - constructor‚Äã
  - rawConnection‚Äã
  - getRepository‚Äã
  - getRepository‚Äã
  - getRepository‚Äã
  - withTransaction‚Äã
  - withTransaction‚Äã
  - withTransaction‚Äã

The TransactionalConnection is a wrapper around the TypeORM Connection object which works in conjunction with the Transaction decorator to implement per-request transactions. All services which access the database should use this class rather than the raw TypeORM connection, to ensure that db changes can be easily wrapped in transactions when required.

The service layer does not need to know about the scope of a transaction, as this is covered at the API by the use of the Transaction decorator.

The plain TypeORM Connection object. Should be used carefully as any operations performed with this connection will not be performed within any outer transactions.

Returns a TypeORM repository. Note that when no RequestContext is supplied, the repository will not be aware of any existing transaction. Therefore, calling this method without supplying a RequestContext is discouraged without a deliberate reason.

Returns a TypeORM repository which is bound to any existing transactions. It is recommended to always pass the RequestContext argument when possible, otherwise the queries will be executed outside of any ongoing transactions which have been started by the Transaction decorator.

The options parameter allows specifying additional configurations, such as the replicationMode, which determines whether the repository should interact with the master or replica database.

Returns a TypeORM repository. Depending on the parameters passed, it will either be transaction-aware or not. If RequestContext is provided, the repository is bound to any ongoing transactions. The options parameter allows further customization, such as selecting the replication mode (e.g., 'master').

Allows database operations to be wrapped in a transaction, ensuring that in the event of an error being thrown at any point, the entire transaction will be rolled back and no changes will be saved.

In the context of API requests, you should instead use the Transaction decorator on your resolver or controller method.

On the other hand, for code that does not run in the context of a GraphQL/REST request, this method should be used to protect against non-atomic changes to the data which could leave your data in an inconsistent state.

Such situations include function processed by the JobQueue or stand-alone scripts which make use of Vendure internal services.

If there is already a RequestContext object available, you should pass it in as the first argument in order to create transactional context as

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
class TransactionalConnection {    constructor(dataSource: DataSource, transactionWrapper: TransactionWrapper)    rawConnection: DataSource    getRepository(target: ObjectType<Entity> | EntitySchema<Entity> | string) => Repository<Entity>;    getRepository(ctx: RequestContext | undefined, target: ObjectType<Entity> | EntitySchema<Entity> | string, options?: {            replicationMode?: ReplicationMode;        }) => Repository<Entity>;    getRepository(ctxOrTarget: RequestContext | ObjectType<Entity> | EntitySchema<Entity> | string | undefined, maybeTarget?: ObjectType<Entity> | EntitySchema<
...
```

Example 2 (ts):
```ts
private async transferCredit(outerCtx: RequestContext, fromId: ID, toId: ID, amount: number) {  await this.connection.withTransaction(outerCtx, async ctx => {    // Note you must not use `outerCtx` here, instead use `ctx`. Otherwise, this query    // will be executed outside of transaction    await this.giftCardService.updateCustomerCredit(ctx, fromId, -amount);    await this.connection.getRepository(ctx, GiftCard).update(fromId, { transferred: true })    // If some intermediate logic here throws an Error,    // then all DB transactions will be rolled back and neither Customer's    // credit b
...
```

---

## DefaultFormConfigHash

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/default-form-config-hash

**Contents:**
- DefaultFormConfigHash
- DefaultFormConfigHash‚Äã
  - 'boolean-form-input'‚Äã
  - 'currency-form-input'‚Äã
  - 'customer-group-form-input'‚Äã
  - 'date-form-input'‚Äã
  - 'facet-value-form-input'‚Äã
  - 'json-editor-form-input'‚Äã
  - 'html-editor-form-input'‚Äã
  - 'number-form-input'‚Äã

Used to define the expected arguments for a given default form input component.

**Examples:**

Example 1 (ts):
```ts
type DefaultFormConfigHash = {    'boolean-form-input': Record<string, never>;    'currency-form-input': Record<string, never>;    'customer-group-form-input': Record<string, never>;    'date-form-input': { min?: string; max?: string; yearRange?: number };    'facet-value-form-input': Record<string, never>;    'json-editor-form-input': { height?: string };    'html-editor-form-input': { height?: string };    'number-form-input': { min?: number; max?: number; step?: number; prefix?: string; suffix?: string };    'password-form-input': Record<string, never>;    'product-selector-form-input': Rec
...
```

---

## DefaultStockLocationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/default-stock-location-strategy

**Contents:**
- DefaultStockLocationStrategy
- DefaultStockLocationStrategy‚Äã
  - init‚Äã
  - getAvailableStock‚Äã
  - forAllocation‚Äã

The DefaultStockLocationStrategy was the default implementation of the StockLocationStrategy prior to the introduction of the MultiChannelStockLocationStrategy. It assumes only a single StockLocation and that all stock is allocated from that location. When more than one StockLocation or Channel is used, it will not behave as expected.

**Examples:**

Example 1 (ts):
```ts
class DefaultStockLocationStrategy extends BaseStockLocationStrategy {    init(injector: Injector) => ;    getAvailableStock(ctx: RequestContext, productVariantId: ID, stockLevels: StockLevel[]) => AvailableStock;    forAllocation(ctx: RequestContext, stockLocations: StockLocation[], orderLine: OrderLine, quantity: number) => LocationWithQuantity[] | Promise<LocationWithQuantity[]>;}
```

---

## SlugStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/slug-strategy

**Contents:**
- SlugStrategy
- SlugStrategy‚Äã
  - generate‚Äã

Defines the strategy for generating slugs from input strings. Slugs are URL-friendly versions of text that are commonly used for entity identifiers in URLs.

Generates a slug from the input string.

**Examples:**

Example 1 (ts):
```ts
export class CustomSlugStrategy implements SlugStrategy {  generate(ctx: RequestContext, params: SlugGenerateParams): string {    return params.value      .toLowerCase()      .replace(/[^a-z0-9]+/g, '-')      .replace(/^-+|-+$/g, '');  }}
```

Example 2 (ts):
```ts
interface SlugStrategy extends InjectableStrategy {    generate(ctx: RequestContext, params: SlugGenerateParams): string | Promise<string>;}
```

---

## StockLevel

**URL:** https://docs.vendure.io/reference/typescript-api/entities/stock-level

**Contents:**
- StockLevel
- StockLevel‚Äã
  - constructor‚Äã
  - productVariant‚Äã
  - productVariantId‚Äã
  - stockLocation‚Äã
  - stockLocationId‚Äã
  - stockOnHand‚Äã
  - stockAllocated‚Äã
  - customFields‚Äã

A StockLevel represents the number of a particular ProductVariant which are available at a particular StockLocation.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class StockLevel extends VendureEntity implements HasCustomFields {    constructor(input: DeepPartial<StockLevel>)    @Index()    @ManyToOne(type => ProductVariant, productVariant => productVariant.stockLevels, { onDelete: 'CASCADE' })    productVariant: ProductVariant;    @EntityId()    productVariantId: ID;    @Index()    @ManyToOne(type => StockLocation, { onDelete: 'CASCADE' })    stockLocation: StockLocation;    @EntityId()    stockLocationId: ID;    @Column()    stockOnHand: number;    @Column()    stockAllocated: number;    @Column(type => CustomStockLevelFields)    customFields: Custom
...
```

---

## PubSubPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/job-queue-plugin/pub-sub-plugin

**Contents:**
- PubSubPlugin
- PubSubPlugin‚Äã
- Installation‚Äã
  - init‚Äã

This plugin uses Google Cloud Pub/Sub to implement a job queue strategy for Vendure.

Note: To use this plugin, you need to manually install the @google-cloud/pubsub package:

**Examples:**

Example 1 (shell):
```shell
npm install```ts title="Signature"class PubSubPlugin {    init(options: PubSubOptions) => Type<PubSubPlugin>;}
```

---

## DefaultSessionCacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/default-session-cache-strategy

**Contents:**
- DefaultSessionCacheStrategy
- DefaultSessionCacheStrategy‚Äã
  - cacheService‚Äã
  - constructor‚Äã
  - init‚Äã
  - set‚Äã
  - get‚Äã
  - delete‚Äã
  - clear‚Äã

The default SessionCacheStrategy delegates to the configured CacheStrategy to store the session data. This should be suitable for most use-cases, assuming you select a suitable CacheStrategy

**Examples:**

Example 1 (ts):
```ts
class DefaultSessionCacheStrategy implements SessionCacheStrategy {    protected cacheService: CacheService;    constructor(options?: {            ttl?: number;            cachePrefix?: string;        })    init(injector: Injector) => ;    set(session: CachedSession) => Promise<void>;    get(sessionToken: string) => Promise<CachedSession | undefined>;    delete(sessionToken: string) => void | Promise<void>;    clear() => Promise<void>;}
```

---

## Fulfillment

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/

**Contents:**
- Fulfillment
- üìÑÔ∏è FulfillmentHandler
- üìÑÔ∏è FulfillmentProcess
- üìÑÔ∏è FulfillmentState
- üìÑÔ∏è FulfillmentStates
- üìÑÔ∏è FulfillmentTransitionData

defaultFulfillmentProcess

FulfillmentTransitionData

---

## StockDisplayStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/stock-display-strategy/

**Contents:**
- StockDisplayStrategy
- StockDisplayStrategy‚Äã
  - getStockLevel‚Äã

Defines how the ProductVariant.stockLevel value is obtained. It is usually not desirable to directly expose stock levels over a public API, as this could be considered a leak of sensitive information. However, the storefront will usually want to display some indication of whether a given ProductVariant is in stock.

This is configured via the catalogOptions.stockDisplayStrategy property of your VendureConfig.

Returns a string representing the stock level, which will be used directly in the GraphQL ProductVariant.stockLevel field.

**Examples:**

Example 1 (ts):
```ts
interface StockDisplayStrategy extends InjectableStrategy {    getStockLevel(        ctx: RequestContext,        productVariant: ProductVariant,        saleableStockLevel: number,    ): string | Promise<string>;}
```

---

## Input Objects

**URL:** https://docs.vendure.io/reference/graphql-api/shop/input-types

**Contents:**
- Input Objects
- AddItemInput‚Äã
- AuthenticationInput‚Äã
- BooleanListOperators‚Äã
- BooleanOperators‚Äã
- CollectionFilterParameter‚Äã
- CollectionListOptions‚Äã
- CollectionSortParameter‚Äã
- ConfigArgInput‚Äã
- ConfigurableOperationInput‚Äã

---

## ImageTransformPreset

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/image-transform-preset

**Contents:**
- ImageTransformPreset
- ImageTransformPreset‚Äã
  - name‚Äã
  - width‚Äã
  - height‚Äã
  - mode‚Äã

A configuration option for an image size preset for the AssetServerPlugin.

Presets allow a shorthand way to generate a thumbnail preview of an asset. For example, the built-in "tiny" preset generates a 50px x 50px cropped preview, which can be accessed by appending the string preset=tiny to the asset url:

http://localhost:3000/assets/some-asset.jpg?preset=tiny

http://localhost:3000/assets/some-asset.jpg?w=50&h=50&mode=crop

**Examples:**

Example 1 (ts):
```ts
interface ImageTransformPreset {    name: string;    width: number;    height: number;    mode: ImageTransformMode;}
```

---

## RunMigrations

**URL:** https://docs.vendure.io/reference/typescript-api/migration/run-migrations/

**Contents:**
- RunMigrations
- runMigrations‚Äã
  - userConfig‚Äã

Runs any pending database migrations. See TypeORM migration docs for more information about the underlying migration mechanism.

**Examples:**

Example 1 (ts):
```ts
function runMigrations(userConfig: Partial<VendureConfig>): Promise<string[]>
```

---

## EmailPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin

**Contents:**
- EmailPlugin
- EmailPlugin‚Äã
- High-level description‚Äã
- Installation‚Äã
- Email templates‚Äã
  - Dynamic Email Templates‚Äã
- Customizing templates‚Äã
  - Setting global variables using globalTemplateVars‚Äã
  - Handlebars helpers‚Äã
- Extending the default email handler‚Äã

The EmailPlugin creates and sends transactional emails based on Vendure events. By default, it uses an MJML-based email generator to generate the email body and Nodemailer to send the emails.

Vendure has an internal events system (see EventBus) that allows plugins to subscribe to events. The EmailPlugin is configured with EmailEventHandlers that listen for a specific event and when it is published, the handler defines which template to use to generate the resulting email.

The plugin comes with a set of default handler for the following events:

You can also create your own handler and register them with the plugin - see the EmailEventHandler docs for more details.

yarn add @vendure/email-plugin

npm install @vendure/email-plugin

In the example above, the plugin has been configured to look in <app-root>/static/email/templates for the email template files. If you used @vendure/create to create your application, the templates will have been copied to that location during setup.

If you are installing the EmailPlugin separately, then you'll need to copy the templates manually from node_modules/@vendure/email-plugin/templates to a location of your choice, and then point the templatePath config property at that directory.

Instead of passing a static value to templatePath, use templateLoader to define a template path.

Emails are generated from templates which use MJML syntax. MJML is an open-source HTML-like markup language which makes the task of creating responsive email markup simple. By default, the templates are installed to <project root>/vendure/email/templates and can be freely edited.

Dynamic data such as the recipient's name or order items are specified using Handlebars syntax:

globalTemplateVars is an object that can be passed to the configuration of the Email Plugin with static object variables. You can also pass an async function that will be called with the RequestContext and the Injector so you can access services and e.g. load channel specific theme configurations.

The following helper functions are available for use in email templates:

The defaultEmailHandlers array defines the default handler such as for handling new account registration, order confirmation, password reset etc. These defaults can be extended by adding custom templates for languages other than the default, or even completely new types of emails which respond to any of the available VendureEvents.

A good way to learn how to create your own email handler is to take a look at the source code of the default handlers, which are located in the `default-email-handlers.ts` file.

**Default Email Handlers:**

The `defaultEmailHandlers` array provides built-in handlers for standard Vendure events:
- Order confirmation
- New customer email address verification
- Password reset request
- Email address change request

**Creating Custom Handlers:**

Custom handlers follow the same structure as the defaults, allowing developers to respond to any available VendureEvents.

**Modifying Default Handlers:**

Rather than replacing all defaults, you can import individual handlers and customize them:

```typescript
import {
  orderConfirmationHandler,
  emailVerificationHandler,
  passwordResetHandler,
  emailAddressChangeHandler,
} from '@vendure/email-plugin';
```

**Available Customization Methods:**

Individual handlers support these modifications:
- **setSubject()**: Set a new subject line (e.g., for order confirmation)
- **loadData()**: Fetch additional data via injected services
- **setTemplateVars()**: Define variables passed to email templates

You can chain these methods for sophisticated customizations, such as loading customer data before rendering password reset emails, then pass the modified handlers to `EmailPlugin.init()`.

**Examples:**

Example 1 (ts):
```ts
import { defaultEmailHandlers, EmailPlugin, FileBasedTemplateLoader } from '@vendure/email-plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    EmailPlugin.init({      handler: defaultEmailHandlers,      templateLoader: new FileBasedTemplateLoader(path.join(__dirname, '../static/email/templates')),      transport: {        type: 'smtp',        host: 'smtp.example.com',        port: 587,        auth: {          user: 'username',          pass: 'password',        }      },    }),  ],};
```

Example 2 (ts):
```ts
EmailPlugin.init({   ...,   templateLoader: new FileBasedTemplateLoader(my/order-confirmation/templates)  })
```

Example 3 (html):
```html
<p>Dear {{ order.customer.firstName }} {{ order.customer.lastName }},</p><p>Thank you for your order!</p><mj-table cellpadding="6px">  {{#each order.lines }}    <tr class="order-row">      <td>{{ quantity }} x {{ productVariant.name }}</td>      <td>{{ productVariant.quantity }}</td>      <td>{{ formatMoney totalPrice }}</td>    </tr>  {{/each}}</mj-table>
```

Example 4 (ts):
```ts
EmailPlugin.init({   globalTemplateVars: {     primaryColor: '#FF0000',     fromAddress: 'no-reply@ourstore.com'   }})
```

---

## Service Helpers

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/

**Contents:**
- Service Helpers
- üìÑÔ∏è EntityDuplicatorService
- üìÑÔ∏è OrderCalculator
- üìÑÔ∏è OrderModifier
- üìÑÔ∏è ProductPriceApplicator
- üìÑÔ∏è SlugValidator
- üìÑÔ∏è TranslatableSaver
- üìÑÔ∏è TranslatorService

EntityDuplicatorService

ProductPriceApplicator

---

## ApiOptions

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/api-options

**Contents:**
- ApiOptions
- ApiOptions‚Äã
  - hostname‚Äã
  - port‚Äã
  - adminApiPath‚Äã
  - shopApiPath‚Äã
  - adminApiPlayground‚Äã
  - shopApiPlayground‚Äã
  - adminApiDebug‚Äã
  - shopApiDebug‚Äã

The ApiOptions define how the Vendure GraphQL APIs are exposed, as well as allowing the API layer to be extended with middleware.

Set the hostname of the server. If not set, the server will be available on localhost.

Which port the Vendure server should listen on.

The path to the admin GraphQL API.

The path to the shop GraphQL API.

The playground config to the admin GraphQL API ApolloServer playground.

The playground config to the shop GraphQL API ApolloServer playground.

The debug config to the admin GraphQL API ApolloServer playground.

The debug config to the shop GraphQL API ApolloServer playground.

The maximum number of items that may be returned by a query which returns a PaginatedList response. In other words, this is the upper limit of the take input option.

The maximum number of items that may be returned by a query which returns a PaginatedList response. In other words, this is the upper limit of the take input option.

Custom functions to use as additional validation rules when validating the schema for the admin GraphQL API ApolloServer validation rules.

Custom functions to use as additional validation rules when validating the schema for the shop GraphQL API ApolloServer validation rules.

The name of the property which contains the token of the active channel. This property can be included either in the request header or as a query string.

Set the CORS handling for the server. See the express CORS docs.

Custom Express or NestJS middleware for the server. More information can be found in the Middleware docs.

Set the trust proxy configuration for the server. See the express proxy docs.

Custom ApolloServerPlugins which allow the extension of the Apollo Server, which is the underlying GraphQL server used by Vendure.

Apollo plugins can be used e.g. to perform custom data transformations on incoming operations or outgoing data.

Controls whether introspection of the GraphQL APIs is enabled. For production, it is recommended to disable introspection, since exposing your entire schema can allow an attacker to trivially learn all operations and much more easily find any potentially exploitable queries.

Note: when introspection is disabled, tooling which relies on it for things like autocompletion will not work.

**Examples:**

Example 1 (ts):
```ts
interface ApiOptions {    hostname?: string;    port: number;    adminApiPath?: string;    shopApiPath?: string;    adminApiPlayground?: boolean | RenderPageOptions;    shopApiPlayground?: boolean | RenderPageOptions;    adminApiDebug?: boolean;    shopApiDebug?: boolean;    shopListQueryLimit?: number;    adminListQueryLimit?: number;    adminApiValidationRules?: Array<(context: ValidationContext) => any>;    shopApiValidationRules?: Array<(context: ValidationContext) => any>;    channelTokenKey?: string;    cors?: boolean | CorsOptions;    middleware?: Middleware[];    trustProxy?: TrustProx
...
```

Example 2 (ts):
```ts
{  introspection: process.env.NODE_ENV !== 'production'}
```

---

## StockLocation

**URL:** https://docs.vendure.io/reference/typescript-api/entities/stock-location/

**Contents:**
- StockLocation
- StockLocation‚Äã
  - constructor‚Äã
  - name‚Äã
  - description‚Äã
  - customFields‚Äã
  - channels‚Äã
  - stockMovements‚Äã

A StockLocation represents a physical location where stock is held. For example, a warehouse or a shop.

When the stock of a ProductVariant is adjusted, the adjustment is applied to a specific StockLocation, and the stockOnHand of that ProductVariant is updated accordingly. When there are multiple StockLocations configured, the StockLocationStrategy is used to determine which StockLocation should be used for a given operation.

Extends: VendureEntity

Implements: HasCustomFields, ChannelAware

**Examples:**

Example 1 (ts):
```ts
class StockLocation extends VendureEntity implements HasCustomFields, ChannelAware {    constructor(input: DeepPartial<StockLocation>)    @Column()    name: string;    @Column()    description: string;    @Column(type => CustomStockLocationFields)    customFields: CustomStockLocationFields;    @ManyToMany(type => Channel, channel => channel.stockLocations)    @JoinTable()    channels: Channel[];    @OneToMany(type => StockMovement, movement => movement.stockLocation)    stockMovements: StockMovement[];}
```

---

## DefaultFormComponentId

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/default-form-component-id

**Contents:**
- DefaultFormComponentId
- DefaultFormComponentId‚Äã

The ids of the default form input components that ship with the Admin UI.

**Examples:**

Example 1 (ts):
```ts
type DefaultFormComponentId = | 'boolean-form-input'    | 'currency-form-input'    | 'customer-group-form-input'    | 'date-form-input'    | 'facet-value-form-input'    | 'json-editor-form-input'    | 'html-editor-form-input'    | 'number-form-input'    | 'password-form-input'    | 'product-selector-form-input'    | 'relation-form-input'    | 'rich-text-form-input'    | 'select-form-input'    | 'text-form-input'    | 'textarea-form-input'    | 'product-multi-form-input'    | 'combination-mode-form-input'    | 'struct-form-input'
```

---

## Country

**URL:** https://docs.vendure.io/reference/typescript-api/entities/country

**Contents:**
- Country
- Country‚Äã
  - constructor‚Äã
  - type‚Äã

A country to which is available when creating / updating an Address. Countries are grouped together into Zones which are in turn used to determine applicable shipping and taxes for an Order.

**Examples:**

Example 1 (ts):
```ts
class Country extends Region {    constructor(input?: DeepPartial<Country>)    readonly type: RegionType = 'country';}
```

---

## DetailPageButton

**URL:** https://docs.vendure.io/reference/dashboard/components/detail-page-button

**Contents:**
- DetailPageButton
- DetailPageButton‚Äã
  - props‚Äã

DetailPageButton is a reusable navigation component designed to provide consistent UX across list views when linking to detail pages. It renders as a ghost button with a chevron indicator, making it easy for users to identify clickable links that navigate to detail views.

**Examples:**

Example 1 (tsx):
```tsx
// Basic usage with ID (relative navigation)<DetailPageButton id="123" label="Product Name" />*Example*```tsx// Custom href with search params<DetailPageButton  href="/products/detail/456"  label="Custom Product"  search={{ tab: 'variants' }}/>
```

Example 2 (ts):
```ts
function DetailPageButton(props: Readonly<{    label: string | React.ReactNode;    id?: string;    href?: string;    disabled?: boolean;    search?: Record<string, string>;    className?: string;}>): void
```

---

## AddActionBarItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/add-action-bar-item/

**Contents:**
- AddActionBarItem
- addActionBarItem‚Äã
  - config‚Äã

Adds a button to the ActionBar at the top right of each list or detail view. The locationId can be determined by pressing ctrl + u when running the Admin UI in dev mode.

**Examples:**

Example 1 (ts):
```ts
export default [    addActionBarItem({        id: 'print-invoice',        label: 'Print Invoice',        locationId: 'order-detail',        routerLink: ['/extensions/invoicing'],    }),];
```

Example 2 (ts):
```ts
function addActionBarItem(config: ActionBarItem): void
```

---

## VendureConfig

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/vendure-config

**Contents:**
- VendureConfig
- VendureConfig‚Äã
  - apiOptions‚Äã
  - assetOptions‚Äã
  - authOptions‚Äã
  - catalogOptions‚Äã
  - customFields‚Äã
  - settingsStoreFields‚Äã
  - dbConnectionOptions‚Äã
  - defaultChannelToken‚Äã

All possible configuration options are defined by the VendureConfig interface.

Configuration for the GraphQL APIs, including hostname, port, CORS settings, middleware etc.

Configuration for the handling of Assets.

Configuration for authorization.

Configuration for Products and Collections.

Defines custom fields which can be used to extend the built-in entities.

Defines key-value fields that can be set and read via the getKeyValue/setKeyValue GraphQL APIs and via the SettingsStoreService. These differ from custom fields in that they are not associated with a specific entity, but can be scoped globally or to a specific user etc, and defining them does not require any changes to the database schema.

The connection options used by TypeORM to connect to the database. See the TypeORM documentation for a full description of all available options.

The token for the default channel. If not specified, a token will be randomly generated.

The default languageCode of the app.

Defines the strategy used for both storing the primary keys of entities in the database, and the encoding & decoding of those ids when exposing entities via the API. The default uses a simple auto-increment integer strategy.

Configuration settings for data import and export.

Configuration settings governing how orders are handled.

Configures available payment processing methods.

Configures the Conditions and Actions available when creating Promotions.

Configures the available checkers and calculators for ShippingMethods.

Provide a logging service which implements the VendureLogger interface. Note that the logging of SQL queries is controlled separately by the dbConnectionOptions.logging property.

Configures how taxes are calculated on products.

Configures how the job queue is persisted and processed.

Configures the scheduler mechanism and tasks.

Configures system options

**Examples:**

Example 1 (ts):
```ts
interface VendureConfig {    apiOptions: ApiOptions;    assetOptions?: AssetOptions;    authOptions: AuthOptions;    catalogOptions?: CatalogOptions;    customFields?: CustomFields;    settingsStoreFields?: SettingsStoreFields;    dbConnectionOptions: DataSourceOptions;    defaultChannelToken?: string | null;    defaultLanguageCode?: LanguageCode;    entityIdStrategy?: EntityIdStrategy<any>;    entityOptions?: EntityOptions;    importExportOptions?: ImportExportOptions;    orderOptions?: OrderOptions;    paymentOptions: PaymentOptions;    plugins?: Array<DynamicModule | Type<any>>;    promotio
...
```

---

## DashboardWidgetConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/dashboard-widgets/dashboard-widget-config

**Contents:**
- DashboardWidgetConfig
- DashboardWidgetConfig‚Äã
  - loadComponent‚Äã
  - title‚Äã
  - supportedWidths‚Äã
  - requiresPermissions‚Äã

A configuration object for a dashboard widget.

Used to specify the widget component. Supports both eager- and lazy-loading.

The title of the widget. Can be a translation token as it will get passed through the translate pipe.

The supported widths of the widget, in terms of a Bootstrap-style 12-column grid. If omitted, then it is assumed the widget supports all widths.

If set, the widget will only be displayed if the current user has all the specified permissions.

**Examples:**

Example 1 (ts):
```ts
interface DashboardWidgetConfig {    loadComponent: () => Promise<Type<any>> | Type<any>;    title?: string;    supportedWidths?: DashboardWidgetWidth[];    requiresPermissions?: string[];}
```

Example 2 (ts):
```ts
// eager-loadingloadComponent: () => MyWidgetComponent,// lazy-loadingloadComponent: () => import('./path-to/widget.component').then(m => m.MyWidgetComponent),
```

---

## AssetPickerDialog

**URL:** https://docs.vendure.io/reference/dashboard/components/asset-picker-dialog

**Contents:**
- AssetPickerDialog
- AssetPickerDialog‚Äã
  - props‚Äã
- AssetPickerDialogProps‚Äã
  - open‚Äã
  - onClose‚Äã
  - onSelect‚Äã
  - multiSelect‚Äã
  - initialSelectedAssets‚Äã
  - title‚Äã

A dialog which allows the creation and selection of assets.

Props for the AssetPickerDialog component.

Whether the dialog is open.

The function to call when the dialog is closed.

The function to call when assets are selected.

Whether multiple assets can be selected.

The initial assets that should be selected.

The title of the dialog.

**Examples:**

Example 1 (ts):
```ts
function AssetPickerDialog(props: AssetPickerDialogProps): void
```

Example 2 (ts):
```ts
interface AssetPickerDialogProps {    open: boolean;    onClose: () => void;    onSelect: (assets: Asset[]) => void;    multiSelect?: boolean;    initialSelectedAssets?: Asset[];    title?: string;}
```

---

## DetailForms

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/detail-forms

**Contents:**
- DetailForms
- DashboardDetailFormInputComponent‚Äã
  - blockId‚Äã
  - field‚Äã
  - component‚Äã
- DashboardDetailFormExtensionDefinition‚Äã
  - pageId‚Äã
  - extendDetailDocument‚Äã
  - inputs‚Äã

Allows you to define custom input components for specific fields in detail forms. The pageId is already defined in the detail form extension, so only the blockId and field are needed.

The ID of the block where this input component should be used.

The name of the field where this input component should be used.

The React component that will be rendered as the input. It should accept value, onChange, and other standard input props.

Allows you to extend existing detail forms (e.g. on the product detail or customer detail pages) with custom GraphQL queries, input components, and display components.

The ID of the page where the detail form is located, e.g. 'product-detail', 'order-detail'.

Extends the GraphQL query used to fetch data for the detail page, allowing you to add additional fields that can be used by custom input or display components.

Custom input components for specific fields in the detail form.

**Examples:**

Example 1 (ts):
```ts
interface DashboardDetailFormInputComponent {    blockId: string;    field: string;    component: DashboardFormComponent;}
```

Example 2 (ts):
```ts
interface DashboardDetailFormExtensionDefinition {    pageId: string;    extendDetailDocument?: string | DocumentNode | (() => DocumentNode | string);    inputs?: DashboardDetailFormInputComponent[];}
```

---

## Asset

**URL:** https://docs.vendure.io/reference/typescript-api/entities/asset

**Contents:**
- Asset
- Asset‚Äã
  - constructor‚Äã
  - name‚Äã
  - type‚Äã
  - mimeType‚Äã
  - width‚Äã
  - height‚Äã
  - fileSize‚Äã
  - source‚Äã

An Asset represents a file such as an image which can be associated with certain other entities such as Products.

Extends: VendureEntity

Implements: Taggable, ChannelAware, HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Asset extends VendureEntity implements Taggable, ChannelAware, HasCustomFields {    constructor(input?: DeepPartial<Asset>)    @Column() name: string;    @Column('varchar') type: AssetType;    @Column() mimeType: string;    @Column({ default: 0 }) width: number;    @Column({ default: 0 }) height: number;    @Column() fileSize: number;    @Column() source: string;    @Column() preview: string;    @Column('simple-json', { nullable: true })    focalPoint?: { x: number; y: number };    @ManyToMany(type => Tag)    @JoinTable()    tags: Tag[];    @ManyToMany(type => Channel)    @JoinTable()   
...
```

---

## DefaultCachePlugin

**URL:** https://docs.vendure.io/reference/typescript-api/cache/default-cache-plugin/

**Contents:**
- DefaultCachePlugin
- DefaultCachePlugin‚Äã
  - options‚Äã
  - init‚Äã
- DefaultCachePluginInitOptions‚Äã
  - cacheSize‚Äã
  - cacheTtlProvider‚Äã

This plugin provides a simple SQL-based cache strategy SqlCacheStrategy which stores cached items in the database.

It is suitable for production use (including multi-instance setups). For increased performance you can also consider using the RedisCachePlugin.

Configuration options for the DefaultCachePlugin.

The maximum number of items to store in the cache. Once the cache reaches this size, the least-recently-used items will be evicted to make room for new items.

Optionally provide a custom CacheTtlProvider to control the TTL of cache items. This is useful for testing.

**Examples:**

Example 1 (ts):
```ts
class DefaultCachePlugin {    static options: DefaultCachePluginInitOptions = {        cacheSize: 10_000,    };    init(options: DefaultCachePluginInitOptions) => ;}
```

Example 2 (ts):
```ts
interface DefaultCachePluginInitOptions {    cacheSize?: number;    cacheTtlProvider?: CacheTtlProvider;}
```

---

## RegisterHistoryEntryComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-history-entry-components/register-history-entry-component

**Contents:**
- RegisterHistoryEntryComponent
- registerHistoryEntryComponent‚Äã
  - config‚Äã

Registers a HistoryEntryComponent for displaying history entries in the Order/Customer history timeline.

**Examples:**

Example 1 (ts):
```ts
import { Component } from '@angular/core';import {    CustomerFragment,    CustomerHistoryEntryComponent,    registerHistoryEntryComponent,    SharedModule,    TimelineDisplayType,    TimelineHistoryEntry,} from '@vendure/admin-ui/core';@Component({    selector: 'tax-id-verification-component',    template: `        <div *ngIf="entry.data.valid">          Tax ID <strong>{{ entry.data.taxId }}</strong> was verified          <vdr-history-entry-detail *ngIf="entry.data">            <vdr-object-tree [value]="entry.data"></vdr-object-tree>          </vdr-history-entry-detail>        </div>        <
...
```

Example 2 (ts):
```ts
function registerHistoryEntryComponent(config: HistoryEntryConfig): void
```

---

## DashboardPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/dashboard-plugin/

**Contents:**
- DashboardPlugin
- DashboardPlugin‚Äã
- Installation‚Äã
- Usage‚Äã
- Development vs Production‚Äã
- Metrics‚Äã
  - constructor‚Äã
  - init‚Äã
  - configure‚Äã

This plugin serves the static files of the Vendure Dashboard and provides the GraphQL extensions needed for the order metrics on the dashboard index page.

npm install @vendure/dashboard

First you need to set up compilation of the Dashboard, using the Vite configuration described in the Dashboard Getting Started Guide

When developing, you can run npx vite (or npm run dev) to start the Vite development server. The plugin will automatically detect if Vite is running on the default port (5173) and proxy requests to it instead of serving static files. This enables hot module replacement and faster development iterations.

For production, run npx vite build to build the dashboard app. The built app files will be output to the location specified by build.outDir in your Vite config file. This should then be passed to the appDir init option, as in the example below:

This plugin defines a metricSummary query which is used by the Dashboard UI to display the order metrics on the dashboard.

If you are building a stand-alone version of the Dashboard UI app, and therefore don't need this plugin to serve the Dashboard UI, you can still use the metricSummary query by adding the DashboardPlugin to the plugins array, but without calling the init() method:

Set the plugin options

**Examples:**

Example 1 (ts):
```ts
import { DashboardPlugin } from '@vendure/dashboard/plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    DashboardPlugin.init({      route: 'dashboard',      appDir: './dist/dashboard',      // Optional: customize Vite dev server port (defaults to 5173)      viteDevServerPort: 3000,    }),  ],};
```

Example 2 (ts):
```ts
import { DashboardPlugin } from '@vendure/dashboard-plugin';const config: VendureConfig = {  plugins: [    DashboardPlugin, // <-- no call to .init()  ],  // ...};
```

Example 3 (ts):
```ts
class DashboardPlugin implements NestModule {    constructor(processContext: ProcessContext)    init(options: DashboardPluginOptions) => Type<DashboardPlugin>;    configure(consumer: MiddlewareConsumer) => ;}
```

---

## RegisterPageTab

**URL:** https://docs.vendure.io/reference/admin-ui-api/tabs/register-page-tab

**Contents:**
- RegisterPageTab
- registerPageTab‚Äã
  - config‚Äã

Add a tab to an existing list or detail page.

**Examples:**

Example 1 (ts):
```ts
import { registerPageTab } from '@vendure/admin-ui/core';import { DeletedProductListComponent } from './components/deleted-product-list/deleted-product-list.component';export default [    registerPageTab({        location: 'product-list',        tab: 'Deleted Products',        route: 'deleted',        component: DeletedProductListComponent,    }),];
```

Example 2 (ts):
```ts
function registerPageTab(config: PageTabConfig): void
```

---

## Cache

**URL:** https://docs.vendure.io/reference/typescript-api/cache

**Contents:**
- Cache
- Cache‚Äã
  - constructor‚Äã
  - get‚Äã
  - delete‚Äã
  - invalidateTags‚Äã

A convenience wrapper around the CacheService methods which provides a simple API for caching and retrieving data.

The advantage of using the Cache class rather than directly calling the CacheService methods is that it allows you to define a consistent way of generating cache keys and to set default cache options, and takes care of setting the value in cache if it does not already exist.

In most cases, using the Cache class will result in simpler and more readable code.

This class is normally created via the CacheService.createCache() method.

Retrieves the value from the cache if it exists, otherwise calls the getValueFn function to get the value, sets it in the cache and returns it.

Deletes one or more items from the cache.

Invalidates one or more tags in the cache.

**Examples:**

Example 1 (ts):
```ts
const cache = cacheService.createCache({  getKey: id => `ProductVariantIds:${id}`,  options: {    ttl: 1000 * 60 * 60,    tags: ['products'],  },});// This will fetch the value from the cache if it exists, or// fetch it from the ProductService if not, and then cache// using the key 'ProductVariantIds.${id}'.const variantIds = await cache.get(id, async () => {  const variants await ProductService.getVariantsByProductId(ctx, id) ;  // The cached value must be serializable, so we just return the ids  return variants.map(v => v.id);});
```

Example 2 (ts):
```ts
class Cache {    constructor(config: CacheConfig, cacheService: CacheService)    get(id: string | number, getValueFn: () => T | Promise<T>) => Promise<T>;    delete(id: string | number | Array<string | number>) => Promise<void>;    invalidateTags(tags: string[]) => Promise<void>;}
```

---

## SetSettingsStoreValueResult

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/set-settings-store-value-result

**Contents:**
- SetSettingsStoreValueResult
- SetSettingsStoreValueResult‚Äã
  - key‚Äã
  - result‚Äã
  - error‚Äã

Result type for settings store set operations, providing detailed feedback about the success or failure of each operation.

The key that was attempted to be set.

Whether the set operation was successful.

Error message if the operation failed, null if successful.

**Examples:**

Example 1 (ts):
```ts
interface SetSettingsStoreValueResult {    key: string;    result: boolean;    error?: string;}
```

---

## UseLocalFormat

**URL:** https://docs.vendure.io/reference/dashboard/hooks/use-local-format

**Contents:**
- UseLocalFormat
- useLocalFormat‚Äã

This hook is used to format numbers and currencies using the configured language and locale of the dashboard app.

**Examples:**

Example 1 (ts):
```ts
const {         formatCurrency,         formatNumber,         formatDate,         formatLanguageName,         formatCurrencyName,         toMajorUnits,} = useLocalFormat();
```

Example 2 (ts):
```ts
function useLocalFormat(): void
```

---

## Worker

**URL:** https://docs.vendure.io/reference/typescript-api/worker/

**Contents:**
- Worker
- üìÑÔ∏è BootstrapWorker
- üìÑÔ∏è VendureWorker
- üìÑÔ∏è WorkerHealthCheckConfig

WorkerHealthCheckConfig

---

## ConfigurableOperationDef

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/

**Contents:**
- ConfigurableOperationDef
- ConfigurableOperationDef‚Äã
- The args property‚Äã
- Dependency Injection‚Äã
  - code‚Äã
  - args‚Äã
  - description‚Äã
  - constructor‚Äã
  - init‚Äã
  - destroy‚Äã

A ConfigurableOperationDef is a special type of object used extensively by Vendure to define code blocks which have arguments which are configurable at run-time by the administrator.

This is the mechanism used by:

Any class which extends ConfigurableOperationDef works in the same way: it takes a config object as the constructor argument. That config object extends the ConfigurableOperationDefOptions interface and typically adds some kind of business logic function to it.

For example, in the case of ShippingEligibilityChecker, it adds the check() function to the config object which defines the logic for checking whether an Order is eligible for a particular ShippingMethod.

The key feature of the ConfigurableOperationDef is the args property. This is where we define those arguments that are exposed via the Admin UI as data input components. This allows their values to be set at run-time by the Administrator. Those values can then be accessed in the business logic of the operation.

The data type of the args can be one of ConfigArgType, and the configuration is further explained in the docs of ConfigArgs.

If your business logic relies on injectable providers, such as the TransactionalConnection object, or any of the internal Vendure services or those defined in a plugin, you can inject them by using the config object's init() method, which exposes the Injector.

Here's an example of a ShippingCalculator that injects a service which has been defined in a plugin:

Convert a ConfigurableOperationDef into a ConfigurableOperationDefinition object, typically so that it can be sent via the API.

Coverts an array of ConfigArgs into a hash object:

from: [{ name: 'foo', type: 'string', value: 'bar'}]

**Examples:**

Example 1 (ts):
```ts
import { Injector, ShippingCalculator } from '@vendure/core';import { ShippingRatesService } from './shipping-rates.service';// We keep reference to our injected service by keeping it// in the top-level scope of the file.let shippingRatesService: ShippingRatesService;export const customShippingCalculator = new ShippingCalculator({  code: 'custom-shipping-calculator',  description: [],  args: {},  init(injector: Injector) {    // The init function is called during bootstrap, and allows    // us to inject any providers we need.    shippingRatesService = injector.get(ShippingRatesService);  },  c
...
```

Example 2 (ts):
```ts
class ConfigurableOperationDef<T extends ConfigArgs = ConfigArgs> {    code: string    args: T    description: LocalizedStringArray    constructor(options: ConfigurableOperationDefOptions<T>)    init(injector: Injector) => ;    destroy() => ;    toGraphQlType(ctx: RequestContext) => ConfigurableOperationDefinition;    argsArrayToHash(args: ConfigArg[]) => ConfigArgValues<T>;}
```

---

## CacheService

**URL:** https://docs.vendure.io/reference/typescript-api/cache/cache-service

**Contents:**
- CacheService
- CacheService‚Äã
  - cacheStrategy‚Äã
  - constructor‚Äã
  - createCache‚Äã
  - get‚Äã
  - set‚Äã
  - delete‚Äã
  - invalidateTags‚Äã

The CacheService is used to cache data in order to optimize performance.

Internally it makes use of the configured CacheStrategy to persist the cache into a key-value store.

Creates a new Cache instance with the given configuration.

The Cache instance provides a convenience wrapper around the CacheService methods.

Gets an item from the cache, or returns undefined if the key is not found, or the item has expired.

Sets a key-value pair in the cache. The value must be serializable, so cannot contain things like functions, circular data structures, class instances etc.

Optionally a "time to live" (ttl) can be specified, which means that the key will be considered stale after that many milliseconds.

Deletes an item from the cache.

Deletes all items from the cache which contain at least one matching tag.

**Examples:**

Example 1 (ts):
```ts
class CacheService {    protected cacheStrategy: CacheStrategy;    constructor(configService: ConfigService)    createCache(config: CacheConfig) => Cache;    get(key: string) => Promise<T | undefined>;    set(key: string, value: T, options?: SetCacheKeyOptions) => Promise<void>;    delete(key: string) => Promise<void>;    invalidateTags(tags: string[]) => Promise<void>;}
```

---

## RegisterReactFormInputComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/register-react-form-input-component

**Contents:**
- RegisterReactFormInputComponent
- registerReactFormInputComponent‚Äã
  - id‚Äã
  - component‚Äã

Registers a React component to be used as a FormInputComponent.

**Examples:**

Example 1 (ts):
```ts
function registerReactFormInputComponent(id: string, component: ElementType): void
```

---

## Queries

**URL:** https://docs.vendure.io/reference/graphql-api/shop/queries

**Contents:**
- Queries
- activeChannel‚Äã
- activeCustomer‚Äã
- activeOrder‚Äã
- activePaymentMethods‚Äã
- activeShippingMethods‚Äã
- availableCountries‚Äã
- collection‚Äã
- collections‚Äã
- eligiblePaymentMethods‚Äã

---

## UseQuery

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-query

**Contents:**
- UseQuery
- useQuery‚Äã
  - query‚Äã
  - variables‚Äã
  - options‚Äã

A React hook which provides access to the results of a GraphQL query.

**Examples:**

Example 1 (ts):
```ts
import { useQuery } from '@vendure/admin-ui/react';import { gql } from 'graphql-tag';const GET_PRODUCT = gql`   query GetProduct($id: ID!) {     product(id: $id) {       id       name       description     }   }`;export const MyComponent = () => {    const { data, loading, error } = useQuery(GET_PRODUCT, { id: '1' }, { refetchOnChannelChange: true });    if (loading) return <div>Loading...</div>;    if (error) return <div>Error! { error }</div>;    return (        <div>            <h1>{data.product.name}</h1>            <p>{data.product.description}</p>        </div>    );};
```

Example 2 (ts):
```ts
function useQuery<T, V extends Record<string, any> = Record<string, any>>(query: DocumentNode | TypedDocumentNode<T, V>, variables?: V, options: { refetchOnChannelChange: boolean } = { refetchOnChannelChange: false }): void
```

---

## HealthCheckStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/health-check/health-check-strategy

**Contents:**
- HealthCheckStrategy
- HealthCheckStrategy‚Äã
  - getHealthIndicator‚Äã

This strategy defines health checks which are included as part of the /health endpoint. They should only be used to monitor critical systems on which proper functioning of the Vendure server depends.

For more information on the underlying mechanism, see the NestJS Terminus module docs.

Custom strategies should be added to the systemOptions.healthChecks array. By default, Vendure includes the TypeORMHealthCheckStrategy, so if you set the value of the healthChecks array, be sure to include it manually.

Vendure also ships with the HttpHealthCheckStrategy, which is convenient for adding a health check dependent on an HTTP ping.

This is configured via the systemOptions.healthChecks property of your VendureConfig.

Should return a HealthIndicatorFunction, as defined by the NestJS Terminus module.

**Examples:**

Example 1 (ts):
```ts
import { HttpHealthCheckStrategy, TypeORMHealthCheckStrategy } from '@vendure/core';import { MyCustomHealthCheckStrategy } from './config/custom-health-check-strategy';export const config = {  // ...  systemOptions: {    healthChecks: [      new TypeORMHealthCheckStrategy(),      new HttpHealthCheckStrategy({ key: 'my-service', url: 'https://my-service.com' }),      new MyCustomHealthCheckStrategy(),    ],  },};
```

Example 2 (ts):
```ts
interface HealthCheckStrategy extends InjectableStrategy {    getHealthIndicator(): HealthIndicatorFunction;}
```

---

## NumberInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/number-input

**Contents:**
- NumberInput
- NumberInput‚Äã
  - props‚Äã

A component for displaying a numeric value.

**Examples:**

Example 1 (ts):
```ts
function NumberInput(props: Readonly<NumberInputProps>): void
```

---

## FormComponents

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/form-components

**Contents:**
- FormComponents
- DashboardCustomFormComponent‚Äã
  - id‚Äã
  - component‚Äã
- DashboardCustomFormComponents‚Äã
  - customFields‚Äã
- DashboardFormComponentProps‚Äã
- DashboardFormComponentMetadata‚Äã
  - isListInput‚Äã
  - isFullWidth‚Äã

Allows you to define custom form components for custom fields in the dashboard.

A unique identifier for the custom form component. It is a good practice to namespace these IDs to avoid naming collisions, for example "my-plugin.markdown-editor".

The React component that will be rendered as the custom form input.

Interface for registering custom field components in the dashboard. For input and display components, use the co-located approach with detailForms.

Custom form components for custom fields. These are used when rendering custom fields in forms.

Props that get passed to all form input components. They are based on the controller props used by the underlying react-hook-form, i.e.:

in addition, they can optionally be passed a fieldDef prop if the component is used in the context of a custom field or configurable operation arg.

The fieldDef arg, when present, has the following shape:

Metadata which can be defined on a DashboardFormComponent which provides additional information about how the dashboard should render the component.

The metadata is defined by adding the static property on the component:

Defines whether this form component is designed to handle list inputs. If set to 'dynamic', it means the component has internal logic that can handle both lists and single values.

TODO: not currently implemented

This is the common type for all custom form components registered for:

Here's a simple example:

**Examples:**

Example 1 (ts):
```ts
interface DashboardCustomFormComponent {    id: string;    component: DashboardFormComponent;}
```

Example 2 (ts):
```ts
interface DashboardCustomFormComponents {    customFields?: DashboardCustomFormComponent[];}
```

Example 3 (ts):
```ts
export type ControllerRenderProps = {    onChange: (event: any) => void;    onBlur: () => void;    value: any;    disabled?: boolean;    name: string;    ref: RefCallBack;};
```

Example 4 (ts):
```ts
export type ConfigurableArgDef = {    defaultValue: any    description: string | null    label: string | null    list: boolean    name: string    required: boolean    type: string    ui: any}
```

---

## HardenPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/harden-plugin/

**Contents:**
- HardenPlugin
- HardenPlugin‚Äã
- Installation‚Äã
- Setting the max query complexity‚Äã
  - options‚Äã
  - init‚Äã

The HardenPlugin hardens the Shop and Admin GraphQL APIs against attacks and abuse.

It is a recommended plugin for all production configurations.

yarn add @vendure/harden-plugin

npm install @vendure/harden-plugin

Then add the HardenPlugin, calling the .init() method with HardenPluginOptions:

The maxQueryComplexity option determines how complex a query can be. The complexity of a query relates to how many, and how deeply-nested are the fields being selected, and is intended to roughly correspond to the amount of server resources that would be required to resolve that query.

The goal of this setting is to prevent attacks in which a malicious actor crafts a very complex query in order to overwhelm your server resources. Here's an example of a request which would likely overwhelm a Vendure server:

This evil query has a complexity score of 2,443,203 - much greater than the default of 1,000!

The complexity score is calculated by the graphql-query-complexity library, and by default uses the defaultVendureComplexityEstimator, which is tuned specifically to the Vendure Shop API.

Note: By default, if the "take" argument is omitted from a list query (e.g. the products or collections query), a default factor of 1000 is applied.

The optimal max complexity score will vary depending on:

You should aim to set the maximum as low as possible while still being able to service all the requests required. This will take some manual tuning. While tuning the max, you can turn on the logComplexityScore to get a detailed breakdown of the complexity of each query, as well as how that total score is derived from its child fields:

With logging configured as above, the following query:

will log the following breakdown:

**Examples:**

Example 1 (ts):
```ts
import { HardenPlugin } from '@vendure/harden-plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [     HardenPlugin.init({       maxQueryComplexity: 650,       apiMode: process.env.APP_ENV === 'dev' ? 'dev' : 'prod',     }),  ],};
```

Example 2 (graphql):
```graphql
query EvilQuery {  products {    items {      collections {        productVariants {          items {            product {              collections {                productVariants {                  items {                    product {                      variants {                        name                      }                    }                  }                }              }            }          }        }      }    }  }}
```

Example 3 (ts):
```ts
import { HardenPlugin } from '@vendure/harden-plugin';const config: VendureConfig = {  // A detailed summary is logged at the "debug" level  logger: new DefaultLogger({ level: LogLevel.Debug }),  plugins: [     HardenPlugin.init({       maxQueryComplexity: 650,       logComplexityScore: true,     }),  ],};
```

Example 4 (graphql):
```graphql
query ProductList {  products(options: { take: 5 }) {    items {      id      name      featuredAsset {        preview      }    }  }}
```

---

## SentryPluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/sentry-plugin/sentry-plugin-options

**Contents:**
- SentryPluginOptions
- SentryPluginOptions‚Äã
  - includeErrorTestMutation‚Äã

Configuration options for the SentryPlugin.

Whether to include the error test mutation in the admin API. When enabled, a createTestError mutation becomes available in the Admin API, which can be used to create different types of error to check that the integration is working correctly.

**Examples:**

Example 1 (ts):
```ts
interface SentryPluginOptions {    includeErrorTestMutation?: boolean;}
```

---

## ExternalAuthenticationService

**URL:** https://docs.vendure.io/reference/typescript-api/auth/external-authentication-service/

**Contents:**
- ExternalAuthenticationService
- ExternalAuthenticationService‚Äã
  - constructor‚Äã
  - findCustomerUser‚Äã
  - findAdministratorUser‚Äã
  - createCustomerAndUser‚Äã
  - createAdministratorAndUser‚Äã
  - findUser‚Äã
  - createUser‚Äã

This is a helper service which exposes methods related to looking up and creating Users based on an external AuthenticationStrategy.

Looks up a User based on their identifier from an external authentication provider, ensuring this User is associated with a Customer account.

By default, only customers in the currently-active Channel will be checked. By passing false as the checkCurrentChannelOnly argument, all channels will be checked.

Looks up a User based on their identifier from an external authentication provider, ensuring this User is associated with an Administrator account.

If a customer has been successfully authenticated by an external authentication provider, yet cannot be found using findCustomerUser, then we need to create a new User and Customer record in Vendure for that user. This method encapsulates that logic as well as additional housekeeping such as adding a record to the Customer's history.

If an administrator has been successfully authenticated by an external authentication provider, yet cannot be found using findAdministratorUser, then we need to create a new User and Administrator record in Vendure for that user.

Looks up a User based on their identifier from an external authentication provider. Creates the user if does not exist. Unlike findCustomerUser and findAdministratorUser, this method does not enforce that the User is associated with a Customer or Administrator account.

**Examples:**

Example 1 (ts):
```ts
class ExternalAuthenticationService {    constructor(connection: TransactionalConnection, roleService: RoleService, historyService: HistoryService, customerService: CustomerService, administratorService: AdministratorService, channelService: ChannelService)    findCustomerUser(ctx: RequestContext, strategy: string, externalIdentifier: string, checkCurrentChannelOnly:  = true) => Promise<User | undefined>;    findAdministratorUser(ctx: RequestContext, strategy: string, externalIdentifier: string) => Promise<User | undefined>;    createCustomerAndUser(ctx: RequestContext, config: {            st
...
```

---

## StockMovement

**URL:** https://docs.vendure.io/reference/typescript-api/entities/stock-movement

**Contents:**
- StockMovement
- StockMovement‚Äã
  - type‚Äã
  - productVariant‚Äã
  - stockLocation‚Äã
  - stockLocationId‚Äã
  - quantity‚Äã
  - customFields‚Äã
- Allocation‚Äã
  - type‚Äã

A StockMovement is created whenever stock of a particular ProductVariant goes in or out.

Extends: VendureEntity

Implements: HasCustomFields

An Allocation is created for each ProductVariant in an Order when the checkout is completed (as configured by the StockAllocationStrategy. This prevents stock being sold twice.

A Cancellation is created when OrderItems from a fulfilled Order are cancelled.

A Release is created when OrderItems which have been allocated (but not yet fulfilled) are cancelled.

A Sale is created when OrderItems are fulfilled.

A StockAdjustment is created when the stockOnHand level of a ProductVariant is manually adjusted.

**Examples:**

Example 1 (ts):
```ts
class StockMovement extends VendureEntity implements HasCustomFields {    @Column({ nullable: false, type: 'varchar' })    readonly type: StockMovementType;    @Index()    @ManyToOne(type => ProductVariant, variant => variant.stockMovements)    productVariant: ProductVariant;    @Index()    @ManyToOne(type => StockLocation, stockLocation => stockLocation.stockMovements, { onDelete: 'CASCADE' })    stockLocation: StockLocation;    @EntityId()    stockLocationId: ID;    @Column()    quantity: number;    @Column(type => CustomStockMovementFields)    customFields: CustomStockMovementFields;}
```

Example 2 (ts):
```ts
class Allocation extends StockMovement {    readonly type = StockMovementType.ALLOCATION;    constructor(input: DeepPartial<Allocation>)    @Index()    @ManyToOne(type => OrderLine, orderLine => orderLine.allocations)    orderLine: OrderLine;}
```

Example 3 (ts):
```ts
class Cancellation extends StockMovement {    readonly type = StockMovementType.CANCELLATION;    constructor(input: DeepPartial<Cancellation>)    @ManyToOne(type => OrderLine, orderLine => orderLine.cancellations)    orderLine: OrderLine;}
```

Example 4 (ts):
```ts
class Release extends StockMovement {    readonly type = StockMovementType.RELEASE;    constructor(input: DeepPartial<Release>)    @ManyToOne(type => OrderLine)    orderLine: OrderLine;}
```

---

## DropdownComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/dropdown-component

**Contents:**
- DropdownComponent
- DropdownComponent‚Äã
  - isOpen‚Äã
  - trigger‚Äã
  - manualToggle‚Äã
  - onClick‚Äã
  - toggleOpen‚Äã
  - onOpenChange‚Äã
  - setTriggerElement‚Äã

Used for building dropdown menus.

**Examples:**

Example 1 (html):
```html
<vdr-dropdown>  <button class="btn btn-outline" vdrDropdownTrigger>      <clr-icon shape="plus"></clr-icon>      Select type  </button>  <vdr-dropdown-menu vdrPosition="bottom-left">    <button      *ngFor="let typeName of allTypes"      type="button"      vdrDropdownItem      (click)="selectType(typeName)"    >      typeName    </button>  </vdr-dropdown-menu></vdr-dropdown>
```

Example 2 (ts):
```ts
class DropdownComponent {    isOpen = false;    public trigger: ElementRef;    @Input() manualToggle = false;    onClick() => ;    toggleOpen() => ;    onOpenChange(callback: (isOpen: boolean) => void) => ;    setTriggerElement(elementRef: ElementRef) => ;}
```

---

## ObjectTreeComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/object-tree-component

**Contents:**
- ObjectTreeComponent
- ObjectTreeComponent‚Äã
  - value‚Äã
  - isArrayItem‚Äã
  - depth‚Äã
  - expanded‚Äã
  - valueIsArray‚Äã
  - entries‚Äã
  - constructor‚Äã
  - ngOnChanges‚Äã

This component displays a plain JavaScript object as an expandable tree.

**Examples:**

Example 1 (html):
```html
<vdr-object-tree [value]="payment.metadata"></vdr-object-tree>
```

Example 2 (ts):
```ts
class ObjectTreeComponent implements OnChanges {    @Input() value: { [key: string]: any } | string;    @Input() isArrayItem = false;    depth: number;    expanded: boolean;    valueIsArray: boolean;    entries: Array<{ key: string; value: any }>;    constructor(parent: ObjectTreeComponent)    ngOnChanges() => ;    isObject(value: any) => boolean;}
```

---

## DataTableComponentConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-table-components/data-table-component-config

**Contents:**
- DataTableComponentConfig
- DataTableComponentConfig‚Äã
  - tableId‚Äã
  - columnId‚Äã
  - component‚Äã
  - providers‚Äã

Configures a CustomDetailComponent to be placed in the given location.

The location in the UI where the custom component should be placed.

The column in the table where the custom component should be placed.

The component to render in the table cell. This component should implement the CustomColumnComponent interface.

**Examples:**

Example 1 (ts):
```ts
interface DataTableComponentConfig {    tableId: DataTableLocationId;    columnId: DataTableColumnId;    component: Type<CustomColumnComponent>;    providers?: Provider[];}
```

---

## SchedulerStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/scheduler-strategy

**Contents:**
- SchedulerStrategy
- SchedulerStrategy‚Äã
  - registerTask‚Äã
  - executeTask‚Äã
  - getTasks‚Äã
  - getTask‚Äã
  - triggerTask‚Äã
  - updateTask‚Äã
- TaskReport‚Äã
  - id‚Äã

This strategy is used to define the mechanism by which scheduled tasks are executed and how they are reported on. The main purpose of this strategy is to ensure that a given task is executed exactly once at the scheduled time, even if there are multiple instances of the worker running.

To do this, the strategy must use some form of shared storage and a method of locking so that only a single worker is allowed to execute the task.

By default, the DefaultSchedulerStrategy will use the database to enable this functionality.

An optional method that may be used by the strategy to register all the configured tasks ahead of time. This can be useful for keeping an internal reference of all the tasks to aid in the specific strategy implemetation.

Execute a scheduled task. This method must also take care of ensuring that the task is executed exactly once at the scheduled time, even if there are multiple instances of the worker running.

For instance, in the DefaultSchedulerStrategy we make use of a dedicated database table and a locking mechansim. If you implement a custom SchedulerStrategy, you must use some other form of shared locking mechanism that could make use of something like Redis etc. to ensure that the task is executed exactly once at the scheduled time.

The function returned is then called in order to execture the task. The job argument is an instance of the croner Cron class, except when the task has been manually triggered, in which case it will be undefined.

Get all scheduled tasks.

Get a single scheduled task by its id.

Manually trigger a given task. This method is not used to actually invoke the task function itself, since that would cause the task to run on the server instance which we typically do not want. Instead, it should be used to signal to the strategy that this specific task needs to be invoked at the soonest opportunity.

For instance, in the DefaultSchedulerStrategy this is done by setting a flag in the database table which is checked periodically and causes those tasks to get immediately invoked.

Update a scheduled task.

A report on the status of a scheduled task.

**Examples:**

Example 1 (ts):
```ts
interface SchedulerStrategy extends InjectableStrategy {    registerTask?(task: ScheduledTask): void;    executeTask(task: ScheduledTask): (job?: Cron) => Promise<any> | any;    getTasks(): Promise<TaskReport[]>;    getTask(id: string): Promise<TaskReport | undefined>;    triggerTask(task: ScheduledTask): Promise<void>;    updateTask(input: UpdateScheduledTaskInput): Promise<TaskReport>;}
```

Example 2 (ts):
```ts
interface TaskReport {    id: string;    lastExecutedAt: Date | null;    isRunning: boolean;    lastResult: any;    enabled: boolean;}
```

---

## LocalAssetStorageStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/local-asset-storage-strategy

**Contents:**
- LocalAssetStorageStrategy
- LocalAssetStorageStrategy‚Äã
  - toAbsoluteUrl‚Äã
  - constructor‚Äã
  - writeFileFromStream‚Äã
  - writeFileFromBuffer‚Äã
  - fileExists‚Äã
  - readFileToBuffer‚Äã
  - readFileToStream‚Äã
  - deleteFile‚Äã

A persistence strategy which saves files to the local file system.

**Examples:**

Example 1 (ts):
```ts
class LocalAssetStorageStrategy implements AssetStorageStrategy {    toAbsoluteUrl: ((reqest: Request, identifier: string) => string) | undefined;    constructor(uploadPath: string, toAbsoluteUrlFn?: (reqest: Request, identifier: string) => string)    writeFileFromStream(fileName: string, data: ReadStream) => Promise<string>;    writeFileFromBuffer(fileName: string, data: Buffer) => Promise<string>;    fileExists(fileName: string) => Promise<boolean>;    readFileToBuffer(identifier: string) => Promise<Buffer>;    readFileToStream(identifier: string) => Promise<Stream>;    deleteFile(identifier
...
```

---

## CountryService

**URL:** https://docs.vendure.io/reference/typescript-api/services/country-service

**Contents:**
- CountryService
- CountryService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findAllAvailable‚Äã
  - findOneByCode‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã

Contains methods relating to Country entities.

Returns an array of enabled Countries, intended for use in a public-facing (ie. Shop) API.

Returns a Country based on its ISO country code.

**Examples:**

Example 1 (ts):
```ts
class CountryService {    constructor(connection: TransactionalConnection, listQueryBuilder: ListQueryBuilder, translatableSaver: TranslatableSaver, eventBus: EventBus, translator: TranslatorService)    findAll(ctx: RequestContext, options?: ListQueryOptions<Country>, relations: RelationPaths<Country> = []) => Promise<PaginatedList<Translated<Country>>>;    findOne(ctx: RequestContext, countryId: ID, relations: RelationPaths<Country> = []) => Promise<Translated<Country> | undefined>;    findAllAvailable(ctx: RequestContext) => Promise<Array<Translated<Country>>>;    findOneByCode(ctx: RequestC
...
```

---

## TestDbInitializer

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-db-initializer/

**Contents:**
- TestDbInitializer
- TestDbInitializer‚Äã
  - init‚Äã
  - populate‚Äã
  - destroy‚Äã

Defines how the e2e TestService sets up a particular DB to run a single test suite. The @vendure/testing package ships with initializers for sql.js, MySQL & Postgres.

Custom initializers can be created by implementing this interface and registering it with the registerInitializer function:

Responsible for creating a database for the current test suite. Typically, this method will:

Execute the populateFn to populate your database.

Clean up any resources used during the init() phase (i.e. close open DB connections)

**Examples:**

Example 1 (ts):
```ts
export class CockroachDbInitializer implements TestDbInitializer<CockroachConnectionOptions> {    // database-specific implementation goes here}registerInitializer('cockroachdb', new CockroachDbInitializer());
```

Example 2 (ts):
```ts
interface TestDbInitializer<T extends BaseConnectionOptions> {    init(testFileName: string, connectionOptions: T): Promise<T>;    populate(populateFn: () => Promise<void>): Promise<void>;    destroy(): void | Promise<void>;}
```

---

## Navigation Types

**URL:** https://docs.vendure.io/reference/admin-ui-api/nav-menu/navigation-types

**Contents:**
- Navigation Types
- NavMenuBadge‚Äã
  - type‚Äã
  - propagateToSection‚Äã

A color-coded notification badge which will be displayed by the NavMenuItem's icon.

If true, the badge will propagate to the NavMenuItem's parent section, displaying a notification badge next to the section name.

**Examples:**

Example 1 (ts):
```ts
interface NavMenuBadge {    type: NavMenuBadgeType;    propagateToSection?: boolean;}
```

---

## ImportParser

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/import-parser

**Contents:**
- ImportParser
- ImportParser‚Äã
  - parseProducts‚Äã
- ParsedOptionGroup‚Äã
  - translations‚Äã
- ParsedFacet‚Äã
  - translations‚Äã
- ParsedProductVariant‚Äã
  - sku‚Äã
  - price‚Äã

Validates and parses CSV files into a data structure which can then be used to created new entities. This is used internally by the Importer.

Parses the contents of the product import CSV file and returns a data structure which can then be used to populate Vendure using the FastImporterService.

The intermediate representation of an OptionGroup after it has been parsed by the ImportParser.

The intermediate representation of a Facet after it has been parsed by the ImportParser.

The intermediate representation of a ProductVariant after it has been parsed by the ImportParser.

The intermediate representation of a Product after it has been parsed by the ImportParser.

The data structure into which an import CSV file is parsed by the ImportParser parseProducts() method.

The result returned by the ImportParser parseProducts() method.

**Examples:**

Example 1 (ts):
```ts
class ImportParser {    parseProducts(input: string | Stream, mainLanguage: LanguageCode = this.configService.defaultLanguageCode) => Promise<ParseResult<ParsedProductWithVariants>>;}
```

Example 2 (ts):
```ts
interface ParsedOptionGroup {    translations: Array<{        languageCode: LanguageCode;        name: string;        values: string[];    }>;}
```

Example 3 (ts):
```ts
interface ParsedFacet {    translations: Array<{        languageCode: LanguageCode;        facet: string;        value: string;    }>;}
```

Example 4 (ts):
```ts
interface ParsedProductVariant {    sku: string;    price: number;    taxCategory: string;    stockOnHand: number;    trackInventory: GlobalFlag;    assetPaths: string[];    facets: ParsedFacet[];    translations: Array<{        languageCode: LanguageCode;        optionValues: string[];        customFields: {            [name: string]: string;        };    }>;}
```

---

## TaxCategory

**URL:** https://docs.vendure.io/reference/typescript-api/entities/tax-category

**Contents:**
- TaxCategory
- TaxCategory‚Äã
  - constructor‚Äã
  - name‚Äã
  - isDefault‚Äã
  - customFields‚Äã
  - productVariants‚Äã
  - taxRates‚Äã

A TaxCategory defines what type of taxes to apply to a ProductVariant.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class TaxCategory extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<TaxCategory>)    @Column() name: string;    @Column({ default: false }) isDefault: boolean;    @Column(type => CustomTaxCategoryFields)    customFields: CustomTaxCategoryFields;    @OneToMany(type => ProductVariant, productVariant => productVariant.taxCategory)    productVariants: ProductVariant[];    @OneToMany(type => TaxRate, taxRate => taxRate.category)    taxRates: TaxRate[];}
```

---

## SetDashboardWidgetLayout

**URL:** https://docs.vendure.io/reference/admin-ui-api/dashboard-widgets/set-dashboard-widget-layout

**Contents:**
- SetDashboardWidgetLayout
- setDashboardWidgetLayout‚Äã
  - layoutDef‚Äã

Sets the default widget layout for the Admin UI dashboard.

**Examples:**

Example 1 (ts):
```ts
function setDashboardWidgetLayout(layoutDef: WidgetLayoutDefinition): void
```

---

## AssetImportStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/asset-import-strategy

**Contents:**
- AssetImportStrategy
- AssetImportStrategy‚Äã
  - getStreamFromPath‚Äã

The AssetImportStrategy determines how asset files get imported based on the path given in the import CSV or via the AssetImporter getAssets() method.

The DefaultAssetImportStrategy is able to load files from either the local filesystem or from a remote URL.

A custom strategy could be created which could e.g. get the asset file from an S3 bucket.

This is configured via the importExportOptions.assetImportStrategy property of your VendureConfig.

Given an asset path, this method should return a Stream of file data. This could e.g. be read from a file system or fetch from a remote location.

**Examples:**

Example 1 (ts):
```ts
interface AssetImportStrategy extends InjectableStrategy {    getStreamFromPath(assetPath: string): Readable | Promise<Readable>;}
```

---

## DefaultMoneyStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/money/default-money-strategy

**Contents:**
- DefaultMoneyStrategy
- DefaultMoneyStrategy‚Äã
  - moneyColumnOptions‚Äã
  - precision‚Äã
  - round‚Äã

A MoneyStrategy that stores monetary values as a int type in the database. The storage configuration and rounding logic replicates the behaviour of Vendure pre-2.0.

**Examples:**

Example 1 (ts):
```ts
class DefaultMoneyStrategy implements MoneyStrategy {    readonly moneyColumnOptions: ColumnOptions = {        type: 'int',    };    readonly precision: number = 2;    round(value: number, quantity:  = 1) => number;}
```

---

## Pipes

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/

**Contents:**
- Pipes
- üìÑÔ∏è AssetPreviewPipe
- üìÑÔ∏è DurationPipe
- üìÑÔ∏è FileSizePipe
- üìÑÔ∏è HasPermissionPipe
- üìÑÔ∏è LocaleCurrencyNamePipe
- üìÑÔ∏è LocaleCurrencyPipe
- üìÑÔ∏è LocaleDatePipe
- üìÑÔ∏è LocaleLanguageNamePipe
- üìÑÔ∏è LocaleRegionNamePipe

LocaleCurrencyNamePipe

LocaleLanguageNamePipe

---

## Transaction Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/transaction-decorator

**Contents:**
- Transaction Decorator
- Transaction‚Äã
- TransactionMode‚Äã
- TransactionIsolationLevel‚Äã

Runs the decorated method in a TypeORM transaction. It works by creating a transactional QueryRunner which gets attached to the RequestContext object. When the RequestContext is the passed to the TransactionalConnection getRepository() method, this QueryRunner is used to execute the queries within this transaction.

Essentially, the entire resolver function is wrapped in a try-catch block which commits the transaction on successful completion of the method, or rolls back the transaction in an unhandled error is thrown.

The Transaction decorator can handle transactions automatically (which is the default) or be set to "manual" mode, where the TransactionalConnection .startTransaction() and .commitOpenTransaction() methods must them be used.

Note that even in manual mode, a rollback will be automatically performed in the case that an uncaught error is thrown within the resolver.

Transactions can be run at different isolation levels. The default is undefined, which falls back to the default of your database. See the documentation of your database for more information on available isolation levels.

**Examples:**

Example 1 (ts):
```ts
// in a GraphQL resolver file@Transaction()async myMutation(@Ctx() ctx: RequestContext) {  // as long as the `ctx` object is passed in to  // all database operations, the entire mutation  // will be run as an atomic transaction, and rolled  // back if an error is thrown.  const result = this.myService.createThing(ctx);  return this.myService.updateOtherThing(ctx, result.id);}
```

Example 2 (ts):
```ts
// in a GraphQL resolver file@Transaction('manual')async myMutation(@Ctx() ctx: RequestContext) {  await this.connection.startTransaction(ctx);  const result = this.myService.createThing(ctx);  const thing = this.myService.updateOtherThing(ctx, result.id);  await this.connection.commitOpenTransaction(ctx);  return thing;}
```

Example 3 (ts):
```ts
type TransactionMode = 'auto' | 'manual'
```

Example 4 (ts):
```ts
type TransactionIsolationLevel = | 'READ UNCOMMITTED'    | 'READ COMMITTED'    | 'REPEATABLE READ'    | 'SERIALIZABLE'
```

---

## TagService

**URL:** https://docs.vendure.io/reference/typescript-api/services/tag-service

**Contents:**
- TagService
- TagService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã
  - valuesToTags‚Äã
  - getTagsForEntity‚Äã

Contains methods relating to Tag entities.

**Examples:**

Example 1 (ts):
```ts
class TagService {    constructor(connection: TransactionalConnection, listQueryBuilder: ListQueryBuilder)    findAll(ctx: RequestContext, options?: ListQueryOptions<Tag>) => Promise<PaginatedList<Tag>>;    findOne(ctx: RequestContext, tagId: ID) => Promise<Tag | undefined>;    create(ctx: RequestContext, input: CreateTagInput) => ;    update(ctx: RequestContext, input: UpdateTagInput) => ;    delete(ctx: RequestContext, id: ID) => Promise<DeletionResponse>;    valuesToTags(ctx: RequestContext, values: string[]) => Promise<Tag[]>;    getTagsForEntity(ctx: RequestContext, entity: Type<VendureEn
...
```

---

## OrderSellerStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-seller-strategy/

**Contents:**
- OrderSellerStrategy
- OrderSellerStrategy‚Äã
  - setOrderLineSellerChannel‚Äã
  - splitOrder‚Äã
  - afterSellerOrdersCreated‚Äã
- DefaultOrderSellerStrategy‚Äã
- SplitOrderContents‚Äã
  - channelId‚Äã
  - state‚Äã
  - lines‚Äã

This strategy defines how an Order can be split into multiple sub-orders for the use-case of a multivendor application.

This is configured via the orderOptions.orderSellerStrategy property of your VendureConfig.

This method is called whenever a new OrderLine is added to the Order via the addItemToOrder mutation or the underlying addItemToOrder() method of the OrderService.

It should return the Channel to which this OrderLine will be assigned, which will be used to set the OrderLine sellerChannel property.

Upon checkout (by default, when the Order moves from "active" to "inactive" according to the OrderPlacedStrategy), this method will be called in order to split the Order into multiple Orders, one for each Seller.

This method is called after splitting the orders, including calculating the totals for each of the seller Orders. This method can be used to set platform fee surcharges on the seller Orders as well as perform any payment processing needed.

The DefaultOrderSellerStrategy treats the Order as single-vendor.

The contents of the aggregate Order which make up a single seller Order.

**Examples:**

Example 1 (ts):
```ts
interface OrderSellerStrategy extends InjectableStrategy {    setOrderLineSellerChannel?(        ctx: RequestContext,        orderLine: OrderLine,    ): Channel | undefined | Promise<Channel | undefined>;    splitOrder?(ctx: RequestContext, order: Order): SplitOrderContents[] | Promise<SplitOrderContents[]>;    afterSellerOrdersCreated?(        ctx: RequestContext,        aggregateOrder: Order,        sellerOrders: Order[],    ): void | Promise<void>;}
```

Example 2 (ts):
```ts
class DefaultOrderSellerStrategy implements OrderSellerStrategy {}
```

Example 3 (ts):
```ts
interface SplitOrderContents {    channelId: ID;    state: OrderState;    lines: OrderLine[];    shippingLines: ShippingLine[];}
```

---

## MolliePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/payments-plugin/mollie-plugin

**Contents:**
- MolliePlugin
- MolliePlugin‚Äã
- Requirements‚Äã
- Setup‚Äã
- Storefront usage‚Äã
- Pay later methods‚Äã
- ArrangingAdditionalPayment state‚Äã
  - options‚Äã
  - init‚Äã
- MolliePluginOptions‚Äã

Plugin to enable payments through the Mollie platform. This plugin uses the Order API from Mollie, not the Payments API.

You will need to create a Mollie account and get your apiKey in the dashboard.

Install the Payments plugin and the Mollie client:

yarn add @vendure/payments-plugin @mollie/api-client

npm install @vendure/payments-plugin @mollie/api-client

In your storefront you add a payment to an order using the createMolliePaymentIntent mutation. In this example, our Mollie PaymentMethod was given the code "mollie-payment-method". The `redirectUrl``is the url that is used to redirect the end-user back to your storefront after completing the payment.

The response will contain a redirectUrl, which can be used to redirect your customer to the Mollie platform.

'molliePaymentMethodCode' is an optional parameter that can be passed to skip Mollie's hosted payment method selection screen You can get available Mollie payment methods with the following query:

After completing payment on the Mollie platform, the user is redirected to the redirect url that was provided in the createMolliePaymentIntent mutation, e.g. https://storefront/order/CH234X5

Mollie supports pay-later methods like 'Klarna Pay Later'. Pay-later methods are captured immediately after payment.

If your order fulfillment time is longer than 24 hours You should pass immediateCapture=false to the createMolliePaymentIntent mutation. This will transition your order to 'PaymentAuthorized' after the Mollie hosted checkout. You need to manually capture the payment after the order is fulfilled, by settling existing payments, either via the admin UI or in custom code.

Make sure to capture a payment within 28 days, after that the payment will be automaticallreleased. See the Mollie documentation for more information.

In some rare cases, a customer can add items to the active order, while a Mollie checkout is still open, for example by opening your storefront in another browser tab. This could result in an order being in ArrangingAdditionalPayment status after the customer finished payment. You should check if there is still an active order with status ArrangingAdditionalPayment on your order confirmation page, and if so, allow your customer to pay for the additional items by creating another Mollie payment.

Initialize the mollie payment plugin

Configuration options for the Mollie payments plugin.

The host of your Vendure server, e.g. 'https://my-vendure.io'. This is used by Mollie to send we

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { MolliePlugin } from '@vendure/payments-plugin/package/mollie';// ...plugins: [  MolliePlugin.init({ vendureHost: 'https://yourhost.io/' }),]
```

Example 2 (graphql):
```graphql
mutation CreateMolliePaymentIntent {  createMolliePaymentIntent(input: {    redirectUrl: "https://storefront/order/1234XYZ" // Optional, the fallback redirect url set in the admin UI will be used if not provided    paymentMethodCode: "mollie-payment-method" // Optional, the first method with Mollie as handler will be used if not provided    molliePaymentMethodCode: "ideal", // Optional argument to skip the method selection in the hosted checkout    locale: "nl_NL", // Optional, the browser language will be used by Mollie if not provided    immediateCapture: true, // Optional, default is true, 
...
```

Example 3 (graphql):
```graphql
{ molliePaymentMethods(input: { paymentMethodCode: "mollie-payment-method" }) {   id   code   description   minimumAmount {     value     currency   }   maximumAmount {     value     currency   }   image {     size1x     size2x     svg   } }}
```

Example 4 (ts):
```ts
class MolliePlugin {    static options: MolliePluginOptions;    init(options: MolliePluginOptions) => typeof MolliePlugin;}
```

---

## OrderProcess

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-process

**Contents:**
- OrderProcess
- OrderProcess‚Äã
  - transitions‚Äã
  - onTransitionStart‚Äã
  - onTransitionEnd‚Äã
  - onTransitionError‚Äã
- DefaultOrderProcessOptions‚Äã
  - checkModificationPayments‚Äã
  - checkAdditionalPaymentsAmount‚Äã
  - checkAllVariantsExist‚Äã

An OrderProcess is used to define the way the order process works as in: what states an Order can be in, and how it may transition from one state to another. Using the onTransitionStart() hook, an OrderProcess can perform checks before allowing a state transition to occur, and the onTransitionEnd() hook allows logic to be executed after a state change.

For detailed description of the interface members, see the StateMachineConfig docs.

This is configured via the orderOptions.process property of your VendureConfig.

Options which can be passed to the configureDefaultOrderProcess function to configure an instance of the default OrderProcess. By default, all options are set to true.

Prevents an Order from transitioning out of the Modifying state if the Order price has changed and there is no Payment or Refund associated with the Modification.

Prevents an Order from transitioning out of the ArrangingAdditionalPayment state if the Order's Payments do not cover the full amount of totalWithTax.

Prevents the transition from AddingItems to any other state (apart from Cancelled) if and of the ProductVariants no longer exists due to deletion.

Prevents transition to the ArrangingPayment state if the active Order has no lines.

Prevents transition to the ArrangingPayment state if the active Order has no customer associated with it.

Prevents transition to the ArrangingPayment state if the active Order has no shipping method set.

Prevents transition to the ArrangingPayment state if there is insufficient saleable stock to cover the contents of the Order.

Prevents transition to the PaymentAuthorized or PaymentSettled states if the order totalWithTax amount is not covered by Payment(s) in the corresponding states.

Prevents transition to the Cancelled state unless all OrderItems are already cancelled.

Prevents transition to the Shipped, PartiallyShipped, Delivered & PartiallyDelivered states unless there are corresponding Fulfillments in the correct states to allow this. E.g. Shipped only if all items in the Order are part of a Fulfillment which itself is in the Shipped state.

Used to configure a customized instance of the default OrderProcess that ships with Vendure. Using this function allows you to turn off certain checks and constraints that are enabled by default.

The DefaultOrderProcessOptions type defines all available options. If you require even more customization, you can create your own implementation of the OrderProcess interface.

This is the built-in default OrderProcess that ships with Vendure. A customized version of this process can be created using the `configureDefaultOrderProcess` function, which allows you to pass in an object to enable/disable certain checks.

The default implementation manages order state transitions and includes validation checks such as verification that modifications have associated payments, confirmation that payment amounts cover order totals, validation of product variant existence, requirements for customer, shipping method, and stock availability before payment arrangement, and fulfillment state verification before shipping/delivery transitions.

**Examples:**

Example 1 (ts):
```ts
interface OrderProcess<State extends keyof CustomOrderStates | string> extends InjectableStrategy {    transitions?: Transitions<State, State | OrderState> & Partial<Transitions<OrderState | State>>;    onTransitionStart?: OnTransitionStartFn<State | OrderState, OrderTransitionData>;    onTransitionEnd?: OnTransitionEndFn<State | OrderState, OrderTransitionData>;    onTransitionError?: OnTransitionErrorFn<State | OrderState>;}
```

Example 2 (ts):
```ts
interface DefaultOrderProcessOptions {    checkModificationPayments?: boolean;    checkAdditionalPaymentsAmount?: boolean;    checkAllVariantsExist?: boolean;    arrangingPaymentRequiresContents?: boolean;    arrangingPaymentRequiresCustomer?: boolean;    arrangingPaymentRequiresShipping?: boolean;    arrangingPaymentRequiresStock?: boolean;    checkPaymentsCoverTotal?: boolean;    checkAllItemsBeforeCancel?: boolean;    checkFulfillmentStates?: boolean;}
```

Example 3 (ts):
```ts
import { configureDefaultOrderProcess, VendureConfig } from '@vendure/core';const myCustomOrderProcess = configureDefaultOrderProcess({  // Disable the constraint that requires  // Orders to have a shipping method assigned  // before payment.  arrangingPaymentRequiresShipping: false,});export const config: VendureConfig = {  orderOptions: {    process: [myCustomOrderProcess],  },};
```

Example 4 (ts):
```ts
function configureDefaultOrderProcess(options: DefaultOrderProcessOptions): void
```

---

## StockLocationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/stock-location-strategy/

**Contents:**
- StockLocationStrategy
- StockLocationStrategy‚Äã
  - getAvailableStock‚Äã
  - forAllocation‚Äã
  - forRelease‚Äã
  - forSale‚Äã
  - forCancellation‚Äã
- AvailableStock‚Äã
  - stockOnHand‚Äã
  - stockAllocated‚Äã

The StockLocationStrategy is responsible for determining which StockLocations should be used to fulfill an OrderLine and how much stock should be allocated from each location. It is also used to determine the available stock for a given ProductVariant.

This is configured via the catalogOptions.stockLocationStrategy property of your VendureConfig.

Returns the available stock for the given ProductVariant, taking into account the stock levels at each StockLocation.

Determines which StockLocations should be used to when allocating stock when and Order is placed.

Determines which StockLocations should be used to when releasing allocated stock when an OrderLine is cancelled before being fulfilled.

Determines which StockLocations should be used to when creating a Sale and reducing the stockOnHand upon fulfillment.

Determines which StockLocations should be used to when creating a Cancellation of an OrderLine which has already been fulfilled.

The overall available stock for a ProductVariant as determined by the logic of the StockLocationStrategy's getAvailableStock method.

Returned by the StockLocationStrategy methods to indicate how much stock from each location should be used in the allocation/sale/release/cancellation of an OrderLine.

**Examples:**

Example 1 (ts):
```ts
interface StockLocationStrategy extends InjectableStrategy {    getAvailableStock(        ctx: RequestContext,        productVariantId: ID,        stockLevels: StockLevel[],    ): AvailableStock | Promise<AvailableStock>;    forAllocation(        ctx: RequestContext,        stockLocations: StockLocation[],        orderLine: OrderLine,        quantity: number,    ): LocationWithQuantity[] | Promise<LocationWithQuantity[]>;    forRelease(        ctx: RequestContext,        stockLocations: StockLocation[],        orderLine: OrderLine,        quantity: number,    ): LocationWithQuantity[] | Promis
...
```

Example 2 (ts):
```ts
interface AvailableStock {    stockOnHand: number;    stockAllocated: number;}
```

Example 3 (ts):
```ts
interface LocationWithQuantity {    location: StockLocation;    quantity: number;}
```

---

## Services

**URL:** https://docs.vendure.io/reference/admin-ui-api/services/

**Contents:**
- Services
- üìÑÔ∏è DataService
- üìÑÔ∏è ModalService
- üìÑÔ∏è NotificationService

---

## PollingJobQueueStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/polling-job-queue-strategy

**Contents:**
- PollingJobQueueStrategy
- PollingJobQueueStrategy‚Äã
  - concurrency‚Äã
  - pollInterval‚Äã
  - setRetries‚Äã
  - backOffStrategy‚Äã
  - gracefulShutdownTimeout‚Äã
  - activeQueues‚Äã
  - constructor‚Äã
  - constructor‚Äã

This class allows easier implementation of JobQueueStrategy in a polling style. Instead of providing JobQueueStrategy start() you should provide a next method.

This class should be extended by any strategy which does not support a push-based system to notify on new jobs. It is used by the SqlJobQueueStrategy and InMemoryJobQueueStrategy.

Should return the next job in the given queue. The implementation is responsible for returning the correct job according to the time of creation.

Update the job details in the store.

Returns a job by its id.

**Examples:**

Example 1 (ts):
```ts
class PollingJobQueueStrategy extends InjectableJobQueueStrategy {    public concurrency: number;    public pollInterval: number | ((queueName: string) => number);    public setRetries: (queueName: string, job: Job) => number;    public backOffStrategy?: BackoffStrategy;    public gracefulShutdownTimeout: number;    protected activeQueues = new QueueNameProcessStorage<ActiveQueue<any>>();    constructor(config?: PollingJobQueueStrategyConfig)    constructor(concurrency?: number, pollInterval?: number)    constructor(concurrencyOrConfig?: number | PollingJobQueueStrategyConfig, maybePollInterva
...
```

---

## BaseEntityResolver

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/base-entity-resolver

**Contents:**
- BaseEntityResolver
- BaseEntityResolver‚Äã
  - constructor‚Äã

A base resolver for an entity detail route. Resolves to an observable of the given entity, or a "blank" version if the route id equals "create". Should be used together with details views which extend the BaseDetailComponent.

**Examples:**

Example 1 (ts):
```ts
@Injectable({  providedIn: 'root',})export class MyEntityResolver extends BaseEntityResolver<MyEntityFragment> {  constructor(router: Router, dataService: DataService) {    super(      router,      {        __typename: 'MyEntity',        id: '',        createdAt: '',        updatedAt: '',        name: '',      },      id => dataService.query(GET_MY_ENTITY, { id }).mapStream(data => data.myEntity),    );  }}
```

Example 2 (ts):
```ts
class BaseEntityResolver<T> {    constructor(router: Router, emptyEntity: T, entityStream: (id: string) => Observable<T | null | undefined>)}
```

---

## EntityHydrator

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/entity-hydrator

**Contents:**
- EntityHydrator
- EntityHydrator‚Äã
  - constructor‚Äã
  - hydrate‚Äã

This is a helper class which is used to "hydrate" entity instances, which means to populate them with the specified relations. This is useful when writing plugin code which receives an entity, and you need to ensure that one or more relations are present.

In this above example, the product instance will now have the facetValues relation available, and those FacetValues will have their facet relations joined too.

This hydrate method will also automatically take care or translating any translatable entities (e.g. Product, Collection, Facet), and if the applyProductVariantPrices options is used (see HydrateOptions), any related ProductVariant will have the correct Channel-specific prices applied to them.

Custom field relations may also be hydrated:

Hydrates (joins) the specified relations to the target entity instance. This method mutates the target entity.

**Examples:**

Example 1 (ts):
```ts
import { Injectable } from '@nestjs/common';import { ID, RequestContext, EntityHydrator, ProductVariantService } from '@vendure/core';@Injectable()export class MyService {  constructor(     private entityHydrator: EntityHydrator,     private productVariantService: ProductVariantService,  ) {}  myMethod(ctx: RequestContext, variantId: ID) {    const product = await this.productVariantService      .getProductForVariant(ctx, variantId);    // at this stage, we don't know which of the Product relations    // will be joined at runtime.    await this.entityHydrator      .hydrate(ctx, product, { rela
...
```

Example 2 (ts):
```ts
const customer = await this.customerService  .findOne(ctx, id);await this.entityHydrator  .hydrate(ctx, customer, { relations: ['customFields.avatar' ]});
```

Example 3 (ts):
```ts
class EntityHydrator {    constructor(connection: TransactionalConnection, productPriceApplicator: ProductPriceApplicator, translator: TranslatorService)    hydrate(ctx: RequestContext, target: Entity, options: HydrateOptions<Entity>) => Promise<Entity>;}
```

Example 4 (ts):
```ts
await this.entityHydrator.hydrate(ctx, product, {  relations: [    'variants.stockMovements'    'optionGroups.options',    'featuredAsset',  ],  applyProductVariantPrices: true,});
```

---

## FacetValue

**URL:** https://docs.vendure.io/reference/typescript-api/entities/facet-value/

**Contents:**
- FacetValue
- FacetValue‚Äã
  - constructor‚Äã
  - name‚Äã
  - code‚Äã
  - translations‚Äã
  - facet‚Äã
  - facetId‚Äã
  - customFields‚Äã
  - channels‚Äã

A particular value of a Facet.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware

**Examples:**

Example 1 (ts):
```ts
class FacetValue extends VendureEntity implements Translatable, HasCustomFields, ChannelAware {    constructor(input?: DeepPartial<FacetValue>)    name: LocaleString;    @Column() code: string;    @OneToMany(type => FacetValueTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<FacetValue>>;    @Index()    @ManyToOne(type => Facet, group => group.values, { onDelete: 'CASCADE' })    facet: Facet;    @EntityId()    facetId: ID;    @Column(type => CustomFacetValueFields)    customFields: CustomFacetValueFields;    @ManyToMany(type => Channel, channel =
...
```

---

## ActiveOrderStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/active-order-strategy/

**Contents:**
- ActiveOrderStrategy
- ActiveOrderStrategy‚Äã
  - name‚Äã
  - defineInputType‚Äã
  - createActiveOrder‚Äã
  - determineActiveOrder‚Äã

This strategy is used to determine the active Order for all order-related operations in the Shop API. By default, all the Shop API operations that relate to the active Order (e.g. activeOrder, addItemToOrder, applyCouponCode etc.) will implicitly create a new Order and set it on the current Session, and then read the session to obtain the active Order. This behaviour is defined by the DefaultActiveOrderStrategy.

The InputType generic argument should correspond to the input type defined by the defineInputType() method.

When defineInputType() is used, then the following Shop API operations will receive an additional activeOrderInput argument allowing the active order input to be specified:

The name of the strategy, e.g. "orderByToken", which will also be used as the field name in the ActiveOrderInput type.

Defines the type of the GraphQL Input object expected by the activeOrderInput input argument.

For example, given the following:

assuming the strategy name is "orderByToken", then the resulting call to activeOrder (or any of the other affected Shop API operations) would look like:

Note: if more than one graphql input type is being defined (as in a nested input type), then the first input will be assumed to be the top-level input.

Certain mutations such as addItemToOrder can automatically create a new Order if one does not exist. In these cases, this method will be called to create the new Order.

If automatic creation of an Order does not make sense in your strategy, then leave this method undefined. You'll then need to take care of creating an order manually by defining a custom mutation.

This method is used to determine the active Order based on the current RequestContext in addition to any input values provided, as defined by the defineInputType method of this strategy.

Note that this method is invoked frequently, so you should aim to keep it efficient. The returned Order, for example, does not need to have its various relations joined.

**Examples:**

Example 1 (graphql):
```graphql
mutation AddItemToOrder {  addItemToOrder(    productVariantId: 42,    quantity: 1,    activeOrderInput: { token: "123456" }  ) {    ...on Order {      id      # ...etc    }  }}
```

Example 2 (ts):
```ts
import { ID } from '@vendure/common/lib/shared-types';import {  ActiveOrderStrategy,  CustomerService,  idsAreEqual,  Injector,  Order,  OrderService,  RequestContext,  TransactionalConnection,} from '@vendure/core';import gql from 'graphql-tag';// This strategy assumes a "orderToken" custom field is defined on the Order// entity, and uses that token to perform a lookup to determine the active Order.//// Additionally, it does _not_ define a `createActiveOrder()` method, which// means that a custom mutation would be required to create the initial Order in// the first place and set the "orderTok
...
```

Example 3 (ts):
```ts
interface ActiveOrderStrategy<InputType extends Record<string, any> | void = void> extends InjectableStrategy {    readonly name: string;    defineInputType?: () => DocumentNode;    createActiveOrder?: (ctx: RequestContext, input: InputType) => Promise<Order>;    determineActiveOrder(ctx: RequestContext, input: InputType): Promise<Order | undefined>;}
```

Example 4 (ts):
```ts
defineInputType() {  return gql`     input OrderTokenInput {       token: String!     }  `;}
```

---

## TaxZoneStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/tax/tax-zone-strategy/

**Contents:**
- TaxZoneStrategy
- TaxZoneStrategy‚Äã
  - determineTaxZone‚Äã

Defines how the active Zone is determined for the purposes of calculating taxes.

This strategy is used in 2 scenarios:

Note that this method is called very often in a typical user session, so any work it performs should be designed with as little performance impact as possible.

This is configured via the taxOptions.taxZoneStrategy property of your VendureConfig.

**Examples:**

Example 1 (ts):
```ts
interface TaxZoneStrategy extends InjectableStrategy {    determineTaxZone(        ctx: RequestContext,        zones: Zone[],        channel: Channel,        order?: Order,    ): Zone | Promise<Zone> | undefined;}
```

---

## StockLocationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/stock-location-strategy

**Contents:**
- StockLocationStrategy
- StockLocationStrategy‚Äã
  - getAvailableStock‚Äã
  - forAllocation‚Äã
  - forRelease‚Äã
  - forSale‚Äã
  - forCancellation‚Äã
- AvailableStock‚Äã
  - stockOnHand‚Äã
  - stockAllocated‚Äã

The StockLocationStrategy is responsible for determining which StockLocations should be used to fulfill an OrderLine and how much stock should be allocated from each location. It is also used to determine the available stock for a given ProductVariant.

This is configured via the catalogOptions.stockLocationStrategy property of your VendureConfig.

Returns the available stock for the given ProductVariant, taking into account the stock levels at each StockLocation.

Determines which StockLocations should be used to when allocating stock when and Order is placed.

Determines which StockLocations should be used to when releasing allocated stock when an OrderLine is cancelled before being fulfilled.

Determines which StockLocations should be used to when creating a Sale and reducing the stockOnHand upon fulfillment.

Determines which StockLocations should be used to when creating a Cancellation of an OrderLine which has already been fulfilled.

The overall available stock for a ProductVariant as determined by the logic of the StockLocationStrategy's getAvailableStock method.

Returned by the StockLocationStrategy methods to indicate how much stock from each location should be used in the allocation/sale/release/cancellation of an OrderLine.

**Examples:**

Example 1 (ts):
```ts
interface StockLocationStrategy extends InjectableStrategy {    getAvailableStock(        ctx: RequestContext,        productVariantId: ID,        stockLevels: StockLevel[],    ): AvailableStock | Promise<AvailableStock>;    forAllocation(        ctx: RequestContext,        stockLocations: StockLocation[],        orderLine: OrderLine,        quantity: number,    ): LocationWithQuantity[] | Promise<LocationWithQuantity[]>;    forRelease(        ctx: RequestContext,        stockLocations: StockLocation[],        orderLine: OrderLine,        quantity: number,    ): LocationWithQuantity[] | Promis
...
```

Example 2 (ts):
```ts
interface AvailableStock {    stockOnHand: number;    stockAllocated: number;}
```

Example 3 (ts):
```ts
interface LocationWithQuantity {    location: StockLocation;    quantity: number;}
```

---

## ConfigArgs

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/config-args

**Contents:**
- ConfigArgs
- ConfigArgs‚Äã
- Data types‚Äã
- Lists‚Äã
- UI Component‚Äã
  - [index]‚Äã

A object which defines the configurable arguments which may be passed to functions in those classes which implement the ConfigurableOperationDef interface.

Each argument has a data type, which must be one of ConfigArgType.

Setting the list property to true will make the argument into an array of the specified data type. For example, if you want to store an array of strings:

In the Admin UI, this will be rendered as an orderable list of string inputs.

The ui field allows you to specify a specific input component to be used in the Admin UI. When not set, a default input component is used appropriate to the data type.

The available components as well as their configuration options can be found in the DefaultFormConfigHash docs. Custom UI components may also be defined via an Admin UI extension using the registerFormInputComponent() function which is exported from @vendure/admin-ui/core.

**Examples:**

Example 1 (ts):
```ts
{  apiKey: { type: 'string' },  maxRetries: { type: 'int' },  logErrors: { type: 'boolean' },}
```

Example 2 (ts):
```ts
{  aliases: {    type: 'string',    list: true,  },}
```

Example 3 (ts):
```ts
{  operator: {    type: 'string',    ui: {      component: 'select-form-input',      options: [        { value: 'startsWith' },        { value: 'endsWith' },        { value: 'contains' },        { value: 'doesNotContain' },      ],    },  },  secretKey: {    type: 'string',    ui: { component: 'password-form-input' },  },}
```

Example 4 (ts):
```ts
type ConfigArgs = {    [name: string]: ConfigArgDef<ConfigArgType>;}
```

---

## DefaultPaymentProcess

**URL:** https://docs.vendure.io/reference/typescript-api/payment/default-payment-process

**Contents:**
- DefaultPaymentProcess
- defaultPaymentProcess‚Äã

The default PaymentProcess

---

## AdministratorService

**URL:** https://docs.vendure.io/reference/typescript-api/services/administrator-service

**Contents:**
- AdministratorService
- AdministratorService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findOneByUserId‚Äã
  - create‚Äã
  - update‚Äã
  - assignRole‚Äã
  - softDelete‚Äã

Contains methods relating to Administrator entities.

Get a paginated list of Administrators.

Get an Administrator by id.

Get an Administrator based on the User id.

Create a new Administrator.

Update an existing Administrator.

Assigns a Role to the Administrator's User entity.

Soft deletes an Administrator (sets the deletedAt field).

**Examples:**

Example 1 (ts):
```ts
class AdministratorService {    constructor(connection: TransactionalConnection, configService: ConfigService, listQueryBuilder: ListQueryBuilder, passwordCipher: PasswordCipher, userService: UserService, roleService: RoleService, customFieldRelationService: CustomFieldRelationService, eventBus: EventBus, requestContextService: RequestContextService)    findAll(ctx: RequestContext, options?: ListQueryOptions<Administrator>, relations?: RelationPaths<Administrator>) => Promise<PaginatedList<Administrator>>;    findOne(ctx: RequestContext, administratorId: ID, relations?: RelationPaths<Administr
...
```

---

## CatalogOptions

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/catalog-options

**Contents:**
- CatalogOptions
- CatalogOptions‚Äã
  - collectionFilters‚Äã
  - productVariantPriceSelectionStrategy‚Äã
  - productVariantPriceCalculationStrategy‚Äã
  - productVariantPriceUpdateStrategy‚Äã
  - stockDisplayStrategy‚Äã
  - stockLocationStrategy‚Äã

Options related to products and collections.

Allows custom CollectionFilters to be defined.

Defines the strategy used to select the price of a ProductVariant, based on factors such as the active Channel and active CurrencyCode.

Defines the strategy used for calculating the price of ProductVariants based on the Channel settings and active tax Zone.

Defines the strategy which determines what happens to a ProductVariant's prices when one of the prices gets updated. For instance, this can be used to synchronize prices across multiple Channels.

Defines how the ProductVariant.stockLevel value is obtained. It is usually not desirable to directly expose stock levels over a public API, as this could be considered a leak of sensitive information. However, the storefront will usually want to display some indication of whether a given ProductVariant is in stock. The default StockDisplayStrategy will display "IN_STOCK", "OUT_OF_STOCK" or "LOW_STOCK" rather than exposing the actual saleable stock level.

Defines the strategy used to determine which StockLocation should be used when performing stock operations such as allocating and releasing stock as well as determining the amount of stock available for sale.

**Examples:**

Example 1 (ts):
```ts
interface CatalogOptions {    collectionFilters?: Array<CollectionFilter<any>>;    productVariantPriceSelectionStrategy?: ProductVariantPriceSelectionStrategy;    productVariantPriceCalculationStrategy?: ProductVariantPriceCalculationStrategy;    productVariantPriceUpdateStrategy?: ProductVariantPriceUpdateStrategy;    stockDisplayStrategy?: StockDisplayStrategy;    stockLocationStrategy?: StockLocationStrategy;}
```

---

## Payment

**URL:** https://docs.vendure.io/reference/typescript-api/entities/payment

**Contents:**
- Payment
- Payment‚Äã
  - constructor‚Äã
  - method‚Äã
  - amount‚Äã
  - state‚Äã
  - errorMessage‚Äã
  - transactionId‚Äã
  - metadata‚Äã
  - order‚Äã

A Payment represents a single payment transaction and exists in a well-defined state defined by the PaymentState type.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Payment extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<Payment>)    @Column() method: string;    @Money() amount: number;    @Column('varchar') state: PaymentState;    @Column({ type: 'varchar', nullable: true })    errorMessage: string | undefined;    @Column({ nullable: true })    transactionId: string;    @Column('simple-json') metadata: PaymentMetadata;    @Index()    @ManyToOne(type => Order, order => order.payments)    order: Order;    @OneToMany(type => Refund, refund => refund.payment)    refunds: Refund[];    @Column(type => CustomPaymentFi
...
```

---

## TranslatorService

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/translator-service

**Contents:**
- TranslatorService
- TranslatorService‚Äã
  - constructor‚Äã
  - translate‚Äã

The TranslatorService is used to translate entities into the current language.

**Examples:**

Example 1 (ts):
```ts
import { Injectable } from '@nestjs/common';import { ID, Product, RequestContext, TransactionalConnection, TranslatorService } from '@vendure/core';@Injectable()export class ProductService {    constructor(private connection: TransactionalConnection,                private translator: TranslatorService){}    async findOne(ctx: RequestContext, productId: ID): Promise<Product | undefined> {        const product = await this.connection.findOneInChannel(ctx, Product, productId, ctx.channelId, {            relations: {                 facetValues: {                     facet: true,                 
...
```

Example 2 (ts):
```ts
class TranslatorService {    constructor(configService: ConfigService)    translate(translatable: T, ctx: RequestContext, translatableRelations: DeepTranslatableRelations<T> = []) => ;}
```

---

## Populate

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/populate

**Contents:**
- Populate
- populate‚Äã
  - bootstrapFn‚Äã
  - initialDataPathOrObject‚Äã
  - productsCsvPath‚Äã
  - channelOrToken‚Äã

Populates the Vendure server with some initial data and (optionally) product data from a supplied CSV file. The format of the CSV file is described in the section Importing Product Data.

If the channelOrToken argument is provided, all ChannelAware entities (Products, ProductVariants, Assets, ShippingMethods, PaymentMethods etc.) will be assigned to the specified Channel. The argument can be either a Channel object or a valid channel token.

Internally the populate() function does the following:

**Examples:**

Example 1 (ts):
```ts
import { bootstrap } from '@vendure/core';import { populate } from '@vendure/core/cli';import { config } from './vendure-config.ts'import { initialData } from './my-initial-data.ts';const productsCsvFile = path.join(__dirname, 'path/to/products.csv')populate(  () => bootstrap(config),  initialData,  productsCsvFile,).then(app => app.close()).then(  () => process.exit(0),  err => {    console.log(err);    process.exit(1);  },);
```

Example 2 (ts):
```ts
function populate<T extends INestApplicationContext>(bootstrapFn: () => Promise<T | undefined>, initialDataPathOrObject: string | object, productsCsvPath?: string, channelOrToken?: string | import('@vendure/core').Channel): Promise<T>
```

---

## MoneyStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/money/money-strategy/

**Contents:**
- MoneyStrategy
- MoneyStrategy‚Äã
- Range‚Äã
- Precision‚Äã
  - moneyColumnOptions‚Äã
  - precision‚Äã
  - round‚Äã

The MoneyStrategy defines how monetary values are stored and manipulated. The MoneyStrategy is defined in EntityOptions:

The DefaultMoneyStrategy uses an int field in the database, which puts an effective limit of ~21.4 million on any stored value. For certain use cases (e.g. business sales with very high amounts, or currencies with very large denominations), this may cause issues. In this case, you can use the BigIntMoneyStrategy which will use the bigint type to store monetary values, giving an effective upper limit of over 9 quadrillion.

Both the DefaultMoneyStrategy and BigIntMoneyStrategy store monetary values as integers, representing the price in the minor units of the currency (i.e. cents in USD or pennies in GBP).

Since v2.2.0, you can configure the precision of the stored values via the precision property of the strategy. Changing the precision has no effect on the stored value. It is merely a hint to the UI as to how many decimal places to display.

This is configured via the entityOptions.moneyStrategy property of your VendureConfig.

Defines the TypeORM column used to store monetary values.

Defines the precision (i.e. number of decimal places) represented by the monetary values. For example, consider a product variant with a price value of 12345.

Changing the precision has no effect on the stored value. It is merely a hint to the UI as to how many decimal places to display.

Defines the logic used to round monetary values. For instance, the default behavior in the DefaultMoneyStrategy is to round the value, then multiply.

However, it may be desirable to instead round only after the unit amount has been multiplied. In this case you can define a custom strategy with logic like this:

**Examples:**

Example 1 (ts):
```ts
const config: VendureConfig = {  entityOptions: {    moneyStrategy: new MyCustomMoneyStrategy(),  }};
```

Example 2 (ts):
```ts
import { DefaultMoneyStrategy, VendureConfig } from '@vendure/core';export class ThreeDecimalPlacesMoneyStrategy extends DefaultMoneyStrategy {  readonly precision = 3;}export const config: VendureConfig = {  // ...  entityOptions: {    moneyStrategy: new ThreeDecimalPlacesMoneyStrategy(),  }};
```

Example 3 (ts):
```ts
interface MoneyStrategy extends InjectableStrategy {    readonly moneyColumnOptions: ColumnOptions;    readonly precision?: number;    round(value: number, quantity?: number): number;}
```

Example 4 (ts):
```ts
return Math.round(value * quantity);
```

---

## PaymentMethod

**URL:** https://docs.vendure.io/reference/typescript-api/entities/payment-method

**Contents:**
- PaymentMethod
- PaymentMethod‚Äã
  - constructor‚Äã
  - name‚Äã
  - code‚Äã
  - description‚Äã
  - translations‚Äã
  - enabled‚Äã
  - checker‚Äã
  - handler‚Äã

A PaymentMethod is created automatically according to the configured PaymentMethodHandlers defined in the PaymentOptions config.

Extends: VendureEntity

Implements: Translatable, ChannelAware, HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class PaymentMethod extends VendureEntity implements Translatable, ChannelAware, HasCustomFields {    constructor(input?: DeepPartial<PaymentMethod>)    name: LocaleString;    @Column({ default: '' }) code: string;    description: LocaleString;    @OneToMany(type => PaymentMethodTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<PaymentMethod>>;    @Column() enabled: boolean;    @Column('simple-json', { nullable: true }) checker: ConfigurableOperation | null;    @Column('simple-json') handler: ConfigurableOperation;    @ManyToMany(type => Channel,
...
```

---

## ImportExportOptions

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/import-export-options

**Contents:**
- ImportExportOptions
- ImportExportOptions‚Äã
  - importAssetsDir‚Äã
  - assetImportStrategy‚Äã

Options related to importing & exporting data.

The directory in which assets to be imported are located.

This strategy determines how asset files get imported based on the path given in the import CSV or via the AssetImporter getAssets() method.

**Examples:**

Example 1 (ts):
```ts
interface ImportExportOptions {    importAssetsDir?: string;    assetImportStrategy?: AssetImportStrategy;}
```

---

## VendurePlugin

**URL:** https://docs.vendure.io/reference/typescript-api/plugin/vendure-plugin

**Contents:**
- VendurePlugin
- VendurePlugin‚Äã
  - pluginMetadata‚Äã

The VendurePlugin decorator is a means of configuring and/or extending the functionality of the Vendure server. A Vendure plugin is a Nestjs Module, with optional additional metadata defining things like extensions to the GraphQL API, custom configuration or new database entities.

As well as configuring the app, a plugin may also extend the GraphQL schema by extending existing types or adding entirely new types. Database entities and resolvers can also be defined to handle the extended GraphQL types.

**Examples:**

Example 1 (ts):
```ts
import { Controller, Get } from '@nestjs/common';import { Ctx, PluginCommonModule, ProductService, RequestContext, VendurePlugin } from '@vendure/core';@Controller('products')export class ProductsController {    constructor(private productService: ProductService) {}    @Get()    findAll(@Ctx() ctx: RequestContext) {        return this.productService.findAll(ctx);    }}//A simple plugin which adds a REST endpoint for querying products.@VendurePlugin({    imports: [PluginCommonModule],    controllers: [ProductsController],})export class RestPlugin {}
```

Example 2 (ts):
```ts
function VendurePlugin(pluginMetadata: VendurePluginMetadata): ClassDecorator
```

---

## FacetValue

**URL:** https://docs.vendure.io/reference/typescript-api/entities/facet-value

**Contents:**
- FacetValue
- FacetValue‚Äã
  - constructor‚Äã
  - name‚Äã
  - code‚Äã
  - translations‚Äã
  - facet‚Äã
  - facetId‚Äã
  - customFields‚Äã
  - channels‚Äã

A particular value of a Facet.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware

**Examples:**

Example 1 (ts):
```ts
class FacetValue extends VendureEntity implements Translatable, HasCustomFields, ChannelAware {    constructor(input?: DeepPartial<FacetValue>)    name: LocaleString;    @Column() code: string;    @OneToMany(type => FacetValueTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<FacetValue>>;    @Index()    @ManyToOne(type => Facet, group => group.values, { onDelete: 'CASCADE' })    facet: Facet;    @EntityId()    facetId: ID;    @Column(type => CustomFacetValueFields)    customFields: CustomFacetValueFields;    @ManyToMany(type => Channel, channel =
...
```

---

## Types

**URL:** https://docs.vendure.io/reference/graphql-api/admin/object-types/

**Contents:**
- Types
- AddFulfillmentToOrderResult‚Äã
- AddManualPaymentToOrderResult‚Äã
- Address‚Äã
- Adjustment‚Äã
- Administrator‚Äã
- AdministratorList‚Äã
- Allocation‚Äã
- AlreadyRefundedError‚Äã
- ApplyCouponCodeResult‚Äã

---

## Customer

**URL:** https://docs.vendure.io/reference/typescript-api/entities/customer/

**Contents:**
- Customer
- Customer‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - title‚Äã
  - firstName‚Äã
  - lastName‚Äã
  - phoneNumber‚Äã
  - emailAddress‚Äã
  - groups‚Äã

This entity represents a customer of the store, typically an individual person. A Customer can be a guest, in which case it has no associated User. Customers with registered account will have an associated User entity.

Extends: VendureEntity

Implements: ChannelAware, HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class Customer extends VendureEntity implements ChannelAware, HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<Customer>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column({ nullable: true })    title: string;    @Column() firstName: string;    @Column() lastName: string;    @Column({ nullable: true })    phoneNumber: string;    @Column()    emailAddress: string;    @ManyToMany(type => CustomerGroup, group => group.customers)    @JoinTable()    groups: CustomerGroup[];    @OneToMany(type => Address, address => address.customer)    addresses: Ad
...
```

---

## UiExtensionBuildCommand

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/ui-extension-build-command

**Contents:**
- UiExtensionBuildCommand
- UiExtensionBuildCommand‚Äã

The package manager to use when invoking the Angular CLI to build UI extensions.

**Examples:**

Example 1 (ts):
```ts
type UiExtensionBuildCommand = 'npm' | 'yarn' | 'pnpm'
```

---

## TextInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/text-input

**Contents:**
- TextInput
- TextInput‚Äã

A component for displaying a text input.

---

## GetEntityOrThrowOptions

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/get-entity-or-throw-options

**Contents:**
- GetEntityOrThrowOptions
- GetEntityOrThrowOptions‚Äã
  - channelId‚Äã
  - retries‚Äã
  - retryDelay‚Äã
  - includeSoftDeleted‚Äã

Options used by the TransactionalConnection getEntityOrThrow method.

An optional channelId to limit results to entities assigned to the given Channel. Should only be used when getting entities that implement the ChannelAware interface.

If set to a positive integer, it will retry getting the entity in case it is initially not found.

Specifies the delay in ms to wait between retries.

If set to true, soft-deleted entities will be returned. Otherwise they will throw as if they did not exist.

**Examples:**

Example 1 (ts):
```ts
interface GetEntityOrThrowOptions<T = any> extends FindOneOptions<T> {    channelId?: ID;    retries?: number;    retryDelay?: number;    includeSoftDeleted?: boolean;}
```

---

## EmailEventListener

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-event-listener

**Contents:**
- EmailEventListener
- EmailEventListener‚Äã
  - type‚Äã
  - constructor‚Äã
  - on‚Äã

An EmailEventListener is used to listen for events and set up a EmailEventHandler which defines how an email will be generated from this event.

Defines the event to listen for.

**Examples:**

Example 1 (ts):
```ts
class EmailEventListener<T extends string> {    public type: T;    constructor(type: T)    on(event: Type<Event>) => EmailEventHandler<T, Event>;}
```

---

## DateTimeInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/date-time-input

**Contents:**
- DateTimeInput
- DateTimeInput‚Äã
  - props‚Äã

A component for selecting a date and time.

**Examples:**

Example 1 (ts):
```ts
function DateTimeInput(props: Readonly<DashboardFormComponentProps>): void
```

---

## ChangedPriceHandlingStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/changed-price-handling-strategy

**Contents:**
- ChangedPriceHandlingStrategy
- ChangedPriceHandlingStrategy‚Äã
  - handlePriceChange‚Äã

This strategy defines how we handle the situation where an item exists in an Order, and then later on another is added but in the meantime the price of the ProductVariant has changed.

By default, the latest price will be used. Any price changes resulting from using a newer price will be reflected in the GraphQL OrderLine.unitPrice[WithTax]ChangeSinceAdded field.

This is configured via the orderOptions.changedPriceHandlingStrategy property of your VendureConfig.

This method is called when adding to or adjusting OrderLines, if the latest price (as determined by the ProductVariant price, potentially modified by the configured OrderItemPriceCalculationStrategy) differs from the initial price at the time that the OrderLine was created.

**Examples:**

Example 1 (ts):
```ts
interface ChangedPriceHandlingStrategy extends InjectableStrategy {    handlePriceChange(        ctx: RequestContext,        current: PriceCalculationResult,        orderLine: OrderLine,        order: Order,    ): PriceCalculationResult | Promise<PriceCalculationResult>;}
```

---

## RevertLastMigration

**URL:** https://docs.vendure.io/reference/typescript-api/migration/revert-last-migration

**Contents:**
- RevertLastMigration
- revertLastMigration‚Äã
  - userConfig‚Äã

Reverts the last applied database migration. See TypeORM migration docs for more information about the underlying migration mechanism.

**Examples:**

Example 1 (ts):
```ts
function revertLastMigration(userConfig: Partial<VendureConfig>): void
```

---

## FacetValueService

**URL:** https://docs.vendure.io/reference/typescript-api/services/facet-value-service

**Contents:**
- FacetValueService
- FacetValueService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findAll‚Äã
  - findAll‚Äã
  - findAllList‚Äã
  - findOne‚Äã
  - findByIds‚Äã
  - findByFacetId‚Äã

Contains methods relating to FacetValue entities.

Returns a PaginatedList of FacetValues.

TODO: in v2 this should replace the findAll() method. A separate method was created just to avoid a breaking change in v1.9.

Returns all FacetValues belonging to the Facet with the given id.

Returns all FacetValues belonging to the Facet with the given id.

Checks for usage of the given FacetValues in any Products or Variants, and returns the counts.

**Examples:**

Example 1 (ts):
```ts
class FacetValueService {    constructor(connection: TransactionalConnection, translatableSaver: TranslatableSaver, configService: ConfigService, customFieldRelationService: CustomFieldRelationService, channelService: ChannelService, eventBus: EventBus, translator: TranslatorService, listQueryBuilder: ListQueryBuilder)    findAll(lang: LanguageCode) => Promise<Array<Translated<FacetValue>>>;    findAll(ctx: RequestContext, lang: LanguageCode) => Promise<Array<Translated<FacetValue>>>;    findAll(ctxOrLang: RequestContext | LanguageCode, lang?: LanguageCode) => Promise<Array<Translated<FacetVal
...
```

---

## EntityDuplicator

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/entity-duplicator

**Contents:**
- EntityDuplicator
- EntityDuplicator‚Äã
  - constructor‚Äã
  - duplicate‚Äã
- DuplicateEntityFn‚Äã
- EntityDuplicatorConfig‚Äã
  - requiresPermission‚Äã
  - forEntities‚Äã
  - duplicate‚Äã

An EntityDuplicator is used to define the logic for duplicating entities when the duplicateEntity mutation is called. This allows you to add support for duplication of both core and custom entities.

The duplicator then gets passed to your VendureConfig object:

A function which performs the duplication of an entity.

Configuration for creating a new EntityDuplicator.

The permissions required in order to execute this duplicator. If an array is passed, then the administrator must have at least one of the permissions in the array.

The entities for which this duplicator is able to duplicate.

The function which performs the duplication.

**Examples:**

Example 1 (ts):
```ts
import { Collection, LanguageCode, Permission  EntityDuplicator, TransactionalConnection, CollectionService } from '@vendure/core';let collectionService: CollectionService;let connection: TransactionalConnection;// This is just an example - we already ship with a built-in duplicator for Collections.const customCollectionDuplicator = new EntityDuplicator({    code: 'custom-collection-duplicator',    description: [{ languageCode: LanguageCode.en, value: 'Custom collection duplicator' }],    args: {        throwError: {            type: 'boolean',            defaultValue: false,        },    },  
...
```

Example 2 (ts):
```ts
import { VendureConfig, defaultEntityDuplicators } from '@vendure/core';import { customCollectionDuplicator } from './config/custom-collection-duplicator';export const config: VendureConfig = {   // ...   entityOptions: {     entityDuplicators: [         ...defaultEntityDuplicators,         customCollectionDuplicator,     ],   },};
```

Example 3 (ts):
```ts
class EntityDuplicator<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: EntityDuplicatorConfig<T>)    duplicate(input: {        ctx: RequestContext;        entityName: string;        id: ID;        args: ConfigArg[];    }) => Promise<VendureEntity>;}
```

Example 4 (ts):
```ts
type DuplicateEntityFn<T extends ConfigArgs> = (input: {    ctx: RequestContext;    entityName: string;    id: ID;    args: ConfigArgValues<T>;}) => Promise<VendureEntity>
```

---

## Mutations

**URL:** https://docs.vendure.io/reference/graphql-api/shop/mutations/

**Contents:**
- Mutations
- addItemToOrder‚Äã
- addItemsToOrder‚Äã
- addPaymentToOrder‚Äã
- adjustOrderLine‚Äã
- applyCouponCode‚Äã
- authenticate‚Äã
- createCustomerAddress‚Äã
- deleteCustomerAddress‚Äã
- login‚Äã

---

## Cache

**URL:** https://docs.vendure.io/reference/typescript-api/cache/

**Contents:**
- Cache
- Cache‚Äã
  - constructor‚Äã
  - get‚Äã
  - delete‚Äã
  - invalidateTags‚Äã

A convenience wrapper around the CacheService methods which provides a simple API for caching and retrieving data.

The advantage of using the Cache class rather than directly calling the CacheService methods is that it allows you to define a consistent way of generating cache keys and to set default cache options, and takes care of setting the value in cache if it does not already exist.

In most cases, using the Cache class will result in simpler and more readable code.

This class is normally created via the CacheService.createCache() method.

Retrieves the value from the cache if it exists, otherwise calls the getValueFn function to get the value, sets it in the cache and returns it.

Deletes one or more items from the cache.

Invalidates one or more tags in the cache.

**Examples:**

Example 1 (ts):
```ts
const cache = cacheService.createCache({  getKey: id => `ProductVariantIds:${id}`,  options: {    ttl: 1000 * 60 * 60,    tags: ['products'],  },});// This will fetch the value from the cache if it exists, or// fetch it from the ProductService if not, and then cache// using the key 'ProductVariantIds.${id}'.const variantIds = await cache.get(id, async () => {  const variants await ProductService.getVariantsByProductId(ctx, id) ;  // The cached value must be serializable, so we just return the ids  return variants.map(v => v.id);});
```

Example 2 (ts):
```ts
class Cache {    constructor(config: CacheConfig, cacheService: CacheService)    get(id: string | number, getValueFn: () => T | Promise<T>) => Promise<T>;    delete(id: string | number | Array<string | number>) => Promise<void>;    invalidateTags(tags: string[]) => Promise<void>;}
```

---

## Request

**URL:** https://docs.vendure.io/reference/typescript-api/request/

**Contents:**
- Request
- üìÑÔ∏è Allow Decorator
- üìÑÔ∏è Api Decorator
- üìÑÔ∏è ApiType
- üìÑÔ∏è Ctx Decorator
- üìÑÔ∏è Relations Decorator
- üìÑÔ∏è RequestContextService
- üìÑÔ∏è RequestContext
- üìÑÔ∏è Transaction Decorator

RequestContextService

---

## Payment

**URL:** https://docs.vendure.io/reference/typescript-api/payment/

**Contents:**
- Payment
- üìÑÔ∏è DefaultPaymentProcess
- üìÑÔ∏è DefaultRefundProcess
- üìÑÔ∏è DummyPaymentHandler
- üìÑÔ∏è PaymentMethodConfigOptions
- üìÑÔ∏è PaymentMethodEligibilityChecker
- üìÑÔ∏è PaymentMethodHandler
- üìÑÔ∏è Payment Method Types
- üìÑÔ∏è PaymentOptions
- üìÑÔ∏è PaymentProcess

defaultPaymentProcess

PaymentMethodConfigOptions

PaymentMethodEligibilityChecker

PaymentTransitionData

---

## User

**URL:** https://docs.vendure.io/reference/typescript-api/entities/user/

**Contents:**
- User
- User‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - identifier‚Äã
  - authenticationMethods‚Äã
  - verified‚Äã
  - roles‚Äã
  - lastLogin‚Äã
  - customFields‚Äã

A User represents any authenticated user of the Vendure API. This includes both Administrators as well as registered Customers.

Extends: VendureEntity

Implements: HasCustomFields, SoftDeletable

**Examples:**

Example 1 (ts):
```ts
class User extends VendureEntity implements HasCustomFields, SoftDeletable {    constructor(input?: DeepPartial<User>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column()    identifier: string;    @OneToMany(type => AuthenticationMethod, method => method.user)    authenticationMethods: AuthenticationMethod[];    @Column({ default: false })    verified: boolean;    @ManyToMany(type => Role)    @JoinTable()    roles: Role[];    @Column({ type: Date, nullable: true })    lastLogin: Date | null;    @Column(type => CustomUserFields)    customFields: CustomUserFields; 
...
```

---

## NavMenuItem

**URL:** https://docs.vendure.io/reference/admin-ui-api/nav-menu/nav-menu-item

**Contents:**
- NavMenuItem
- NavMenuItem‚Äã
  - id‚Äã
  - label‚Äã
  - routerLink‚Äã
  - onClick‚Äã
  - icon‚Äã
  - requiresPermission‚Äã
  - statusBadge‚Äã

A NavMenuItem is a menu item in the main (left-hand side) nav bar.

**Examples:**

Example 1 (ts):
```ts
interface NavMenuItem {    id: string;    label: string;    routerLink: RouterLinkDefinition;    onClick?: (event: MouseEvent) => void;    icon?: string;    requiresPermission?: string | ((userPermissions: string[]) => boolean);    statusBadge?: Observable<NavMenuBadge>;}
```

---

## ShippingCalculator

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-calculator

**Contents:**
- ShippingCalculator
- ShippingCalculator‚Äã
  - constructor‚Äã
- ShippingCalculationResult‚Äã
  - price‚Äã
  - priceIncludesTax‚Äã
  - taxRate‚Äã
  - metadata‚Äã
- CalculateShippingFn‚Äã

The ShippingCalculator is used by a ShippingMethod to calculate the price of shipping on a given Order.

The return value of the CalculateShippingFn.

The shipping price without any taxes.

Whether or not the given price already includes taxes.

The tax rate applied to the shipping price.

Arbitrary metadata may be returned from the calculation function. This can be used e.g. to return data on estimated delivery times or any other data which may be needed in the storefront application when listing eligible shipping methods.

A function which implements the specific shipping calculation logic. It takes an Order and an arguments object and should return the shipping price as an integer in cents.

Should return a ShippingCalculationResult object.

**Examples:**

Example 1 (ts):
```ts
const flatRateCalculator = new ShippingCalculator({  code: 'flat-rate-calculator',  description: [{ languageCode: LanguageCode.en, value: 'Default Flat-Rate Shipping Calculator' }],  args: {    rate: {      type: 'int',      ui: { component: 'currency-form-input' },    },    taxRate: {      type: 'int',      ui: { component: 'number-form-input', suffix: '%' },    },  },  calculate: (ctx, order, args) => {    return {      price: args.rate,      taxRate: args.taxRate,      priceIncludesTax: ctx.channel.pricesIncludeTax,    };  },});
```

Example 2 (ts):
```ts
class ShippingCalculator<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: ShippingCalculatorConfig<T>)}
```

Example 3 (ts):
```ts
interface ShippingCalculationResult {    price: number;    priceIncludesTax: boolean;    taxRate: number;    metadata?: Record<string, any>;}
```

Example 4 (ts):
```ts
type CalculateShippingFn<T extends ConfigArgs> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    method: ShippingMethod,) => CalculateShippingFnResult
```

---

## PasswordHashingStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/password-hashing-strategy

**Contents:**
- PasswordHashingStrategy
- PasswordHashingStrategy‚Äã
  - hash‚Äã
  - check‚Äã

Defines how user passwords get hashed when using the NativeAuthenticationStrategy.

This is configured via the authOptions.passwordHashingStrategy property of your VendureConfig.

**Examples:**

Example 1 (ts):
```ts
interface PasswordHashingStrategy extends InjectableStrategy {    hash(plaintext: string): Promise<string>;    check(plaintext: string, hash: string): Promise<boolean>;}
```

---

## Auth

**URL:** https://docs.vendure.io/reference/typescript-api/auth/

**Contents:**
- Auth
- üìÑÔ∏è AuthOptions
- üìÑÔ∏è AuthenticationStrategy
- üìÑÔ∏è BcryptPasswordHashingStrategy
- üìÑÔ∏è CookieOptions
- üìÑÔ∏è DefaultPasswordValidationStrategy
- üìÑÔ∏è DefaultSessionCacheStrategy
- üìÑÔ∏è DefaultVerificationTokenStrategy
- üìÑÔ∏è ExternalAuthenticationService
- üìÑÔ∏è InMemorySessionCacheStrategy

AuthenticationStrategy

BcryptPasswordHashingStrategy

DefaultPasswordValidationStrategy

DefaultSessionCacheStrategy

DefaultVerificationTokenStrategy

ExternalAuthenticationService

InMemorySessionCacheStrategy

NativeAuthenticationStrategy

NoopSessionCacheStrategy

PasswordHashingStrategy

PasswordValidationStrategy

SuperadminCredentials

VerificationTokenStrategy

---

## TestingLogger

**URL:** https://docs.vendure.io/reference/typescript-api/testing/testing-logger

**Contents:**
- TestingLogger
- TestingLogger‚Äã
  - constructor‚Äã
  - debugSpy‚Äã
  - errorSpy‚Äã
  - infoSpy‚Äã
  - verboseSpy‚Äã
  - warnSpy‚Äã
  - debug‚Äã
  - error‚Äã

The TestingLogger can be used in unit tests or e2e tests to make assertions on whether the various Logger methods have been called, and which arguments.

Here's some examples of how to use it in e2e tests and unit tests. In both cases we are using the Jest testing framework, but the TestingLogger should work with other similar frameworks (e.g. replacing jest.fn() with jasmine.createSpy()).

**Examples:**

Example 1 (ts):
```ts
// e2e test exampleimport { createTestEnvironment, TestingLogger } from '@vendure/testing';const testingLogger = new TestingLogger(() => jest.fn());const { server, adminClient, shopClient } = createTestEnvironment({  ...testConfig,  logger: testingLogger,});// e2e testing setup omittedit('should log an error', async () => {  // The `errorSpy` property exposes the Jest mock function  testingLogger.errorSpy.mockClear();  await doSomethingThatErrors();  expect(testingLogger.errorSpy).toHaveBeenCalled();});
```

Example 2 (ts):
```ts
// unit test exampleimport { Test } from '@nestjs/testing';import { Logger } from '@vendure/core';import { TestingLogger } from '@vendure/testing';beforeEach(async () => {  const moduleRef = await Test.createTestingModule({    // Nest testing setup omitted  }).compile();  Logger.useLogger(testingLogger);  moduleRef.useLogger(new Logger());}
```

Example 3 (ts):
```ts
class TestingLogger<Spy extends (...args: any[]) => any> implements VendureLogger {    constructor(createSpyFn: () => Spy)    debugSpy: Spy;    errorSpy: Spy;    infoSpy: Spy;    verboseSpy: Spy;    warnSpy: Spy;    debug(message: string, context?: string) => void;    error(message: string, context?: string, trace?: string) => void;    info(message: string, context?: string) => void;    verbose(message: string, context?: string) => void;    warn(message: string, context?: string) => void;}
```

---

## ShippingOptions

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-options/

**Contents:**
- ShippingOptions
- ShippingOptions‚Äã
  - shippingEligibilityCheckers‚Äã
  - shippingCalculators‚Äã
  - shippingLineAssignmentStrategy‚Äã
  - customFulfillmentProcess‚Äã
  - process‚Äã
  - fulfillmentHandlers‚Äã

An array of available ShippingEligibilityCheckers for use in configuring ShippingMethods

An array of available ShippingCalculators for use in configuring ShippingMethods

This strategy is used to assign a given ShippingLine to one or more OrderLines of the Order. This allows you to set multiple shipping methods for a single order, each assigned a different subset of OrderLines.

Allows the definition of custom states and transition logic for the fulfillment process state machine. Takes an array of objects implementing the FulfillmentProcess interface.

Allows the definition of custom states and transition logic for the fulfillment process state machine. Takes an array of objects implementing the FulfillmentProcess interface.

An array of available FulfillmentHandlers.

**Examples:**

Example 1 (ts):
```ts
interface ShippingOptions {    shippingEligibilityCheckers?: Array<ShippingEligibilityChecker<any>>;    shippingCalculators?: Array<ShippingCalculator<any>>;    shippingLineAssignmentStrategy?: ShippingLineAssignmentStrategy;    customFulfillmentProcess?: Array<FulfillmentProcess<any>>;    process?: Array<FulfillmentProcess<any>>;    fulfillmentHandlers?: Array<FulfillmentHandler<any>>;}
```

---

## StockMovementService

**URL:** https://docs.vendure.io/reference/typescript-api/services/stock-movement-service

**Contents:**
- StockMovementService
- StockMovementService‚Äã
  - shippingEligibilityCheckers‚Äã
  - shippingCalculators‚Äã
  - constructor‚Äã
  - getStockMovementsByProductVariantId‚Äã
  - adjustProductVariantStock‚Äã
  - createAllocationsForOrder‚Äã
  - createAllocationsForOrderLines‚Äã
  - createSalesForOrder‚Äã

Contains methods relating to StockMovement entities.

Returns a PaginatedList of all StockMovements associated with the specified ProductVariant.

Adjusts the stock level of the ProductVariant, creating a new StockAdjustment entity in the process.

Creates a new Allocation for each OrderLine in the Order. For ProductVariants which are configured to track stock levels, the ProductVariant.stockAllocated value is increased, indicating that this quantity of stock is allocated and cannot be sold.

Creates a new Allocation for each of the given OrderLines. For ProductVariants which are configured to track stock levels, the ProductVariant.stockAllocated value is increased, indicating that this quantity of stock is allocated and cannot be sold.

Creates Sales for each OrderLine in the Order. For ProductVariants which are configured to track stock levels, the ProductVariant.stockAllocated value is reduced and the stockOnHand value is also reduced by the OrderLine quantity, indicating that the stock is no longer allocated, but is actually sold and no longer available.

Creates a Cancellation for each of the specified OrderItems. For ProductVariants which are configured to track stock levels, the ProductVariant.stockOnHand value is increased for each Cancellation, allowing that stock to be sold again.

Creates a Release for each of the specified OrderItems. For ProductVariants which are configured to track stock levels, the ProductVariant.stockAllocated value is reduced, indicating that this stock is once again available to buy.

**Examples:**

Example 1 (ts):
```ts
class StockMovementService {    shippingEligibilityCheckers: ShippingEligibilityChecker[];    shippingCalculators: ShippingCalculator[];    constructor(connection: TransactionalConnection, listQueryBuilder: ListQueryBuilder, globalSettingsService: GlobalSettingsService, stockLevelService: StockLevelService, eventBus: EventBus, stockLocationService: StockLocationService)    getStockMovementsByProductVariantId(ctx: RequestContext, productVariantId: ID, options?: StockMovementListOptions) => Promise<PaginatedList<StockMovement>>;    adjustProductVariantStock(ctx: RequestContext, productVariantId:
...
```

---

## PostgresSearchStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/default-search-plugin/postgres-search-strategy

**Contents:**
- PostgresSearchStrategy
- PostgresSearchStrategy‚Äã
  - init‚Äã
  - getFacetValueIds‚Äã
  - getCollectionIds‚Äã
  - getSearchResults‚Äã
  - getTotalCount‚Äã

A weighted fulltext search for PostgeSQL.

**Examples:**

Example 1 (ts):
```ts
class PostgresSearchStrategy implements SearchStrategy {    init(injector: Injector) => ;    getFacetValueIds(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<Map<ID, number>>;    getCollectionIds(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<Map<ID, number>>;    getSearchResults(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<SearchResult[]>;    getTotalCount(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<number>;}
```

---

## SimpleGraphQLClient

**URL:** https://docs.vendure.io/reference/typescript-api/testing/simple-graph-qlclient

**Contents:**
- SimpleGraphQLClient
- SimpleGraphQLClient‚Äã
  - constructor‚Äã
  - setAuthToken‚Äã
  - setChannelToken‚Äã
  - getAuthToken‚Äã
  - query‚Äã
  - fetch‚Äã
  - queryStatus‚Äã
  - asUserWithCredentials‚Äã

A minimalistic GraphQL client for populating and querying test data.

Sets the authToken to be used in each GraphQL request.

Sets the authToken to be used in each GraphQL request.

Returns the authToken currently being used.

Performs both query and mutation operations.

Performs a raw HTTP request to the given URL, but also includes the authToken & channelToken headers if they have been set. Useful for testing non-GraphQL endpoints, e.g. for plugins which make use of REST controllers.

Performs a query or mutation and returns the resulting status code.

Attempts to log in with the specified credentials.

Logs in as the SuperAdmin user.

Logs out so that the client is then treated as an anonymous user.

Perform a file upload mutation.

Upload spec: https://github.com/jaydenseric/graphql-multipart-request-spec

Discussion of issue: https://github.com/jaydenseric/apollo-upload-client/issues/32

**Examples:**

Example 1 (ts):
```ts
class SimpleGraphQLClient {    constructor(vendureConfig: Required<VendureConfig>, apiUrl: string = '')    setAuthToken(token: string) => ;    setChannelToken(token: string | null) => ;    getAuthToken() => string;    query(query: DocumentNode | TypedDocumentNode<T, V>, variables?: V, queryParams?: QueryParams) => Promise<T>;    fetch(url: string, options: RequestInit = {}) => Promise<Response>;    queryStatus(query: DocumentNode, variables?: V) => Promise<number>;    asUserWithCredentials(username: string, password: string) => ;    asSuperAdmin() => ;    asAnonymousUser() => ;    fileUploadMu
...
```

Example 2 (ts):
```ts
// Testing a custom mutation:const result = await client.fileUploadMutation({  mutation: gql`    mutation AddSellerImages($input: AddSellerImagesInput!) {      addSellerImages(input: $input) {        id        name      }    }  `,  filePaths: ['./images/profile-picture.jpg', './images/logo.png'],  mapVariables: () => ({    name: "George's Pans",    profilePicture: null,  // corresponds to filePaths[0]    branding: {      logo: null  // corresponds to filePaths[1]    }  })});
```

---

## NativeAuthenticationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/native-authentication-strategy

**Contents:**
- NativeAuthenticationStrategy
- NativeAuthenticationStrategy‚Äã
  - name‚Äã
  - init‚Äã
  - defineInputType‚Äã
  - authenticate‚Äã
  - verifyUserPassword‚Äã

This strategy implements a username/password credential-based authentication, with the credentials being stored in the Vendure database. This is the default method of authentication, and it is advised to keep it configured unless there is a specific reason not to.

**Examples:**

Example 1 (ts):
```ts
class NativeAuthenticationStrategy implements AuthenticationStrategy<NativeAuthenticationData> {    readonly name = NATIVE_AUTH_STRATEGY_NAME;    init(injector: Injector) => ;    defineInputType() => DocumentNode;    authenticate(ctx: RequestContext, data: NativeAuthenticationData) => Promise<User | false>;    verifyUserPassword(ctx: RequestContext, userId: ID, password: string) => Promise<boolean>;}
```

---

## NavMenuSection

**URL:** https://docs.vendure.io/reference/admin-ui-api/nav-menu/nav-menu-section

**Contents:**
- NavMenuSection
- NavMenuSection‚Äã
  - id‚Äã
  - label‚Äã
  - items‚Äã
  - icon‚Äã
  - displayMode‚Äã
  - requiresPermission‚Äã
  - collapsible‚Äã
  - collapsedByDefault‚Äã

A NavMenuSection is a grouping of links in the main (left-hand side) nav bar.

Control the display of this item based on the user permissions. Note: if you attempt to pass a PermissionDefinition object, you will get a compilation error. Instead, pass the plain string version. For example, if the permission is defined as:

then the generated permission strings will be:

**Examples:**

Example 1 (ts):
```ts
interface NavMenuSection {    id: string;    label: string;    items: NavMenuItem[];    icon?: string;    displayMode?: 'regular' | 'settings';    requiresPermission?: string | ((userPermissions: string[]) => boolean);    collapsible?: boolean;    collapsedByDefault?: boolean;}
```

Example 2 (ts):
```ts
export const MyPermission = new PermissionDefinition('ProductReview');
```

---

## VendureConfig

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/vendure-config/

**Contents:**
- VendureConfig
- VendureConfig‚Äã
  - apiOptions‚Äã
  - assetOptions‚Äã
  - authOptions‚Äã
  - catalogOptions‚Äã
  - customFields‚Äã
  - settingsStoreFields‚Äã
  - dbConnectionOptions‚Äã
  - defaultChannelToken‚Äã

All possible configuration options are defined by the VendureConfig interface.

Configuration for the GraphQL APIs, including hostname, port, CORS settings, middleware etc.

Configuration for the handling of Assets.

Configuration for authorization.

Configuration for Products and Collections.

Defines custom fields which can be used to extend the built-in entities.

Defines key-value fields that can be set and read via the getKeyValue/setKeyValue GraphQL APIs and via the SettingsStoreService. These differ from custom fields in that they are not associated with a specific entity, but can be scoped globally or to a specific user etc, and defining them does not require any changes to the database schema.

The connection options used by TypeORM to connect to the database. See the TypeORM documentation for a full description of all available options.

The token for the default channel. If not specified, a token will be randomly generated.

The default languageCode of the app.

Defines the strategy used for both storing the primary keys of entities in the database, and the encoding & decoding of those ids when exposing entities via the API. The default uses a simple auto-increment integer strategy.

Configuration settings for data import and export.

Configuration settings governing how orders are handled.

Configures available payment processing methods.

Configures the Conditions and Actions available when creating Promotions.

Configures the available checkers and calculators for ShippingMethods.

Provide a logging service which implements the VendureLogger interface. Note that the logging of SQL queries is controlled separately by the dbConnectionOptions.logging property.

Configures how taxes are calculated on products.

Configures how the job queue is persisted and processed.

Configures the scheduler mechanism and tasks.

Configures system options

**Examples:**

Example 1 (ts):
```ts
interface VendureConfig {    apiOptions: ApiOptions;    assetOptions?: AssetOptions;    authOptions: AuthOptions;    catalogOptions?: CatalogOptions;    customFields?: CustomFields;    settingsStoreFields?: SettingsStoreFields;    dbConnectionOptions: DataSourceOptions;    defaultChannelToken?: string | null;    defaultLanguageCode?: LanguageCode;    entityIdStrategy?: EntityIdStrategy<any>;    entityOptions?: EntityOptions;    importExportOptions?: ImportExportOptions;    orderOptions?: OrderOptions;    paymentOptions: PaymentOptions;    plugins?: Array<DynamicModule | Type<any>>;    promotio
...
```

---

## TaxZoneStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/tax/tax-zone-strategy

**Contents:**
- TaxZoneStrategy
- TaxZoneStrategy‚Äã
  - determineTaxZone‚Äã

Defines how the active Zone is determined for the purposes of calculating taxes.

This strategy is used in 2 scenarios:

Note that this method is called very often in a typical user session, so any work it performs should be designed with as little performance impact as possible.

This is configured via the taxOptions.taxZoneStrategy property of your VendureConfig.

**Examples:**

Example 1 (ts):
```ts
interface TaxZoneStrategy extends InjectableStrategy {    determineTaxZone(        ctx: RequestContext,        zones: Zone[],        channel: Channel,        order?: Order,    ): Zone | Promise<Zone> | undefined;}
```

---

## Tag

**URL:** https://docs.vendure.io/reference/typescript-api/entities/tag/

**Contents:**
- Tag
- Tag‚Äã
  - constructor‚Äã
  - value‚Äã

A tag is an arbitrary label which can be applied to certain entities. It is used to help organize and filter those entities.

**Examples:**

Example 1 (ts):
```ts
class Tag extends VendureEntity {    constructor(input?: DeepPartial<Tag>)    @Column()    value: string;}
```

---

## Enums

**URL:** https://docs.vendure.io/reference/graphql-api/shop/enums

**Contents:**
- Enums
- AdjustmentType‚Äã
- AssetType‚Äã
- CurrencyCode‚Äã
- DeletionResult‚Äã
- ErrorCode‚Äã
- GlobalFlag‚Äã
- HistoryEntryType‚Äã
- LanguageCode‚Äã
- LogicalOperator‚Äã

---

## Ui Devkit

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/

**Contents:**
- Ui Devkit
- üìÑÔ∏è AdminUiExtension
- üìÑÔ∏è CompileUiExtensions
- üìÑÔ∏è Helpers
- üìÑÔ∏è UiDevkitClient
- üìÑÔ∏è UiExtensionBuildCommand
- üìÑÔ∏è UiExtensionCompilerOptions
- üìÑÔ∏è UiExtensionCompilerProcessArgument

UiExtensionBuildCommand

UiExtensionCompilerOptions

UiExtensionCompilerProcessArgument

---

## RegisterCustomDetailComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-detail-components/register-custom-detail-component/

**Contents:**
- RegisterCustomDetailComponent
- registerCustomDetailComponent‚Äã
  - config‚Äã

Registers a CustomDetailComponent to be placed in a given location. This allows you to embed any type of custom Angular component in the entity detail pages of the Admin UI.

**Examples:**

Example 1 (ts):
```ts
import { Component, OnInit } from '@angular/core';import { switchMap } from 'rxjs';import { FormGroup } from '@angular/forms';import { CustomFieldConfig } from '@vendure/common/lib/generated-types';import {    DataService,    SharedModule,    CustomDetailComponent,    registerCustomDetailComponent,    GetProductWithVariants} from '@vendure/admin-ui/core';@Component({    template: `{{ extraInfo$ | async | json }}`,    standalone: true,    imports: [SharedModule],})export class ProductInfoComponent implements CustomDetailComponent, OnInit {    // These two properties are provided by Vendure and 
...
```

Example 2 (ts):
```ts
function registerCustomDetailComponent(config: CustomDetailComponentConfig): void
```

---

## Form Components

**URL:** https://docs.vendure.io/reference/dashboard/form-components/

**Contents:**
- Form Components
- üìÑÔ∏è AffixedInput
- üìÑÔ∏è BooleanInput
- üìÑÔ∏è CheckboxInput
- üìÑÔ∏è DateTimeInput
- üìÑÔ∏è FormFieldWrapper
- üìÑÔ∏è MoneyInput
- üìÑÔ∏è NumberInput
- üìÑÔ∏è PasswordInput
- üìÑÔ∏è RichTextInput

TranslatableFormFieldWrapper

---

## SettingsStoreFields

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/settings-store-fields

**Contents:**
- SettingsStoreFields
- SettingsStoreFields‚Äã
  - [index]‚Äã

This is how SettingsStoreFields are defined in the VendureConfig object.

**Examples:**

Example 1 (ts):
```ts
type SettingsStoreFields = {    [namespace: string]: SettingsStoreFieldConfig[];}
```

---

## Creating Detail Pages

**URL:** https://docs.vendure.io/guides/extending-the-dashboard/creating-pages/detail-pages

**Contents:**
- Creating Detail Pages
- Setup‚Äã
- Simple Detail Pages‚Äã
- Customizing the detail page‚Äã

This guide assumes you have a CmsPlugin with an Article entity, as covered in the Extending the Dashboard: Plugin Setup guide.

Detail pages can be created for any entity which has been exposed via the Admin API. Following the above setup of the CmsPlugin will result in the following additions to your API schema:

Now let's create a detail page so we can start adding articles.

We'll begin with the simplest approach, where the form will be auto-generated for us based on the GraphQL schema using the DetailPage component. This is useful for quickly getting started, but you can also to customize the form later on.

Create a new file called article-detail.tsx in the ./src/plugins/cms/dashboard directory:

Now we can register this route in our index.tsx file:

You should now be able to click on the "New article" button in the list view, and see the detail page:

Congratulations! You can now add, edit and delete articles in the dashboard.

The auto-generated DetailPage is a great way to get started and quickly be able to interact with your entities. But let's now see how we can fully customize the layout and form fields.

In the above example, we have:

**Examples:**

Example 1 (graphql):
```graphql
type Article implements Node {    id: ID!    createdAt: DateTime!    updatedAt: DateTime!    slug: String!    title: String!    body: String!    isPublished: Boolean!}type Query {    # ...    article(id: ID!): Article}type Mutation {    # ...    createArticle(input: CreateArticleInput!): Article!    updateArticle(input: UpdateArticleInput!): Article!    deleteArticle(id: ID!): DeletionResponse!}
```

Example 2 (tsx):
```tsx
import { DashboardRouteDefinition, DetailPage, detailPageRouteLoader } from '@vendure/dashboard';import { graphql } from '@/gql';const articleDetailDocument = graphql(`    query GetArticleDetail($id: ID!) {        article(id: $id) {            id            createdAt            updatedAt            isPublished            title            slug            body            customFields        }    }`);const createArticleDocument = graphql(`    mutation CreateArticle($input: CreateArticleInput!) {        createArticle(input: $input) {            id        }    }`);const updateArticleDocument = grap
...
```

Example 3 (tsx):
```tsx
import { defineDashboardExtension } from '@vendure/dashboard';import { articleList } from './article-list';import { articleDetail } from './article-detail';defineDashboardExtension({    routes: [        articleList,        articleDetail,    ],});
```

Example 4 (tsx):
```tsx
import {    DashboardRouteDefinition,    detailPageRouteLoader,    useDetailPage,    Page,    PageTitle,    PageActionBar,    PageActionBarRight,    PermissionGuard,    Button,    PageLayout,    PageBlock,    FormFieldWrapper,    DetailFormGrid,    Switch,    Input,    RichTextInput,    CustomFieldsPageBlock,} from '@vendure/dashboard';import { AnyRoute, useNavigate } from '@tanstack/react-router';import { toast } from 'sonner';import { graphql } from '@/gql';const articleDetailDocument = graphql(`    query GetArticleDetail($id: ID!) {        article(id: $id) {            id            created
...
```

---

## Tabs

**URL:** https://docs.vendure.io/reference/admin-ui-api/tabs/

**Contents:**
- Tabs
- üìÑÔ∏è PageTabConfig
- üìÑÔ∏è RegisterPageTab

---

## RedisCachePlugin

**URL:** https://docs.vendure.io/reference/typescript-api/cache/redis-cache-plugin

**Contents:**
- RedisCachePlugin
- RedisCachePlugin‚Äã
  - options‚Äã
  - init‚Äã
- RedisCachePluginInitOptions‚Äã
  - maxItemSizeInBytes‚Äã
  - namespace‚Äã
  - redisOptions‚Äã

This plugin provides a Redis-based RedisCacheStrategy which stores cached items in a Redis instance. This is a high-performance cache strategy which is suitable for production use, and is a drop-in replacement for the DefaultCachePlugin.

Note: To use this plugin, you need to manually install the ioredis package:

Configuration options for the RedisCachePlugin.

The maximum size of a single cache item in bytes. If a cache item exceeds this size, it will not be stored and an error will be logged.

The namespace to use for all keys stored in Redis. This can be useful if you are sharing a Redis instance between multiple applications.

Options to pass to the ioredis Redis client.

**Examples:**

Example 1 (shell):
```shell
npm install ioredis@^5.3.2
```

Example 2 (ts):
```ts
class RedisCachePlugin {    static options: RedisCachePluginInitOptions = {        maxItemSizeInBytes: 128_000,        redisOptions: {},        namespace: 'vendure-cache',    };    init(options: RedisCachePluginInitOptions) => ;}
```

Example 3 (ts):
```ts
interface RedisCachePluginInitOptions {    maxItemSizeInBytes?: number;    namespace?: string;    redisOptions?: import('ioredis').RedisOptions;}
```

---

## ShippingMethodService

**URL:** https://docs.vendure.io/reference/typescript-api/services/shipping-method-service

**Contents:**
- ShippingMethodService
- ShippingMethodService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - softDelete‚Äã
  - assignShippingMethodsToChannel‚Äã
  - removeShippingMethodsFromChannel‚Äã

Contains methods relating to ShippingMethod entities.

**Examples:**

Example 1 (ts):
```ts
class ShippingMethodService {    constructor(connection: TransactionalConnection, configService: ConfigService, roleService: RoleService, listQueryBuilder: ListQueryBuilder, channelService: ChannelService, configArgService: ConfigArgService, translatableSaver: TranslatableSaver, customFieldRelationService: CustomFieldRelationService, eventBus: EventBus, translator: TranslatorService)    findAll(ctx: RequestContext, options?: ListQueryOptions<ShippingMethod>, relations: RelationPaths<ShippingMethod> = []) => Promise<PaginatedList<Translated<ShippingMethod>>>;    findOne(ctx: RequestContext, shi
...
```

---

## CdsIcon

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/cds-icon

**Contents:**
- CdsIcon
- CdsIcon‚Äã
  - props‚Äã

A React wrapper for the Clarity UI icon component.

**Examples:**

Example 1 (ts):
```ts
import { userIcon } from '@cds/core/icon';import { CdsIcon } from '@vendure/admin-ui/react';registerCdsIcon(userIcon);export function MyComponent() {   return <CdsIcon icon={userIcon} badge="warning" solid size="lg"></CdsIcon>;}
```

Example 2 (ts):
```ts
function CdsIcon(props: { icon: IconShapeTuple; className?: string } & Partial<CdsIconProps>): void
```

---

## SessionCacheStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/session-cache-strategy

**Contents:**
- SessionCacheStrategy
- SessionCacheStrategy‚Äã
  - set‚Äã
  - get‚Äã
  - delete‚Äã
  - clear‚Äã
- CachedSessionUser‚Äã
  - id‚Äã
  - identifier‚Äã
  - verified‚Äã

This strategy defines how sessions get cached. Since most requests will need the Session object for permissions data, it can become a bottleneck to go to the database and do a multi-join SQL query each time. Therefore, we cache the session data only perform the SQL query once and upon invalidation of the cache.

The Vendure default from v3.1+ is to use a the DefaultSessionCacheStrategy, which delegates to the configured CacheStrategy to store the session data. This should be suitable for most use-cases.

If you are using v3.1 or later, you should not normally need to implement a custom SessionCacheStrategy, since this is now handled by the DefaultSessionCacheStrategy.

Prior to v3.1, the default was to use the InMemorySessionCacheStrategy, which is fast but suitable for single-instance deployments.

This is configured via the authOptions.sessionCacheStrategy property of your VendureConfig.

Here's an example implementation using Redis. To use this, you need to add the ioredis package as a dependency.

Store the session in the cache. When caching a session, the data should not be modified apart from performing any transforms needed to get it into a state to be stored, e.g. JSON.stringify().

Retrieve the session from the cache

Delete a session from the cache

Clear the entire cache

A simplified representation of the User associated with the current Session.

A simplified representation of a Session which is easy to store.

The timestamp after which this cache entry is considered stale and a fresh copy of the data will be set. Based on the sessionCacheTTL option.

**Examples:**

Example 1 (ts):
```ts
import { CachedSession, Logger, SessionCacheStrategy, VendurePlugin } from '@vendure/core';import { Redis, RedisOptions } from 'ioredis';export interface RedisSessionCachePluginOptions {  namespace?: string;  redisOptions?: RedisOptions;}const loggerCtx = 'RedisSessionCacheStrategy';const DEFAULT_NAMESPACE = 'vendure-session-cache';const DEFAULT_TTL = 86400;export class RedisSessionCacheStrategy implements SessionCacheStrategy {  private client: Redis;  constructor(private options: RedisSessionCachePluginOptions) {}  init() {    this.client = new Redis(this.options.redisOptions as RedisOptions
...
```

Example 2 (ts):
```ts
interface SessionCacheStrategy extends InjectableStrategy {    set(session: CachedSession): void | Promise<void>;    get(sessionToken: string): CachedSession | undefined | Promise<CachedSession | undefined>;    delete(sessionToken: string): void | Promise<void>;    clear(): void | Promise<void>;}
```

Example 3 (ts):
```ts
type CachedSessionUser = {    id: ID;    identifier: string;    verified: boolean;    channelPermissions: UserChannelPermissions[];}
```

Example 4 (ts):
```ts
type CachedSession = {    cacheExpiry: number;    id: ID;    token: string;    expires: Date;    activeOrderId?: ID;    authenticationStrategy?: string;    user?: CachedSessionUser;    activeChannelId?: ID;}
```

---

## OrderModifier

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/order-modifier

**Contents:**
- OrderModifier
- OrderModifier‚Äã
  - constructor‚Äã
  - constrainQuantityToSaleable‚Äã
  - getExistingOrderLine‚Äã
  - getOrCreateOrderLine‚Äã
  - updateOrderLineQuantity‚Äã
  - cancelOrderByOrderLines‚Äã
  - modifyOrder‚Äã
  - setShippingMethods‚Äã

This helper is responsible for modifying the contents of an Order.

Note: There is not a clear separation of concerns between the OrderService and this, since the OrderService also contains some method which modify the Order (e.g. removeItemFromOrder). So this helper was mainly extracted to isolate the huge modifyOrder method since the OrderService was just growing too large. Future refactoring could improve the organization of these Order-related methods into a more clearly-delineated set of classes.

Ensure that the ProductVariant has sufficient saleable stock to add the given quantity to an Order.

Given a ProductVariant ID and optional custom fields, this method will return an existing OrderLine that matches, or undefined if no match is found.

Returns the OrderLine containing the given ProductVariant, taking into account any custom field values. If no existing OrderLine is found, a new OrderLine will be created.

Updates the quantity of an OrderLine, taking into account the available saleable stock level. Returns the actual quantity that the OrderLine was updated to (which may be less than the quantity argument if insufficient stock was available.

**Examples:**

Example 1 (ts):
```ts
class OrderModifier {    constructor(connection: TransactionalConnection, configService: ConfigService, orderCalculator: OrderCalculator, paymentService: PaymentService, countryService: CountryService, stockMovementService: StockMovementService, productVariantService: ProductVariantService, customFieldRelationService: CustomFieldRelationService, promotionService: PromotionService, eventBus: EventBus, shippingCalculator: ShippingCalculator, historyService: HistoryService, translator: TranslatorService)    constrainQuantityToSaleable(ctx: RequestContext, variant: ProductVariant, quantity: number
...
```

---

## PaymentMethod

**URL:** https://docs.vendure.io/reference/typescript-api/entities/payment-method/

**Contents:**
- PaymentMethod
- PaymentMethod‚Äã
  - constructor‚Äã
  - name‚Äã
  - code‚Äã
  - description‚Äã
  - translations‚Äã
  - enabled‚Äã
  - checker‚Äã
  - handler‚Äã

A PaymentMethod is created automatically according to the configured PaymentMethodHandlers defined in the PaymentOptions config.

Extends: VendureEntity

Implements: Translatable, ChannelAware, HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class PaymentMethod extends VendureEntity implements Translatable, ChannelAware, HasCustomFields {    constructor(input?: DeepPartial<PaymentMethod>)    name: LocaleString;    @Column({ default: '' }) code: string;    description: LocaleString;    @OneToMany(type => PaymentMethodTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<PaymentMethod>>;    @Column() enabled: boolean;    @Column('simple-json', { nullable: true }) checker: ConfigurableOperation | null;    @Column('simple-json') handler: ConfigurableOperation;    @ManyToMany(type => Channel,
...
```

---

## DefaultSearchPlugin

**URL:** https://docs.vendure.io/reference/typescript-api/default-search-plugin/

**Contents:**
- DefaultSearchPlugin
- DefaultSearchPlugin‚Äã
  - options‚Äã
  - init‚Äã

The DefaultSearchPlugin provides a full-text Product search based on the full-text searching capabilities of the underlying database.

The DefaultSearchPlugin is bundled with the @vendure/core package. If you are not using an alternative search plugin, then make sure this one is used, otherwise you will not be able to search products via the search query.

Note that the quality of the fulltext search capabilities varies depending on the underlying database being used. For example, the MySQL & Postgres implementations will typically yield better results than the SQLite implementation.

**Examples:**

Example 1 (ts):
```ts
import { DefaultSearchPlugin, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    DefaultSearchPlugin.init({      indexStockStatus: true,      bufferUpdates: true,    }),  ],};
```

Example 2 (ts):
```ts
class DefaultSearchPlugin implements OnApplicationBootstrap, OnApplicationShutdown {    static options: DefaultSearchPluginInitOptions = {};    init(options: DefaultSearchPluginInitOptions) => Type<DefaultSearchPlugin>;}
```

---

## RegisterAlert

**URL:** https://docs.vendure.io/reference/admin-ui-api/alerts/register-alert

**Contents:**
- RegisterAlert
- registerAlert‚Äã
  - config‚Äã

Registers an alert which can be displayed in the Admin UI alert dropdown in the top bar. The alert is configured using the AlertConfig object.

**Examples:**

Example 1 (ts):
```ts
function registerAlert(config: AlertConfig): void
```

---

## EntityRelationPaths

**URL:** https://docs.vendure.io/reference/typescript-api/common/entity-relation-paths

**Contents:**
- EntityRelationPaths
- EntityRelationPaths‚Äã

This type allows type-safe access to entity relations using strings with dot notation. It works to 2 levels deep.

In the above example, the type T1 will be a string union of all relations of the Product entity:

**Examples:**

Example 1 (ts):
```ts
type T1 = EntityRelationPaths<Product>;
```

Example 2 (ts):
```ts
type EntityRelationPaths<T extends VendureEntity> = | `customFields.${string}`    | PathsToStringProps1<T>    | Join<PathsToStringProps2<T>, '.'>    | TripleDotPath
```

---

## VendureEvent

**URL:** https://docs.vendure.io/reference/typescript-api/events/vendure-event

**Contents:**
- VendureEvent
- VendureEvent‚Äã
  - createdAt‚Äã
  - constructor‚Äã

The base class for all events used by the EventBus system.

**Examples:**

Example 1 (ts):
```ts
class VendureEvent {    public readonly createdAt: Date;    constructor()}
```

---

## UserService

**URL:** https://docs.vendure.io/reference/typescript-api/services/user-service

**Contents:**
- UserService
- UserService‚Äã
  - constructor‚Äã
  - getUserById‚Äã
  - getUserByEmailAddress‚Äã
  - createCustomerUser‚Äã
  - addNativeAuthenticationMethod‚Äã
  - createAdminUser‚Äã
  - softDelete‚Äã
  - setVerificationToken‚Äã

Contains methods relating to User entities.

Creates a new User with the special customer Role and using the NativeAuthenticationStrategy.

Adds a new NativeAuthenticationMethod to the User. If the AuthOptions requireVerification is set to true (as is the default), the User will be marked as unverified until the email verification flow is completed.

Creates a new verified User using the NativeAuthenticationStrategy.

Sets the NativeAuthenticationMethod verificationToken as part of the User email verification flow.

Verifies a verificationToken by looking for a User which has previously had it set using the setVerificationToken() method, and checks that the token is valid and has not expired.

If valid, the User will be set to verified: true.

Sets the NativeAuthenticationMethod passwordResetToken as part of the User password reset flow.

Verifies a passwordResetToken by looking for a User which has previously had it set using the setPasswordResetToken() method, and checks that the token is valid and has not expired.

If valid, the User's credentials will be updated with the new password.

Changes the User identifier without an email verification step, so this should be only used when an Administrator is setting a new email address.

Sets the NativeAuthenticationMethod identifierChangeToken as part of the User email address change flow.

Changes the User identifier as part of the storefront flow used by Customers to set a new email address, with the token previously set using the setIdentifierChangeToken() method.

Updates the password for a User with the NativeAuthenticationMethod.

**Examples:**

Example 1 (ts):
```ts
class UserService {    constructor(connection: TransactionalConnection, configService: ConfigService, roleService: RoleService, passwordCipher: PasswordCipher, verificationTokenGenerator: VerificationTokenGenerator, moduleRef: ModuleRef)    getUserById(ctx: RequestContext, userId: ID) => Promise<User | undefined>;    getUserByEmailAddress(ctx: RequestContext, emailAddress: string, userType?: 'administrator' | 'customer') => Promise<User | undefined>;    createCustomerUser(ctx: RequestContext, identifier: string, password?: string) => Promise<User | PasswordValidationError>;    addNativeAuthent
...
```

---

## DefaultCachePlugin

**URL:** https://docs.vendure.io/reference/typescript-api/cache/default-cache-plugin

**Contents:**
- DefaultCachePlugin
- DefaultCachePlugin‚Äã
  - options‚Äã
  - init‚Äã
- DefaultCachePluginInitOptions‚Äã
  - cacheSize‚Äã
  - cacheTtlProvider‚Äã

This plugin provides a simple SQL-based cache strategy SqlCacheStrategy which stores cached items in the database.

It is suitable for production use (including multi-instance setups). For increased performance you can also consider using the RedisCachePlugin.

Configuration options for the DefaultCachePlugin.

The maximum number of items to store in the cache. Once the cache reaches this size, the least-recently-used items will be evicted to make room for new items.

Optionally provide a custom CacheTtlProvider to control the TTL of cache items. This is useful for testing.

**Examples:**

Example 1 (ts):
```ts
class DefaultCachePlugin {    static options: DefaultCachePluginInitOptions = {        cacheSize: 10_000,    };    init(options: DefaultCachePluginInitOptions) => ;}
```

Example 2 (ts):
```ts
interface DefaultCachePluginInitOptions {    cacheSize?: number;    cacheTtlProvider?: CacheTtlProvider;}
```

---

## Address

**URL:** https://docs.vendure.io/reference/typescript-api/entities/address

**Contents:**
- Address
- Address‚Äã
  - constructor‚Äã
  - customer‚Äã
  - fullName‚Äã
  - company‚Äã
  - streetLine1‚Äã
  - streetLine2‚Äã
  - city‚Äã
  - province‚Äã

Represents a Customer's address.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Address extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<Address>)    @Index()    @ManyToOne(type => Customer, customer => customer.addresses)    customer: Customer;    @Column({ default: '' }) fullName: string;    @Column({ default: '' })    company: string;    @Column() streetLine1: string;    @Column({ default: '' })    streetLine2: string;    @Column({ default: '' }) city: string;    @Column({ default: '' })    province: string;    @Column({ default: '' }) postalCode: string;    @Index()    @ManyToOne(type => Country)    country: Country;    @Colu
...
```

---

## Vendure Admin UI API Docs

**URL:** https://docs.vendure.io/reference/admin-ui-api/

**Contents:**
- Vendure Admin UI API Docs

These APIs are used when building your own custom extensions to the Admin UI provided by the AdminUiPlugin.

All documentation in this section is auto-generated from the TypeScript & HTML source of the Vendure Admin UI package.

---

## Queries

**URL:** https://docs.vendure.io/reference/graphql-api/shop/queries/

**Contents:**
- Queries
- activeChannel‚Äã
- activeCustomer‚Äã
- activeOrder‚Äã
- activePaymentMethods‚Äã
- activeShippingMethods‚Äã
- availableCountries‚Äã
- collection‚Äã
- collections‚Äã
- eligiblePaymentMethods‚Äã

---

## PaginatedList

**URL:** https://docs.vendure.io/reference/typescript-api/common/paginated-list/

**Contents:**
- PaginatedList
- PaginatedList‚Äã
  - items‚Äã
  - totalItems‚Äã

A type describing the shape of a paginated list response. In Vendure, almost all list queries (products, collections, orders, customers etc) return an object of this type.

**Examples:**

Example 1 (ts):
```ts
type PaginatedList<T> = {    items: T[];    totalItems: number;}
```

---

## TaxRate

**URL:** https://docs.vendure.io/reference/typescript-api/entities/tax-rate

**Contents:**
- TaxRate
- TaxRate‚Äã
  - constructor‚Äã
  - name‚Äã
  - enabled‚Äã
  - value‚Äã
  - category‚Äã
  - categoryId‚Äã
  - zone‚Äã
  - zoneId‚Äã

A TaxRate defines the rate of tax to apply to a ProductVariant based on three factors:

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class TaxRate extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<TaxRate>)    @Column() name: string;    @Column() enabled: boolean;    @Column({ type: 'decimal', precision: 5, scale: 2, transformer: new DecimalTransformer() }) value: number;    @Index()    @ManyToOne(type => TaxCategory, taxCategory => taxCategory.taxRates)    category: TaxCategory;    @EntityId({ nullable: true })    categoryId: ID;    @Index()    @ManyToOne(type => Zone, zone => zone.taxRates)    zone: Zone;    @EntityId({ nullable: true })    zoneId: ID;    @Index()    @ManyToOne(type => 
...
```

---

## TranslatableSaver

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/translatable-saver

**Contents:**
- TranslatableSaver
- TranslatableSaver‚Äã
  - constructor‚Äã
  - create‚Äã
  - update‚Äã

A helper which contains methods for creating and updating entities which implement the Translatable interface.

Create a translatable entity, including creating any translation entities according to the translations array.

Update a translatable entity. Performs a diff of the translations array in order to perform the correct operation on the translations.

**Examples:**

Example 1 (ts):
```ts
export class MyService {  constructor(private translatableSaver: TranslatableSaver) {}  async create(ctx: RequestContext, input: CreateFacetInput): Promise<Translated<Facet>> {    const facet = await this.translatableSaver.create({      ctx,      input,      entityType: Facet,      translationType: FacetTranslation,      beforeSave: async f => {          f.code = await this.ensureUniqueCode(ctx, f.code);      },    });    return facet;  }  // ...}
```

Example 2 (ts):
```ts
class TranslatableSaver {    constructor(connection: TransactionalConnection)    create(options: CreateTranslatableOptions<T>) => Promise<T>;    update(options: UpdateTranslatableOptions<T>) => Promise<T>;}
```

---

## Injector

**URL:** https://docs.vendure.io/reference/typescript-api/common/injector

**Contents:**
- Injector
- Injector‚Äã
  - constructor‚Äã
  - get‚Äã
  - resolve‚Äã

The Injector wraps the underlying Nestjs ModuleRef, allowing injection of providers known to the application's dependency injection container. This is intended to enable the injection of services into objects which exist outside of the Nestjs module system, e.g. the various Strategies which can be supplied in the VendureConfig.

Retrieve an instance of the given type from the app's dependency injection container. Wraps the Nestjs ModuleRef.get() method.

Retrieve an instance of the given scoped provider (transient or request-scoped) from the app's dependency injection container. Wraps the Nestjs ModuleRef.resolve() method.

**Examples:**

Example 1 (ts):
```ts
class Injector {    constructor(moduleRef: ModuleRef)    get(typeOrToken: Type<T> | string | symbol) => R;    resolve(typeOrToken: Type<T> | string | symbol, contextId?: ContextId) => Promise<R>;}
```

---

## Detail Views

**URL:** https://docs.vendure.io/reference/dashboard/detail-views/

**Contents:**
- Detail Views
- üìÑÔ∏è DetailPage
- üìÑÔ∏è UseDetailPage
- üìÑÔ∏è UseGeneratedForm

---

## Migration

**URL:** https://docs.vendure.io/reference/typescript-api/migration/

**Contents:**
- Migration
- üìÑÔ∏è GenerateMigration
- üìÑÔ∏è MigrationOptions
- üìÑÔ∏è RevertLastMigration
- üìÑÔ∏è RunMigrations

---

## EntitySlugService

**URL:** https://docs.vendure.io/reference/typescript-api/services/entity-slug-service

**Contents:**
- EntitySlugService
- EntitySlugService‚Äã
  - constructor‚Äã
  - generateSlugFromInput‚Äã

A service that handles slug generation for entities, ensuring uniqueness and handling conflicts by appending numbers.

Generates a slug from input value for an entity, ensuring uniqueness. Automatically detects if the field exists on the base entity or its translation entity.

**Examples:**

Example 1 (ts):
```ts
class EntitySlugService {    constructor(slugService: SlugService, connection: TransactionalConnection)    generateSlugFromInput(ctx: RequestContext, params: GenerateSlugFromInputParams) => Promise<string>;}
```

---

## Hooks

**URL:** https://docs.vendure.io/reference/dashboard/hooks/

**Contents:**
- Hooks
- üìÑÔ∏è UseAlerts
- üìÑÔ∏è UseAuth
- üìÑÔ∏è UseChannel
- üìÑÔ∏è UseCustomFieldConfig
- üìÑÔ∏è UseDisplayLocale
- üìÑÔ∏è UseLocalFormat
- üìÑÔ∏è UsePaginatedList
- üìÑÔ∏è UsePermissions
- üìÑÔ∏è UseUiLanguageLoader

---

## ApiOptions

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/api-options/

**Contents:**
- ApiOptions
- ApiOptions‚Äã
  - hostname‚Äã
  - port‚Äã
  - adminApiPath‚Äã
  - shopApiPath‚Äã
  - adminApiPlayground‚Äã
  - shopApiPlayground‚Äã
  - adminApiDebug‚Äã
  - shopApiDebug‚Äã

The ApiOptions define how the Vendure GraphQL APIs are exposed, as well as allowing the API layer to be extended with middleware.

Set the hostname of the server. If not set, the server will be available on localhost.

Which port the Vendure server should listen on.

The path to the admin GraphQL API.

The path to the shop GraphQL API.

The playground config to the admin GraphQL API ApolloServer playground.

The playground config to the shop GraphQL API ApolloServer playground.

The debug config to the admin GraphQL API ApolloServer playground.

The debug config to the shop GraphQL API ApolloServer playground.

The maximum number of items that may be returned by a query which returns a PaginatedList response. In other words, this is the upper limit of the take input option.

The maximum number of items that may be returned by a query which returns a PaginatedList response. In other words, this is the upper limit of the take input option.

Custom functions to use as additional validation rules when validating the schema for the admin GraphQL API ApolloServer validation rules.

Custom functions to use as additional validation rules when validating the schema for the shop GraphQL API ApolloServer validation rules.

The name of the property which contains the token of the active channel. This property can be included either in the request header or as a query string.

Set the CORS handling for the server. See the express CORS docs.

Custom Express or NestJS middleware for the server. More information can be found in the Middleware docs.

Set the trust proxy configuration for the server. See the express proxy docs.

Custom ApolloServerPlugins which allow the extension of the Apollo Server, which is the underlying GraphQL server used by Vendure.

Apollo plugins can be used e.g. to perform custom data transformations on incoming operations or outgoing data.

Controls whether introspection of the GraphQL APIs is enabled. For production, it is recommended to disable introspection, since exposing your entire schema can allow an attacker to trivially learn all operations and much more easily find any potentially exploitable queries.

Note: when introspection is disabled, tooling which relies on it for things like autocompletion will not work.

**Examples:**

Example 1 (ts):
```ts
interface ApiOptions {    hostname?: string;    port: number;    adminApiPath?: string;    shopApiPath?: string;    adminApiPlayground?: boolean | RenderPageOptions;    shopApiPlayground?: boolean | RenderPageOptions;    adminApiDebug?: boolean;    shopApiDebug?: boolean;    shopListQueryLimit?: number;    adminListQueryLimit?: number;    adminApiValidationRules?: Array<(context: ValidationContext) => any>;    shopApiValidationRules?: Array<(context: ValidationContext) => any>;    channelTokenKey?: string;    cors?: boolean | CorsOptions;    middleware?: Middleware[];    trustProxy?: TrustProx
...
```

Example 2 (ts):
```ts
{  introspection: process.env.NODE_ENV !== 'production'}
```

---

## PaymentProcess

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-process

**Contents:**
- PaymentProcess
- PaymentProcess‚Äã
  - transitions‚Äã
  - onTransitionStart‚Äã
  - onTransitionEnd‚Äã
  - onTransitionError‚Äã

A PaymentProcess is used to define the way the payment process works as in: what states a Payment can be in, and how it may transition from one state to another. Using the onTransitionStart() hook, a PaymentProcess can perform checks before allowing a state transition to occur, and the onTransitionEnd() hook allows logic to be executed after a state change.

For detailed description of the interface members, see the StateMachineConfig docs.

This is configured via the paymentOptions.process property of your VendureConfig.

**Examples:**

Example 1 (ts):
```ts
interface PaymentProcess<State extends keyof CustomPaymentStates | string> extends InjectableStrategy {    transitions?: Transitions<State, State | PaymentState> & Partial<Transitions<PaymentState | State>>;    onTransitionStart?: OnTransitionStartFn<State | PaymentState, PaymentTransitionData>;    onTransitionEnd?: OnTransitionEndFn<State | PaymentState, PaymentTransitionData>;    onTransitionError?: OnTransitionErrorFn<State | PaymentState>;}
```

---

## Region

**URL:** https://docs.vendure.io/reference/typescript-api/entities/region/

**Contents:**
- Region
- Region‚Äã
  - code‚Äã
  - type‚Äã
  - name‚Äã
  - parent‚Äã
  - parentId‚Äã
  - enabled‚Äã
  - translations‚Äã
  - customFields‚Äã

A Region represents a geographical administrative unit, such as a Country, Province, State, Prefecture etc. This is an abstract class which is extended by the Country and Province entities. Regions can be grouped into Zones which are in turn used to determine applicable shipping and taxes for an Order.

Extends: VendureEntity

Implements: Translatable, HasCustomFields

A code representing the region. The code format will depend on the type of region. For example, a Country code will be a 2-letter ISO code, whereas a Province code could use a format relevant to the type of province, e.g. a US state code like "CA".

**Examples:**

Example 1 (ts):
```ts
class Region extends VendureEntity implements Translatable, HasCustomFields {    @Column() code: string;    @Column({ nullable: false, type: 'varchar' })    readonly type: RegionType;    name: LocaleString;    @Index()    @ManyToOne(type => Region, { nullable: true, onDelete: 'SET NULL' })    parent?: Region;    @EntityId({ nullable: true })    parentId?: ID;    @Column() enabled: boolean;    @OneToMany(type => RegionTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<Region>>;    @Column(type => CustomRegionFields)    customFields: CustomRegionFie
...
```

---

## StateMachineConfig

**URL:** https://docs.vendure.io/reference/typescript-api/state-machine/state-machine-config

**Contents:**
- StateMachineConfig
- StateMachineConfig‚Äã
  - transitions‚Äã
  - onTransitionStart‚Äã
  - onTransitionEnd‚Äã
  - onError‚Äã
- OnTransitionStartFn‚Äã
- OnTransitionErrorFn‚Äã
- OnTransitionEndFn‚Äã

The config object used to instantiate a new FSM instance.

Defines the available states of the state machine as well as the permitted transitions from one state to another.

Called before a transition takes place. If the function resolves to false or a string, then the transition will be cancelled. In the case of a string, the string (error message) will be forwarded to the onError handler.

If this function returns a value resolving to true or void (no return value), then the transition will be permitted.

Called after a transition has taken place.

Called when a transition is prevented and the onTransitionStart handler has returned an error message.

Called before a transition takes place. If the function resolves to false or a string, then the transition will be cancelled. In the case of a string, the string (error message) will be forwarded to the onError handler.

If this function returns a value resolving to true or void (no return value), then the transition will be permitted.

Called when a transition is prevented and the onTransitionStart handler has returned an error message.

Called after a transition has taken place.

**Examples:**

Example 1 (ts):
```ts
interface StateMachineConfig<T extends string, Data = undefined> {    readonly transitions: Transitions<T>;    onTransitionStart?: OnTransitionStartFn<T, Data>;    onTransitionEnd?: OnTransitionEndFn<T, Data>;    onError?: OnTransitionErrorFn<T>;}
```

Example 2 (ts):
```ts
type OnTransitionStartFn<T extends string, Data> = (    fromState: T,    toState: T,    data: Data,) => boolean | string | void | Promise<boolean | string | void> | Observable<boolean | string | void>
```

Example 3 (ts):
```ts
type OnTransitionErrorFn<T extends string> = (    fromState: T,    toState: T,    message?: string,) => void | Promise<void> | Observable<void>
```

Example 4 (ts):
```ts
type OnTransitionEndFn<T extends string, Data> = (    fromState: T,    toState: T,    data: Data,) => void | Promise<void> | Observable<void>
```

---

## SessionService

**URL:** https://docs.vendure.io/reference/typescript-api/services/session-service

**Contents:**
- SessionService
- SessionService‚Äã
  - constructor‚Äã
  - onApplicationBootstrap‚Äã
  - createNewAuthenticatedSession‚Äã
  - createAnonymousSession‚Äã
  - getSessionFromToken‚Äã
  - serializeSession‚Äã
  - setActiveOrder‚Äã
  - unsetActiveOrder‚Äã

Contains methods relating to Session entities.

Creates a new AuthenticatedSession. To be used after successful authentication.

Create an AnonymousSession and caches it using the configured SessionCacheStrategy, and returns the cached session object.

Returns the cached session object matching the given session token.

Serializes a Session instance into a simplified plain object suitable for caching.

Sets the activeOrder on the given cached session object and updates the cache.

Clears the activeOrder on the given cached session object and updates the cache.

Sets the activeChannel on the given cached session object and updates the cache.

Deletes all existing sessions for the given user.

Deletes all existing sessions with the given activeOrder.

Triggers the clean sessions job.

Cleans expired sessions from the database & the session cache.

**Examples:**

Example 1 (ts):
```ts
class SessionService implements EntitySubscriberInterface, OnApplicationBootstrap {    constructor(connection: TransactionalConnection, configService: ConfigService, orderService: OrderService, jobQueueService: JobQueueService, requestContextService: RequestContextService)    onApplicationBootstrap() => ;    createNewAuthenticatedSession(ctx: RequestContext, user: User, authenticationStrategyName: string) => Promise<AuthenticatedSession>;    createAnonymousSession() => Promise<CachedSession>;    getSessionFromToken(sessionToken: string) => Promise<CachedSession | undefined>;    serializeSessio
...
```

---

## CreateTestEnvironment

**URL:** https://docs.vendure.io/reference/typescript-api/testing/create-test-environment/

**Contents:**
- CreateTestEnvironment
- createTestEnvironment‚Äã
  - config‚Äã

Configures a TestServer and a SimpleGraphQLClient for each of the GraphQL APIs for use in end-to-end tests. Returns a TestEnvironment object.

**Examples:**

Example 1 (ts):
```ts
import { createTestEnvironment, testConfig } from '@vendure/testing';describe('some feature to test', () => {  const { server, adminClient, shopClient } = createTestEnvironment(testConfig);  beforeAll(async () => {    await server.init({        // ... server options    });    await adminClient.asSuperAdmin();  });  afterAll(async () => {      await server.destroy();  });  // ... end-to-end tests here});
```

Example 2 (ts):
```ts
function createTestEnvironment(config: Required<VendureConfig>): TestEnvironment
```

---

## MolliePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/payments-plugin/mollie-plugin/

**Contents:**
- MolliePlugin
- MolliePlugin‚Äã
- Requirements‚Äã
- Setup‚Äã
- Storefront usage‚Äã
- Pay later methods‚Äã
- ArrangingAdditionalPayment state‚Äã
  - options‚Äã
  - init‚Äã
- MolliePluginOptions‚Äã

Plugin to enable payments through the Mollie platform. This plugin uses the Order API from Mollie, not the Payments API.

You will need to create a Mollie account and get your apiKey in the dashboard.

Install the Payments plugin and the Mollie client:

yarn add @vendure/payments-plugin @mollie/api-client

npm install @vendure/payments-plugin @mollie/api-client

In your storefront you add a payment to an order using the createMolliePaymentIntent mutation. In this example, our Mollie PaymentMethod was given the code "mollie-payment-method". The `redirectUrl``is the url that is used to redirect the end-user back to your storefront after completing the payment.

The response will contain a redirectUrl, which can be used to redirect your customer to the Mollie platform.

'molliePaymentMethodCode' is an optional parameter that can be passed to skip Mollie's hosted payment method selection screen You can get available Mollie payment methods with the following query:

After completing payment on the Mollie platform, the user is redirected to the redirect url that was provided in the createMolliePaymentIntent mutation, e.g. https://storefront/order/CH234X5

Mollie supports pay-later methods like 'Klarna Pay Later'. Pay-later methods are captured immediately after payment.

If your order fulfillment time is longer than 24 hours You should pass immediateCapture=false to the createMolliePaymentIntent mutation. This will transition your order to 'PaymentAuthorized' after the Mollie hosted checkout. You need to manually capture the payment after the order is fulfilled, by settling existing payments, either via the admin UI or in custom code.

Make sure to capture a payment within 28 days, after that the payment will be automaticallreleased. See the Mollie documentation for more information.

In some rare cases, a customer can add items to the active order, while a Mollie checkout is still open, for example by opening your storefront in another browser tab. This could result in an order being in ArrangingAdditionalPayment status after the customer finished payment. You should check if there is still an active order with status ArrangingAdditionalPayment on your order confirmation page, and if so, allow your customer to pay for the additional items by creating another Mollie payment.

Initialize the mollie payment plugin

Configuration options for the Mollie payments plugin.

The host of your Vendure server, e.g. 'https://my-vendure.io'. This is used by Mollie to send we

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { MolliePlugin } from '@vendure/payments-plugin/package/mollie';// ...plugins: [  MolliePlugin.init({ vendureHost: 'https://yourhost.io/' }),]
```

Example 2 (graphql):
```graphql
mutation CreateMolliePaymentIntent {  createMolliePaymentIntent(input: {    redirectUrl: "https://storefront/order/1234XYZ" // Optional, the fallback redirect url set in the admin UI will be used if not provided    paymentMethodCode: "mollie-payment-method" // Optional, the first method with Mollie as handler will be used if not provided    molliePaymentMethodCode: "ideal", // Optional argument to skip the method selection in the hosted checkout    locale: "nl_NL", // Optional, the browser language will be used by Mollie if not provided    immediateCapture: true, // Optional, default is true, 
...
```

Example 3 (graphql):
```graphql
{ molliePaymentMethods(input: { paymentMethodCode: "mollie-payment-method" }) {   id   code   description   minimumAmount {     value     currency   }   maximumAmount {     value     currency   }   image {     size1x     size2x     svg   } }}
```

Example 4 (ts):
```ts
class MolliePlugin {    static options: MolliePluginOptions;    init(options: MolliePluginOptions) => typeof MolliePlugin;}
```

---

## ReactDataTableComponentConfig

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/react-data-table-component-config

**Contents:**
- ReactDataTableComponentConfig
- ReactDataTableComponentConfig‚Äã
  - tableId‚Äã
  - columnId‚Äã
  - component‚Äã
  - props‚Äã

Configures a CustomDetailComponent to be placed in the given location.

The location in the UI where the custom component should be placed.

The column in the table where the custom component should be placed.

The component to render in the table cell. This component will receive the rowItem prop which is the data object for the row, e.g. the Product object if used in the product-list table.

Optional props to pass to the React component.

**Examples:**

Example 1 (ts):
```ts
interface ReactDataTableComponentConfig {    tableId: DataTableLocationId;    columnId: DataTableColumnId;    component: ElementType;    props?: Record<string, any>;}
```

---

## FacetService

**URL:** https://docs.vendure.io/reference/typescript-api/services/facet-service

**Contents:**
- FacetService
- FacetService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findByCode‚Äã
  - findByCode‚Äã
  - findByCode‚Äã
  - findByFacetValueId‚Äã
  - create‚Äã

Contains methods relating to Facet entities.

Returns the Facet which contains the given FacetValue id.

Assigns Facets to the specified Channel

Remove Facets from the specified Channel

**Examples:**

Example 1 (ts):
```ts
class FacetService {    constructor(connection: TransactionalConnection, facetValueService: FacetValueService, translatableSaver: TranslatableSaver, listQueryBuilder: ListQueryBuilder, configService: ConfigService, channelService: ChannelService, customFieldRelationService: CustomFieldRelationService, eventBus: EventBus, translator: TranslatorService, roleService: RoleService)    findAll(ctx: RequestContext, options?: ListQueryOptions<Facet>, relations?: RelationPaths<Facet>) => Promise<PaginatedList<Translated<Facet>>>;    findOne(ctx: RequestContext, facetId: ID, relations?: RelationPaths<Fa
...
```

---

## EmailSendEvent

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-send-event

**Contents:**
- EmailSendEvent
- EmailSendEvent‚Äã
  - constructor‚Äã

This event is fired when an email sending attempt has been made. If the sending was successful, the success property will be true, and if not, the error property will contain the error which occurred.

**Examples:**

Example 1 (ts):
```ts
class EmailSendEvent extends VendureEvent {    constructor(ctx: RequestContext, details: EmailDetails, success: boolean, error?: Error, metadata?: EmailMetadata)}
```

---

## TypedCustomSingleFieldConfig

**URL:** https://docs.vendure.io/reference/typescript-api/custom-fields/typed-custom-single-field-config

**Contents:**
- TypedCustomSingleFieldConfig
- TypedCustomSingleFieldConfig‚Äã

Configures a custom field on an entity in the CustomFields config object.

**Examples:**

Example 1 (ts):
```ts
type TypedCustomSingleFieldConfig<T extends CustomFieldType, C extends CustomField> = BaseTypedCustomFieldConfig<T, C> & {    list?: false;    defaultValue?: DefaultValueType<T>;    validate?: (        value: DefaultValueType<T>,        injector: Injector,        ctx: RequestContext,    ) => string | LocalizedString[] | void | Promise<string | LocalizedString[] | void>;}
```

---

## OrderByCodeAccessStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-by-code-access-strategy

**Contents:**
- OrderByCodeAccessStrategy
- OrderByCodeAccessStrategy‚Äã
  - canAccessOrder‚Äã
- DefaultOrderByCodeAccessStrategy‚Äã
  - constructor‚Äã
  - canAccessOrder‚Äã

The OrderByCodeAccessStrategy determines how access to a placed Order via the orderByCode query is granted. With a custom strategy anonymous access could be made permanent or tied to specific conditions like IP range or an Order status.

This example grants access to the requested Order to anyone ‚Äì unless it's Monday.

This is configured via the orderOptions.orderByCodeAccessStrategy property of your VendureConfig.

Gives or denies permission to access the requested Order

The default OrderByCodeAccessStrategy used by Vendure. It permitts permanent access to the Customer owning the Order and anyone within a given time period after placing the Order (defaults to 2h).

**Examples:**

Example 1 (ts):
```ts
export class NotMondayOrderByCodeAccessStrategy implements OrderByCodeAccessStrategy {    canAccessOrder(ctx: RequestContext, order: Order): boolean {        const MONDAY = 1;        const today = (new Date()).getDay();        return today !== MONDAY;    }}
```

Example 2 (ts):
```ts
interface OrderByCodeAccessStrategy extends InjectableStrategy {    canAccessOrder(ctx: RequestContext, order: Order): boolean | Promise<boolean>;}
```

Example 3 (ts):
```ts
class DefaultOrderByCodeAccessStrategy implements OrderByCodeAccessStrategy {    constructor(anonymousAccessDuration: string)    canAccessOrder(ctx: RequestContext, order: Order) => boolean;}
```

---

## HttpHealthCheckStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/health-check/http-health-check-strategy

**Contents:**
- HttpHealthCheckStrategy
- HttpHealthCheckStrategy‚Äã
  - constructor‚Äã
  - init‚Äã
  - getHealthIndicator‚Äã

A HealthCheckStrategy used to check health by pinging a url. Internally it uses the NestJS HttpHealthIndicator.

**Examples:**

Example 1 (ts):
```ts
import { HttpHealthCheckStrategy, TypeORMHealthCheckStrategy } from '@vendure/core';export const config = {  // ...  systemOptions: {    healthChecks: [      new TypeORMHealthCheckStrategy(),      new HttpHealthCheckStrategy({ key: 'my-service', url: 'https://my-service.com' }),    ]  },};
```

Example 2 (ts):
```ts
class HttpHealthCheckStrategy implements HealthCheckStrategy {    constructor(options: HttpHealthCheckOptions)    init(injector: Injector) => ;    getHealthIndicator() => HealthIndicatorFunction;}
```

---

## BooleanInput

**URL:** https://docs.vendure.io/reference/dashboard/form-components/boolean-input

**Contents:**
- BooleanInput
- BooleanInput‚Äã
  - props‚Äã

Displays a boolean value as a switch toggle.

**Examples:**

Example 1 (ts):
```ts
function BooleanInput(props: Readonly<DashboardFormComponentProps>): void
```

---

## RegisterAlert

**URL:** https://docs.vendure.io/reference/admin-ui-api/alerts/register-alert/

**Contents:**
- RegisterAlert
- registerAlert‚Äã
  - config‚Äã

Registers an alert which can be displayed in the Admin UI alert dropdown in the top bar. The alert is configured using the AlertConfig object.

**Examples:**

Example 1 (ts):
```ts
function registerAlert(config: AlertConfig): void
```

---

## EntityIdStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/entity-id-strategy/

**Contents:**
- EntityIdStrategy
- AutoIncrementIdStrategy‚Äã
  - primaryKeyType‚Äã
  - decodeId‚Äã
  - encodeId‚Äã
- EntityIdStrategy‚Äã
  - primaryKeyType‚Äã
  - encodeId‚Äã
  - decodeId‚Äã
- UuidIdStrategy‚Äã

An id strategy which uses auto-increment integers as primary keys for all entities. This is the default strategy used by Vendure.

The EntityIdStrategy determines how entity IDs are generated and stored in the database, as well as how they are transformed when being passed from the API to the service layer and vice versa.

Vendure ships with two strategies: AutoIncrementIdStrategy and UuidIdStrategy, but custom strategies can be used, e.g. to apply some custom encoding to the ID before exposing it in the GraphQL API.

This is configured via the entityOptions.entityIdStrategy property of your VendureConfig.

Note: changing from an integer-based strategy to a uuid-based strategy on an existing Vendure database will lead to problems with broken foreign-key references. To change primary key types like this, you'll need to start with a fresh database.

Defines how the primary key will be stored in the database - either 'increment' for auto-increment integer IDs, or 'uuid' for a unique string ID.

Allows the raw ID from the database to be transformed in some way before exposing it in the GraphQL API.

For example, you may need to use auto-increment integer IDs due to some business constraint, but you may not want to expose this data publicly in your API. In this case, you can use the encode/decode methods to obfuscate the ID with some kind of encoding scheme, such as base64 (or something more sophisticated).

Reverses the transformation performed by the encodeId method in order to get back to the raw ID value.

An id strategy which uses string uuids as primary keys for all entities. This strategy can be configured with the entityIdStrategy property of the entityOptions property of VendureConfig.

**Examples:**

Example 1 (ts):
```ts
class AutoIncrementIdStrategy implements EntityIdStrategy<'increment'> {    readonly primaryKeyType = 'increment';    decodeId(id: string) => number;    encodeId(primaryKey: number) => string;}
```

Example 2 (ts):
```ts
interface EntityIdStrategy<T extends 'increment' | 'uuid'> extends InjectableStrategy {    readonly primaryKeyType: T;    encodeId: (primaryKey: PrimaryKeyType<T>) => string;    decodeId: (id: string) => PrimaryKeyType<T>;}
```

Example 3 (ts):
```ts
import { UuidIdStrategy, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  entityOptions: {    entityIdStrategy: new UuidIdStrategy(),    // ...  }}
```

Example 4 (ts):
```ts
class UuidIdStrategy implements EntityIdStrategy<'uuid'> {    readonly primaryKeyType = 'uuid';    decodeId(id: string) => string;    encodeId(primaryKey: string) => string;}
```

---

## DashboardPluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/dashboard-plugin/dashboard-plugin-options

**Contents:**
- DashboardPluginOptions
- DashboardPluginOptions‚Äã
  - route‚Äã
  - appDir‚Äã
  - viteDevServerPort‚Äã

Configuration options for the DashboardPlugin.

The route to the Dashboard UI.

The path to the dashboard UI app dist directory.

The port on which to check for a running Vite dev server. If a Vite dev server is detected on this port, requests will be proxied to it instead of serving static files from appDir.

**Examples:**

Example 1 (ts):
```ts
interface DashboardPluginOptions {    route: string;    appDir: string;    viteDevServerPort?: number;}
```

---

## MultiChannelStockLocationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/multi-channel-stock-location-strategy

**Contents:**
- MultiChannelStockLocationStrategy
- MultiChannelStockLocationStrategy‚Äã
  - getAvailableStock‚Äã
  - forAllocation‚Äã

The MultiChannelStockLocationStrategy is an implementation of the StockLocationStrategy. which is suitable for both single- and multichannel setups. It takes into account the active channel when determining stock levels, and also ensures that allocations are made only against stock locations which are associated with the active channel.

This strategy became the default in Vendure 3.1.0. If you want to use the previous strategy which does not take channels into account, update your VendureConfig to use to DefaultStockLocationStrategy.

Returns the available stock for the given ProductVariant, taking into account the active Channel.

This method takes into account whether the stock location is applicable to the active channel. It furthermore respects the trackInventory and outOfStockThreshold settings of the ProductVariant, in order to allocate stock only from locations which are relevant to the active channel and which have sufficient stock available.

**Examples:**

Example 1 (ts):
```ts
class MultiChannelStockLocationStrategy extends BaseStockLocationStrategy {    getAvailableStock(ctx: RequestContext, productVariantId: ID, stockLevels: StockLevel[]) => Promise<AvailableStock>;    forAllocation(ctx: RequestContext, stockLocations: StockLocation[], orderLine: OrderLine, quantity: number) => Promise<LocationWithQuantity[]>;}
```

---

## ApiType

**URL:** https://docs.vendure.io/reference/typescript-api/request/api-type

**Contents:**
- ApiType
- ApiType‚Äã

Which of the GraphQL APIs the current request came via.

**Examples:**

Example 1 (ts):
```ts
type ApiType = 'admin' | 'shop' | 'custom'
```

---

## FacetValueChecker

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/facet-value-checker

**Contents:**
- FacetValueChecker
- FacetValueChecker‚Äã
  - constructor‚Äã
  - onModuleInit‚Äã
  - hasFacetValues‚Äã

The FacetValueChecker is a helper class used to determine whether a given OrderLine consists of ProductVariants containing the given FacetValues.

Checks a given OrderLine against the facetValueIds and returns true if the associated ProductVariant & Product together have all the specified FacetValues.

**Examples:**

Example 1 (ts):
```ts
import { FacetValueChecker, LanguageCode, PromotionCondition, TransactionalConnection } from '@vendure/core';let facetValueChecker: FacetValueChecker;export const hasFacetValues = new PromotionCondition({  code: 'at_least_n_with_facets',  description: [    { languageCode: LanguageCode.en, value: 'Buy at least { minimum } products with the given facets' },  ],  args: {    minimum: { type: 'int' },    facets: { type: 'ID', list: true, ui: { component: 'facet-value-form-input' } },  },  init(injector) {    facetValueChecker = injector.get(FacetValueChecker);  },  async check(ctx, order, args) {  
...
```

Example 2 (ts):
```ts
class FacetValueChecker implements OnModuleInit {    constructor(connection: TransactionalConnection, cacheService: CacheService, eventBus?: EventBus)    onModuleInit() => any;    hasFacetValues(orderLine: OrderLine, facetValueIds: ID[], ctx?: RequestContext) => Promise<boolean>;}
```

---

## VendureEntityEvent

**URL:** https://docs.vendure.io/reference/typescript-api/events/vendure-entity-event

**Contents:**
- VendureEntityEvent
- VendureEntityEvent‚Äã
  - entity‚Äã
  - type‚Äã
  - ctx‚Äã
  - input‚Äã
  - constructor‚Äã

The base class for all entity events used by the EventBus system.

**Examples:**

Example 1 (ts):
```ts
class VendureEntityEvent<Entity, Input = any> extends VendureEvent {    public readonly entity: Entity;    public readonly type: 'created' | 'updated' | 'deleted';    public readonly ctx: RequestContext;    public readonly input?: Input;    constructor(entity: Entity, type: 'created' | 'updated' | 'deleted', ctx: RequestContext, input?: Input)}
```

---

## AuthenticationMethod

**URL:** https://docs.vendure.io/reference/typescript-api/entities/authentication-method

**Contents:**
- AuthenticationMethod
- AuthenticationMethod‚Äã
  - user‚Äã
- ExternalAuthenticationMethod‚Äã
  - constructor‚Äã
  - strategy‚Äã
  - externalIdentifier‚Äã
  - metadata‚Äã
- NativeAuthenticationMethod‚Äã
  - constructor‚Äã

An AuthenticationMethod represents the means by which a User is authenticated. There are two kinds: NativeAuthenticationMethod and ExternalAuthenticationMethod.

This method is used when an external authentication service is used to authenticate Vendure Users. Examples of external auth include social logins or corporate identity servers.

This is the default, built-in authentication method which uses a identifier (typically username or email address) and password combination to authenticate a User.

A token issued when a User requests to change their identifier (typically an email address)

When a request has been made to change the User's identifier, the new identifier will be stored here until it has been verified, after which it will replace the current value of the identifier field.

**Examples:**

Example 1 (ts):
```ts
class AuthenticationMethod extends VendureEntity {    @Index()    @ManyToOne(type => User, user => user.authenticationMethods)    user: User;}
```

Example 2 (ts):
```ts
class ExternalAuthenticationMethod extends AuthenticationMethod {    constructor(input: DeepPartial<ExternalAuthenticationMethod>)    @Column()    strategy: string;    @Column()    externalIdentifier: string;    @Column('simple-json')    metadata: any;}
```

Example 3 (ts):
```ts
class NativeAuthenticationMethod extends AuthenticationMethod {    constructor(input?: DeepPartial<NativeAuthenticationMethod>)    @Column()    identifier: string;    @Column({ select: false }) passwordHash: string;    @Column({ type: 'varchar', nullable: true })    verificationToken: string | null;    @Column({ type: 'varchar', nullable: true })    passwordResetToken: string | null;    @Column({ type: 'varchar', nullable: true })    identifierChangeToken: string | null;    @Column({ type: 'varchar', nullable: true })    pendingIdentifier: string | null;}
```

---

## AsyncQueue

**URL:** https://docs.vendure.io/reference/typescript-api/common/async-queue

**Contents:**
- AsyncQueue
- AsyncQueue‚Äã
  - constructor‚Äã
  - push‚Äã

A queue class for limiting concurrent async tasks. This can be used e.g. to prevent race conditions when working on a shared resource such as writing to a database.

Pushes a new task onto the queue, upon which the task will either execute immediately or (if the number of running tasks is equal to the concurrency limit) enqueue the task to be executed at the soonest opportunity.

**Examples:**

Example 1 (ts):
```ts
class AsyncQueue {    constructor(label: string = 'default', concurrency: number = 1)    push(task: Task<T>) => Promise<T>;}
```

---

## CacheConfig

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/cache-config

**Contents:**
- CacheConfig
- CacheConfig‚Äã
  - maxAge‚Äã
  - restriction‚Äã

A configuration option for the Cache-Control header in the AssetServerPlugin asset response.

The max-age=N response directive indicates that the response remains fresh until N seconds after the response is generated.

The private response directive indicates that the response can be stored only in a private cache (e.g. local caches in browsers). The public response directive indicates that the response can be stored in a shared cache.

**Examples:**

Example 1 (ts):
```ts
type CacheConfig = {    maxAge: number;    restriction?: 'public' | 'private';}
```

---

## Province

**URL:** https://docs.vendure.io/reference/typescript-api/entities/province/

**Contents:**
- Province
- Province‚Äã
  - constructor‚Äã
  - type‚Äã

A Province represents an administrative subdivision of a Country. For example, in the United States, the country would be "United States" and the province would be "California".

**Examples:**

Example 1 (ts):
```ts
class Province extends Region {    constructor(input?: DeepPartial<Province>)    readonly type: RegionType = 'province';}
```

---

## Vendure API Reference

**URL:** https://docs.vendure.io/reference/

**Contents:**
- Vendure API Reference
  - TypeScript API‚Äã
  - Core Plugins‚Äã
  - GraphQL API‚Äã
  - Dashboard API‚Äã
  - Admin UI API (Deprecated)‚Äã

This section contains reference documentation for the various APIs exposed by Vendure.

All of the information in this section is generated directly from the Vendure source code. You can jump directly to the source file using the links below each heading.

These are the classes, interfaces and other TypeScript object which are used when writing plugins or custom business logic.

These are the TypeScript APIs for the core Vendure plugins.

These are the GraphQL APIs you will use to build your storefront (Shop API) or admin integrations (Admin API).

These are the React components & hooks you can use when building Dashboard extensions. Also see the Storybook component library for interactive examples.

These are the Angular components and services you can use when building Admin UI extensions with the deprecated Admin UI.

---

## RichTextEditor

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-components/rich-text-editor

**Contents:**
- RichTextEditor
- RichTextEditor‚Äã

A rich text editor component which uses ProseMirror (rich text editor) under the hood.

**Examples:**

Example 1 (ts):
```ts
import { RichTextEditor } from '@vendure/admin-ui/react';import React from 'react';export function MyComponent() {  const onSubmit = async (e: React.FormEvent) => {    e.preventDefault();    const form = new FormData(e.target as HTMLFormElement);    const content = form.get("content");    console.log(content);  };  return (    <form className="w-full" onSubmit={onSubmit}>      <RichTextEditor        name="content"        readOnly={false}        onMount={(e) => console.log("Mounted", e)}      />      <button type="submit" className="btn btn-primary">        Submit      </button>    </form>  );}
```

---

## LocalizedStringArray

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/localized-string-array/

**Contents:**
- LocalizedStringArray
- LocalizedStringArray‚Äã

An array of string values in a given LanguageCode, used to define human-readable string values. The ui property can be used in conjunction with the Vendure Admin UI to specify a custom form input component.

**Examples:**

Example 1 (ts):
```ts
const title: LocalizedStringArray = [  { languageCode: LanguageCode.en, value: 'English Title' },  { languageCode: LanguageCode.de, value: 'German Title' },  { languageCode: LanguageCode.zh, value: 'Chinese Title' },]
```

Example 2 (ts):
```ts
type LocalizedStringArray = Array<Omit<LocalizedString, '__typename'>>
```

---

## State Machine

**URL:** https://docs.vendure.io/reference/typescript-api/state-machine/

**Contents:**
- State Machine
- üìÑÔ∏è FSM
- üìÑÔ∏è StateMachineConfig
- üìÑÔ∏è Transitions

---

## FSM

**URL:** https://docs.vendure.io/reference/typescript-api/state-machine/fsm

**Contents:**
- FSM
- FSM‚Äã
  - constructor‚Äã
  - initialState‚Äã
  - currentState‚Äã
  - transitionTo‚Äã
  - jumpTo‚Äã
  - getNextStates‚Äã
  - canTransitionTo‚Äã

A simple type-safe finite state machine. This is used internally to control the Order process, ensuring that the state of Orders, Payments, Fulfillments and Refunds follows a well-defined behaviour.

**Examples:**

Example 1 (ts):
```ts
class FSM<T extends string, Data = any> {    constructor(config: StateMachineConfig<T, Data>, initialState: T)    initialState: T    currentState: T    transitionTo(state: T, data: Data) => Promise<{ finalize: () => Promise<any> }>;    jumpTo(state: T) => ;    getNextStates() => readonly T[];    canTransitionTo(state: T) => boolean;}
```

---

## MysqlSearchStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/default-search-plugin/mysql-search-strategy

**Contents:**
- MysqlSearchStrategy
- MysqlSearchStrategy‚Äã
  - init‚Äã
  - getFacetValueIds‚Äã
  - getCollectionIds‚Äã
  - getSearchResults‚Äã
  - getTotalCount‚Äã

A weighted fulltext search for MySQL / MariaDB.

**Examples:**

Example 1 (ts):
```ts
class MysqlSearchStrategy implements SearchStrategy {    init(injector: Injector) => ;    getFacetValueIds(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<Map<ID, number>>;    getCollectionIds(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<Map<ID, number>>;    getSearchResults(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<SearchResult[]>;    getTotalCount(ctx: RequestContext, input: SearchInput, enabledOnly: boolean) => Promise<number>;}
```

---

## Admin Ui

**URL:** https://docs.vendure.io/reference/typescript-api/common/admin-ui/

**Contents:**
- Admin Ui
- üìÑÔ∏è AdminUiAppConfig
- üìÑÔ∏è AdminUiAppDevModeConfig
- üìÑÔ∏è AdminUiConfig

AdminUiAppDevModeConfig

---

## DataTable2Component

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/data-table2component/

**Contents:**
- DataTable2Component
- DataTable2Component‚Äã
  - id‚Äã
  - items‚Äã
  - itemsPerPage‚Äã
  - currentPage‚Äã
  - totalItems‚Äã
  - emptyStateLabel‚Äã
  - filters‚Äã
  - activeIndex‚Äã

A table for displaying PaginatedList results. It is designed to be used inside components which extend the BaseListComponent or TypedBaseListComponent class.

**Examples:**

Example 1 (html):
```html
<vdr-data-table-2    id="product-review-list"    [items]="items$ | async"    [itemsPerPage]="itemsPerPage$ | async"    [totalItems]="totalItems$ | async"    [currentPage]="currentPage$ | async"    [filters]="filters"    (pageChange)="setPageNumber($event)"    (itemsPerPageChange)="setItemsPerPage($event)">    <vdr-bulk-action-menu        locationId="product-review-list"        [hostComponent]="this"        [selectionManager]="selectionManager"    />    <vdr-dt2-search        [searchTermControl]="searchTermControl"        searchTermPlaceholder="Filter by title"    />    <vdr-dt2-column [heading
...
```

Example 2 (ts):
```ts
class DataTable2Component<T> implements AfterContentInit, OnChanges, OnDestroy {    @Input() id: DataTableLocationId;    @Input() items: T[];    @Input() itemsPerPage: number;    @Input() currentPage: number;    @Input() totalItems: number;    @Input() emptyStateLabel: string;    @Input() filters: DataTableFilterCollection;    @Input() activeIndex = -1;    @Input() trackByPath = 'id';    @Output() pageChange = new EventEmitter<number>();    @Output() itemsPerPageChange = new EventEmitter<number>();    @Output() visibleColumnsChange = new EventEmitter<Array<DataTable2ColumnComponent<T>>>();    
...
```

---

## JobQueueOptions

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job-queue-options

**Contents:**
- JobQueueOptions
- JobQueueOptions‚Äã
  - jobQueueStrategy‚Äã
  - jobBufferStorageStrategy‚Äã
  - activeQueues‚Äã
  - prefix‚Äã

Options related to the built-in job queue.

Defines how the jobs in the queue are persisted and accessed.

Defines the queues that will run in this process. This can be used to configure only certain queues to run in this process. If its empty all queues will be run. Note: this option is primarily intended to apply to the Worker process. Jobs will always get published to the queue regardless of this setting, but this setting determines whether they get processed or not.

Prefixes all job queue names with the passed string. This is useful with multiple deployments in cloud environments using services such as Amazon SQS or Google Cloud Tasks.

For example, we might have a staging and a production deployment in the same account/project and each one will need its own task queue. We can achieve this with a prefix.

**Examples:**

Example 1 (ts):
```ts
interface JobQueueOptions {    jobQueueStrategy?: JobQueueStrategy;    jobBufferStorageStrategy?: JobBufferStorageStrategy;    activeQueues?: string[];    prefix?: string;}
```

---

## TypedBaseListComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/typed-base-list-component

**Contents:**
- TypedBaseListComponent
- TypedBaseListComponent‚Äã
  - availableLanguages$‚Äã
  - contentLanguage$‚Äã
  - dataService‚Äã
  - router‚Äã
  - serverConfigService‚Äã
  - permissionsService‚Äã
  - dataTableConfigService‚Äã
  - dataTableListId‚Äã

A version of the BaseListComponent which is designed to be used with a TypedDocumentNode.

Extends: BaseListComponent<ResultOf<T>, ItemOf<ResultOf<T>, Field>, VariablesOf<T>>

**Examples:**

Example 1 (ts):
```ts
class TypedBaseListComponent<T extends TypedDocumentNode<any, Vars>, Field extends keyof ResultOf<T>, Vars extends { options: { filter: any; sort: any } } = VariablesOf<T>> extends BaseListComponent<ResultOf<T>, ItemOf<ResultOf<T>, Field>, VariablesOf<T>> implements OnInit {    availableLanguages$: Observable<LanguageCode[]>;    contentLanguage$: Observable<LanguageCode>;    protected dataService = inject(DataService);    protected router = inject(Router);    protected serverConfigService = inject(ServerConfigService);    protected permissionsService = inject(PermissionsService);    protected 
...
```

---

## ConfigurableOperationDefOptions

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/configurable-operation-def-options

**Contents:**
- ConfigurableOperationDefOptions
- ConfigurableOperationDefOptions‚Äã
  - code‚Äã
  - args‚Äã
  - description‚Äã

Common configuration options used when creating a new instance of a ConfigurableOperationDef (

A unique code used to identify this operation.

Optional provider-specific arguments which, when specified, are editable in the admin-ui. For example, args could be used to store an API key for a payment provider service.

See ConfigArgs for available configuration options.

A human-readable description for the operation method.

**Examples:**

Example 1 (ts):
```ts
interface ConfigurableOperationDefOptions<T extends ConfigArgs> extends InjectableStrategy {    code: string;    args: T;    description: LocalizedStringArray;}
```

Example 2 (ts):
```ts
args: {  apiKey: { type: 'string' },}
```

---

## Routes

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/routes

**Contents:**
- Routes
- DashboardRouteDefinition‚Äã
  - component‚Äã
  - path‚Äã
  - navMenuItem‚Äã
  - loader‚Äã
  - validateSearch‚Äã
  - authenticated‚Äã

Defines a custom route for the dashboard with optional navigation menu integration.

The React component that will be rendered for this route.

The URL path for this route, e.g. '/my-custom-page'.

Optional navigation menu item configuration to add this route to the nav menu on the left side of the dashboard.

The sectionId specifies which nav menu section (e.g. "catalog", "customers") this item should appear in. It can also point to custom nav menu sections that have been defined using the navSections extension property.

Optional loader function to fetch data before the route renders. The value is a Tanstack Router loader function

Optional search parameter validation function. The value is a Tanstack Router validateSearch function

Define if the route should be under the authentication context, i.e have the authenticated route as a parent.

**Examples:**

Example 1 (ts):
```ts
interface DashboardRouteDefinition {    component: (route: AnyRoute) => React.ReactNode;    path: string;    navMenuItem?: Partial<NavMenuItem> & { sectionId: string };    loader?: RouteOptions['loader'];    validateSearch?: RouteOptions['validateSearch'];    authenticated?: boolean;}
```

---

## AssetStorageStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/assets/asset-storage-strategy/

**Contents:**
- AssetStorageStrategy
- AssetStorageStrategy‚Äã
  - writeFileFromBuffer‚Äã
  - writeFileFromStream‚Äã
  - readFileToBuffer‚Äã
  - readFileToStream‚Äã
  - deleteFile‚Äã
  - fileExists‚Äã
  - toAbsoluteUrl‚Äã

The AssetPersistenceStrategy determines how Asset files are physically stored and retrieved.

This is configured via the assetOptions.assetStorageStrategy property of your VendureConfig.

Writes a buffer to the store and returns a unique identifier for that file such as a file path or a URL.

Writes a readable stream to the store and returns a unique identifier for that file such as a file path or a URL.

Reads a file based on an identifier which was generated by the writeFile method, and returns the as a Buffer.

Reads a file based on an identifier which was generated by the writeFile method, and returns the file as a Stream.

Deletes a file from the storage.

Check whether a file with the given name already exists. Used to avoid naming conflicts before saving the file.

Convert an identifier as generated by the writeFile... methods into an absolute url (if it is not already in that form). If no conversion step is needed (i.e. the identifier is already an absolute url) then this method should not be implemented.

**Examples:**

Example 1 (ts):
```ts
interface AssetStorageStrategy extends InjectableStrategy {    writeFileFromBuffer(fileName: string, data: Buffer): Promise<string>;    writeFileFromStream(fileName: string, data: Stream): Promise<string>;    readFileToBuffer(identifier: string): Promise<Buffer>;    readFileToStream(identifier: string): Promise<Stream>;    deleteFile(identifier: string): Promise<void>;    fileExists(fileName: string): Promise<boolean>;    toAbsoluteUrl?(request: Request, identifier: string): string;}
```

---

## CompileUiExtensions

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/compile-ui-extensions

**Contents:**
- CompileUiExtensions
- compileUiExtensions‚Äã
  - options‚Äã

Compiles the Admin UI app with the specified extensions.

**Examples:**

Example 1 (ts):
```ts
function compileUiExtensions(options: UiExtensionCompilerOptions): AdminUiAppConfig | AdminUiAppDevModeConfig
```

---

## RegisterReactRouteComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/register-react-route-component

**Contents:**
- RegisterReactRouteComponent
- registerReactRouteComponent‚Äã
  - options‚Äã

Registers a React component to be used as a route component.

**Examples:**

Example 1 (ts):
```ts
function registerReactRouteComponent<Entity extends { id: string; updatedAt?: string }, T extends DocumentNode | TypedDocumentNode<any, { id: string }>, Field extends keyof ResultOf<T>, R extends Field>(options: RegisterReactRouteComponentOptions<Entity, T, Field, R>): Route
```

---

## UseMutation

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-hooks/use-mutation

**Contents:**
- UseMutation
- useMutation‚Äã
  - mutation‚Äã

A React hook which allows you to execute a GraphQL mutation.

**Examples:**

Example 1 (ts):
```ts
import { useMutation } from '@vendure/admin-ui/react';import { gql } from 'graphql-tag';const UPDATE_PRODUCT = gql`  mutation UpdateProduct($input: UpdateProductInput!) {    updateProduct(input: $input) {    id    name  }}`;export const MyComponent = () => {    const [updateProduct, { data, loading, error }] = useMutation(UPDATE_PRODUCT);    const handleClick = () => {        updateProduct({            input: {                id: '1',                name: 'New name',            },        }).then(result => {            // do something with the result        });    };    if (loading) return <div
...
```

Example 2 (ts):
```ts
function useMutation<T, V extends Record<string, any> = Record<string, any>>(mutation: DocumentNode | TypedDocumentNode<T, V>): void
```

---

## PaymentMethodService

**URL:** https://docs.vendure.io/reference/typescript-api/services/payment-method-service

**Contents:**
- PaymentMethodService
- PaymentMethodService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã
  - assignPaymentMethodsToChannel‚Äã
  - removePaymentMethodsFromChannel‚Äã

Contains methods relating to PaymentMethod entities.

**Examples:**

Example 1 (ts):
```ts
class PaymentMethodService {    constructor(connection: TransactionalConnection, configService: ConfigService, roleService: RoleService, listQueryBuilder: ListQueryBuilder, eventBus: EventBus, configArgService: ConfigArgService, channelService: ChannelService, customFieldRelationService: CustomFieldRelationService, translatableSaver: TranslatableSaver, translator: TranslatorService)    findAll(ctx: RequestContext, options?: ListQueryOptions<PaymentMethod>, relations: RelationPaths<PaymentMethod> = []) => Promise<PaginatedList<PaymentMethod>>;    findOne(ctx: RequestContext, paymentMethodId: ID
...
```

---

## Facet

**URL:** https://docs.vendure.io/reference/typescript-api/entities/facet

**Contents:**
- Facet
- Facet‚Äã
  - constructor‚Äã
  - name‚Äã
  - isPrivate‚Äã
  - code‚Äã
  - translations‚Äã
  - values‚Äã
  - customFields‚Äã
  - channels‚Äã

A Facet is a class of properties which can be applied to a Product or ProductVariant. They are used to enable faceted search whereby products can be filtered along a number of dimensions (facets).

For example, there could be a Facet named "Brand" which has a number of FacetValues representing the various brands of product, e.g. "Apple", "Samsung", "Dell", "HP" etc.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware

**Examples:**

Example 1 (ts):
```ts
class Facet extends VendureEntity implements Translatable, HasCustomFields, ChannelAware {    constructor(input?: DeepPartial<Facet>)    name: LocaleString;    @Column({ default: false })    isPrivate: boolean;    @Column({ unique: true })    code: string;    @OneToMany(type => FacetTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<Facet>>;    @OneToMany(type => FacetValue, value => value.facet)    values: FacetValue[];    @Column(type => CustomFacetFields)    customFields: CustomFacetFields;    @ManyToMany(type => Channel, channel => channel.fac
...
```

---

## ProductVariant

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product-variant/

**Contents:**
- ProductVariant
- ProductVariant‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - enabled‚Äã
  - sku‚Äã
  - listPrice‚Äã
  - listPriceIncludesTax‚Äã
  - currencyCode‚Äã

A ProductVariant represents a single stock keeping unit (SKU) in the store's inventory. Whereas a Product is a "container" of variants, the variant itself holds the data on price, tax category etc. When one adds items to their cart, they are adding ProductVariants, not Products.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, SoftDeletable, ChannelAware

Specifies the value of stockOnHand at which the ProductVariant is considered out of stock.

When true, the outOfStockThreshold value will be taken from the GlobalSettings and the value set on this ProductVariant will be ignored.

**Examples:**

Example 1 (ts):
```ts
class ProductVariant extends VendureEntity implements Translatable, HasCustomFields, SoftDeletable, ChannelAware {    constructor(input?: DeepPartial<ProductVariant>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    @Column({ default: true })    enabled: boolean;    @Column()    sku: string;    listPrice: number;    listPriceIncludesTax: boolean;    currencyCode: CurrencyCode;    price: number    priceWithTax: number    taxRateApplied: TaxRate;    @Index()    @ManyToOne(type => Asset, asset => asset.featuredInVariants, { onDelete: 'SET NULL' })   
...
```

---

## NativeAuthenticationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/native-authentication-strategy/

**Contents:**
- NativeAuthenticationStrategy
- NativeAuthenticationStrategy‚Äã
  - name‚Äã
  - init‚Äã
  - defineInputType‚Äã
  - authenticate‚Äã
  - verifyUserPassword‚Äã

This strategy implements a username/password credential-based authentication, with the credentials being stored in the Vendure database. This is the default method of authentication, and it is advised to keep it configured unless there is a specific reason not to.

**Examples:**

Example 1 (ts):
```ts
class NativeAuthenticationStrategy implements AuthenticationStrategy<NativeAuthenticationData> {    readonly name = NATIVE_AUTH_STRATEGY_NAME;    init(injector: Injector) => ;    defineInputType() => DocumentNode;    authenticate(ctx: RequestContext, data: NativeAuthenticationData) => Promise<User | false>;    verifyUserPassword(ctx: RequestContext, userId: ID, password: string) => Promise<boolean>;}
```

---

## HealthCheckRegistryService

**URL:** https://docs.vendure.io/reference/typescript-api/health-check/health-check-registry-service/

**Contents:**
- HealthCheckRegistryService
- HealthCheckRegistryService‚Äã
  - registerIndicatorFunction‚Äã

This service is used to register health indicator functions to be included in the health check. Health checks can be used by automated services such as Kubernetes to determine the state of applications it is running. They are also useful for administrators to get an overview of the health of all the parts of the Vendure stack.

It wraps the Nestjs Terminus module, so see those docs for information on creating custom health checks.

Plugins which rely on external services (web services, databases etc.) can make use of this service to add a check for that dependency to the Vendure health check.

Since v1.6.0, the preferred way to implement a custom health check is by creating a new HealthCheckStrategy and then passing it to the systemOptions.healthChecks array. See the HealthCheckStrategy docs for an example configuration.

The alternative way to register a health check is by injecting this service directly into your plugin module. To use it in your plugin, you'll need to import the PluginCommonModule:

Registers one or more HealthIndicatorFunctions (see Nestjs docs) to be added to the health check endpoint. The indicator will also appear in the Admin UI's "system status" view.

**Examples:**

Example 1 (ts):
```ts
import { HealthCheckRegistryService, PluginCommonModule, VendurePlugin } from '@vendure/core';import { TerminusModule } from '@nestjs/terminus';@VendurePlugin({  imports: [PluginCommonModule, TerminusModule],})export class MyPlugin {  constructor(    private registry: HealthCheckRegistryService    private httpIndicator: HttpHealthIndicator  ) {    registry.registerIndicatorFunction(      () => this.httpIndicator.pingCheck('vendure-docs', 'https://www.vendure.io/docs/'),    )  }}
```

Example 2 (ts):
```ts
class HealthCheckRegistryService {    registerIndicatorFunction(fn: HealthIndicatorFunction | HealthIndicatorFunction[]) => ;}
```

---

## PaymentMethodEligibilityChecker

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-method-eligibility-checker/

**Contents:**
- PaymentMethodEligibilityChecker
- PaymentMethodEligibilityChecker‚Äã
  - constructor‚Äã
- PaymentMethodEligibilityCheckerConfig‚Äã
  - check‚Äã
- CheckPaymentMethodEligibilityCheckerFn‚Äã

The PaymentMethodEligibilityChecker class is used to check whether an order qualifies for a given PaymentMethod.

Configuration passed into the constructor of a PaymentMethodEligibilityChecker to configure its behavior.

A function which implements logic to determine whether a given Order is eligible for a particular payment method. If the function resolves to false or a string, the check is considered to have failed. A string result can be used to provide information about the reason for ineligibility, if desired.

**Examples:**

Example 1 (ts):
```ts
const ccPaymentEligibilityChecker = new PaymentMethodEligibilityChecker({    code: 'order-total-payment-eligibility-checker',    description: [{ languageCode: LanguageCode.en, value: 'Checks that the order total is above some minimum value' }],    args: {        orderMinimum: { type: 'int', ui: { component: 'currency-form-input' } },    },    check: (ctx, order, args) => {        return order.totalWithTax >= args.orderMinimum;    },});
```

Example 2 (ts):
```ts
class PaymentMethodEligibilityChecker<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: PaymentMethodEligibilityCheckerConfig<T>)}
```

Example 3 (ts):
```ts
interface PaymentMethodEligibilityCheckerConfig<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {    check: CheckPaymentMethodEligibilityCheckerFn<T>;}
```

Example 4 (ts):
```ts
type CheckPaymentMethodEligibilityCheckerFn<T extends ConfigArgs> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    method: PaymentMethod,) => boolean | string | Promise<boolean | string>
```

---

## ShippingLineAssignmentStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-line-assignment-strategy

**Contents:**
- ShippingLineAssignmentStrategy
- ShippingLineAssignmentStrategy‚Äã
  - assignShippingLineToOrderLines‚Äã

This strategy is used to assign a given ShippingLine to one or more OrderLines of the Order. This allows you to set multiple shipping methods for a single order, each assigned a different subset of OrderLines.

The DefaultShippingLineAssignmentStrategy simply assigns all OrderLines, so is suitable for the most common scenario of a single shipping method per Order.

This is configured via the shippingOptions.shippingLineAssignmentStrategy property of your VendureConfig.

Here's an example of a custom ShippingLineAssignmentStrategy which assigns digital products to a different ShippingLine to physical products:

**Examples:**

Example 1 (ts):
```ts
import {    Order,    OrderLine,    RequestContext,    ShippingLine,    ShippingLineAssignmentStrategy,} from '@vendure/core';export class DigitalShippingLineAssignmentStrategy implements ShippingLineAssignmentStrategy {    assignShippingLineToOrderLines(        ctx: RequestContext,        shippingLine: ShippingLine,        order: Order,    ): OrderLine[] | Promise<OrderLine[]> {        if (shippingLine.shippingMethod.customFields.isDigital) {            return order.lines.filter(l => l.productVariant.customFields.isDigital);        } else {            return order.lines.filter(l => !l.product
...
```

Example 2 (ts):
```ts
interface ShippingLineAssignmentStrategy extends InjectableStrategy {    assignShippingLineToOrderLines(        ctx: RequestContext,        shippingLine: ShippingLine,        order: Order,    ): OrderLine[] | Promise<OrderLine[]>;}
```

---

## Entities

**URL:** https://docs.vendure.io/reference/typescript-api/entities/

**Contents:**
- Entities
- üìÑÔ∏è Address
- üìÑÔ∏è Administrator
- üìÑÔ∏è AnonymousSession
- üìÑÔ∏è Asset
- üìÑÔ∏è AuthenticatedSession
- üìÑÔ∏è AuthenticationMethod
- üìÑÔ∏è Channel
- üìÑÔ∏è Collection
- üìÑÔ∏è Country

---

## LocaleCurrencyPipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/locale-currency-pipe

**Contents:**
- LocaleCurrencyPipe
- LocaleCurrencyPipe‚Äã
  - precisionFactor‚Äã
  - constructor‚Äã
  - transform‚Äã

Formats a Vendure monetary value (in cents) into the correct format for the configured currency and display locale.

Extends: LocaleBasePipe

Implements: PipeTransform

**Examples:**

Example 1 (html):
```html
{{ variant.priceWithTax | localeCurrency }}
```

Example 2 (ts):
```ts
class LocaleCurrencyPipe extends LocaleBasePipe implements PipeTransform {    readonly precisionFactor: number;    constructor(currencyService: CurrencyService, dataService?: DataService, changeDetectorRef?: ChangeDetectorRef)    transform(value: unknown, args: unknown[]) => string | unknown;}
```

---

## CustomColumnComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-table-components/custom-column-component

**Contents:**
- CustomColumnComponent
- CustomColumnComponent‚Äã
  - rowItem‚Äã

Components which are to be used to render custom cells in a data table should implement this interface.

The rowItem property is the data object for the row, e.g. the Product object if used in the product-list table.

**Examples:**

Example 1 (ts):
```ts
interface CustomColumnComponent {    rowItem: any;}
```

---

## EventBus

**URL:** https://docs.vendure.io/reference/typescript-api/events/event-bus/

**Contents:**
- EventBus
- EventBus‚Äã
  - constructor‚Äã
  - publish‚Äã
  - ofType‚Äã
  - filter‚Äã
  - registerBlockingEventHandler‚Äã

The EventBus is used to globally publish events which can then be subscribed to.

Events are published whenever certain actions take place within the Vendure server, for example:

Using the EventBus it is possible to subscribe to an take action when these events occur. This is done with the .ofType() method, which takes an event type and returns an rxjs observable stream of events:

Publish an event which any subscribers can react to.

Returns an RxJS Observable stream of events of the given type. If the event contains a RequestContext object, the subscriber will only get called after any active database transactions are complete.

This means that the subscriber function can safely access all updated data related to the event.

Returns an RxJS Observable stream of events filtered by a custom predicate. If the event contains a RequestContext object, the subscriber will only get called after any active database transactions are complete.

This means that the subscriber function can safely access all updated data related to the event.

Register an event handler function which will be executed when an event of the given type is published, and will block execution of the code which published the event until the handler has completed.

This is useful when you need assurance that the event handler has successfully completed, and you want the triggering code to fail if the handler fails.

::: warning This API should be used with caution, as errors or performance issues in the handler can cause the associated operation to be slow or fail entirely. For this reason, any handler which takes longer than 100ms to execute will log a warning. Any non-trivial task to be performed in a blocking event handler should be offloaded to a background job using the JobQueueService.

Also, be aware that the handler will be executed in the same database transaction as the code which published the event (as long as you pass the ctx object from the event to any TransactionalConnection calls). :::

**Examples:**

Example 1 (ts):
```ts
import { OnApplicationBootstrap } from '@nestjs/common';import { EventBus, PluginCommonModule, VendurePlugin } from '@vendure/core';import { filter } from 'rxjs/operators';@VendurePlugin({    imports: [PluginCommonModule]})export class MyPlugin implements OnApplicationBootstrap {  constructor(private eventBus: EventBus) {}  async onApplicationBootstrap() {    this.eventBus      .ofType(OrderStateTransitionEvent)      .pipe(        filter(event => event.toState === 'PaymentSettled'),      )      .subscribe((event) => {        // do some action when this event fires      });  }}
```

Example 2 (ts):
```ts
class EventBus implements OnModuleDestroy {    constructor(transactionSubscriber: TransactionSubscriber)    publish(event: T) => Promise<void>;    ofType(type: Type<T>) => Observable<T>;    filter(predicate: (event: VendureEvent) => boolean) => Observable<T>;    registerBlockingEventHandler(handlerOptions: BlockingEventHandlerOptions<T>) => ;}
```

Example 3 (ts):
```ts
await eventBus.publish(new SomeEvent());
```

Example 4 (ts):
```ts
eventBus.registerBlockingEventHandler({  event: OrderStateTransitionEvent,  id: 'my-order-state-transition-handler',  handler: async (event) => {    // perform some synchronous task  }});
```

---

## SelfRefreshingCache

**URL:** https://docs.vendure.io/reference/typescript-api/cache/self-refreshing-cache

**Contents:**
- SelfRefreshingCache
- SelfRefreshingCache‚Äã
  - value‚Äã
  - memoize‚Äã
  - refresh‚Äã
- SelfRefreshingCacheConfig‚Äã
  - name‚Äã
  - ttl‚Äã
  - refresh‚Äã
  - getTimeFn‚Äã

A cache which automatically refreshes itself if the value is found to be stale.

The current value of the cache. If the value is stale, the data will be refreshed and then the fresh value will be returned.

Allows a memoized function to be defined. For the given arguments, the fn function will be invoked only once and its output cached and returned. The results cache is cleared along with the rest of the cache according to the configured ttl value.

Force a refresh of the value, e.g. when it is known that the value has changed such as after an update operation to the source data in the database.

Configuration options for creating a SelfRefreshingCache.

The name of the cache, used for logging purposes. e.g. 'MyService.cachedValue'.

The time-to-live (ttl) in milliseconds for the cache. After this time, the value will be considered stale and will be refreshed the next time it is accessed.

The function which is used to refresh the value of the cache. This function should return a Promise which resolves to the new value.

Intended for unit testing the SelfRefreshingCache only. By default uses () => new Date().getTime()

Creates a SelfRefreshingCache object, which is used to cache a single frequently-accessed value. In this type of cache, the function used to populate the value (refreshFn) is defined during the creation of the cache, and it is immediately used to populate the initial value.

From there, when the .value property is accessed, it will return a value from the cache, and if the value has expired, it will automatically run the refreshFn to update the value and then return the fresh value.

**Examples:**

Example 1 (ts):
```ts
interface SelfRefreshingCache<V, RefreshArgs extends any[] = []> {    value(...refreshArgs: RefreshArgs | [undefined] | []): Promise<V>;    memoize<Args extends any[], R>(        args: Args,        refreshArgs: RefreshArgs,        fn: (value: V, ...args: Args) => R,    ): Promise<R>;    refresh(...args: RefreshArgs): Promise<V>;}
```

Example 2 (ts):
```ts
interface SelfRefreshingCacheConfig<V, RefreshArgs extends any[]> {    name: string;    ttl: number;    refresh: {        fn: (...args: RefreshArgs) => Promise<V>;        /**         * Default arguments, passed to refresh function         */        defaultArgs: RefreshArgs;    };    getTimeFn?: () => number;}
```

Example 3 (ts):
```ts
import { createSelfRefreshingCache } from '@vendure/core';@Injectable()export class PublicChannelService {  private publicChannel: SelfRefreshingCache<Channel, [RequestContext]>;  async init() {    this.publicChannel = await createSelfRefreshingCache<Channel, [RequestContext]>({     name: 'PublicChannelService.publicChannel',     ttl: 1000 * 60 * 60, // 1 hour     refresh: {       fn: async (ctx: RequestContext) => {        return this.channelService.getPublicChannel(ctx);      },     defaultArgs: [RequestContext.empty()],    },  });}
```

Example 4 (ts):
```ts
function createSelfRefreshingCache<V, RefreshArgs extends any[]>(config: SelfRefreshingCacheConfig<V, RefreshArgs>, refreshArgs?: RefreshArgs): Promise<SelfRefreshingCache<V, RefreshArgs>>
```

---

## BraintreePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/payments-plugin/braintree-plugin

**Contents:**
- BraintreePlugin
- BraintreePlugin‚Äã
- Requirements‚Äã
- Setup‚Äã
- Storefront usage‚Äã
- Storing payment details (vaulting)‚Äã
  - options‚Äã
  - init‚Äã
- BraintreePluginOptions‚Äã
  - environment‚Äã

This plugin enables payments to be processed by Braintree, a popular payment provider.

The plugin is designed to work with the Braintree drop-in UI. This is a library provided by Braintree which will handle the payment UI for you. You can install it in your storefront project with:

The high-level workflow is:

Here is an example of how your storefront code will look. Note that this example is attempting to be framework-agnostic, so you'll need to adapt it to fit to your framework of choice.

Braintree has a vault feature which allows the secure storage of customer's payment information. Using the vault allows you to offer a faster checkout for repeat customers without needing to worry about how to securely store payment details.

To enable this feature, set the storeCustomersInBraintree option to true.

Since v1.8, it is possible to override vaulting on a per-payment basis by passing includeCustomerId: false to the generateBraintreeClientToken mutation:

as well as in the metadata of the addPaymentToOrder mutation:

Options for the Braintree plugin.

The Braintree environment being targeted, e.g. sandbox or production.

If set to true, a Customer object will be created in Braintree, which allows the secure storage ("vaulting") of previously-used payment methods. This is done by adding a custom field to the Customer entity to store the Braintree customer ID, so switching this on will require a database migration / synchronization.

Since v1.8, it is possible to override vaulting on a per-payment basis by passing includeCustomerId: false to the generateBraintreeClientToken mutation.

Allows you to configure exactly what information from the Braintree Transaction object (which is returned by the transaction.sale() method of the SDK) should be persisted to the resulting Payment entity metadata.

By default, the built-in extraction function will return a metadata object that looks like this:

**Examples:**

Example 1 (shell):
```shell
yarn add @vendure/payments-plugin braintreeyarn add -D @types/braintree
```

Example 2 (shell):
```shell
npm install @vendure/payments-plugin braintreenpm install -D @types/braintree
```

Example 3 (ts):
```ts
import { BraintreePlugin } from '@vendure/payments-plugin/package/braintree';import { Environment } from 'braintree';// ...plugins: [  BraintreePlugin.init({    environment: Environment.Sandbox,    // This allows saving customer payment    // methods with Braintree (see "vaulting"    // section below for details)    storeCustomersInBraintree: true,  }),]
```

Example 4 (shell):
```shell
yarn add braintree-web-drop-in# ornpm install braintree-web-drop-in
```

---

## PaymentMethodEligibilityChecker

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-method-eligibility-checker

**Contents:**
- PaymentMethodEligibilityChecker
- PaymentMethodEligibilityChecker‚Äã
  - constructor‚Äã
- PaymentMethodEligibilityCheckerConfig‚Äã
  - check‚Äã
- CheckPaymentMethodEligibilityCheckerFn‚Äã

The PaymentMethodEligibilityChecker class is used to check whether an order qualifies for a given PaymentMethod.

Configuration passed into the constructor of a PaymentMethodEligibilityChecker to configure its behavior.

A function which implements logic to determine whether a given Order is eligible for a particular payment method. If the function resolves to false or a string, the check is considered to have failed. A string result can be used to provide information about the reason for ineligibility, if desired.

**Examples:**

Example 1 (ts):
```ts
const ccPaymentEligibilityChecker = new PaymentMethodEligibilityChecker({    code: 'order-total-payment-eligibility-checker',    description: [{ languageCode: LanguageCode.en, value: 'Checks that the order total is above some minimum value' }],    args: {        orderMinimum: { type: 'int', ui: { component: 'currency-form-input' } },    },    check: (ctx, order, args) => {        return order.totalWithTax >= args.orderMinimum;    },});
```

Example 2 (ts):
```ts
class PaymentMethodEligibilityChecker<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: PaymentMethodEligibilityCheckerConfig<T>)}
```

Example 3 (ts):
```ts
interface PaymentMethodEligibilityCheckerConfig<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {    check: CheckPaymentMethodEligibilityCheckerFn<T>;}
```

Example 4 (ts):
```ts
type CheckPaymentMethodEligibilityCheckerFn<T extends ConfigArgs> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    method: PaymentMethod,) => boolean | string | Promise<boolean | string>
```

---

## DefaultSchedulerStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/scheduled-tasks/default-scheduler-strategy

**Contents:**
- DefaultSchedulerStrategy
- DefaultSchedulerStrategy‚Äã
  - init‚Äã
  - destroy‚Äã
  - registerTask‚Äã
  - executeTask‚Äã
  - getTasks‚Äã
  - getTask‚Äã
  - updateTask‚Äã
  - triggerTask‚Äã

The default SchedulerStrategy implementation that uses the database to execute scheduled tasks. This strategy is configured when you use the DefaultSchedulerPlugin.

**Examples:**

Example 1 (ts):
```ts
class DefaultSchedulerStrategy implements SchedulerStrategy {    init(injector: Injector) => ;    destroy() => ;    registerTask(task: ScheduledTask) => void;    executeTask(task: ScheduledTask) => ;    getTasks() => Promise<TaskReport[]>;    getTask(id: string) => Promise<TaskReport | undefined>;    updateTask(input: UpdateScheduledTaskInput) => Promise<TaskReport>;    triggerTask(task: ScheduledTask) => Promise<void>;}
```

---

## DataTable2Component

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/data-table2component

**Contents:**
- DataTable2Component
- DataTable2Component‚Äã
  - id‚Äã
  - items‚Äã
  - itemsPerPage‚Äã
  - currentPage‚Äã
  - totalItems‚Äã
  - emptyStateLabel‚Äã
  - filters‚Äã
  - activeIndex‚Äã

A table for displaying PaginatedList results. It is designed to be used inside components which extend the BaseListComponent or TypedBaseListComponent class.

**Examples:**

Example 1 (html):
```html
<vdr-data-table-2    id="product-review-list"    [items]="items$ | async"    [itemsPerPage]="itemsPerPage$ | async"    [totalItems]="totalItems$ | async"    [currentPage]="currentPage$ | async"    [filters]="filters"    (pageChange)="setPageNumber($event)"    (itemsPerPageChange)="setItemsPerPage($event)">    <vdr-bulk-action-menu        locationId="product-review-list"        [hostComponent]="this"        [selectionManager]="selectionManager"    />    <vdr-dt2-search        [searchTermControl]="searchTermControl"        searchTermPlaceholder="Filter by title"    />    <vdr-dt2-column [heading
...
```

Example 2 (ts):
```ts
class DataTable2Component<T> implements AfterContentInit, OnChanges, OnDestroy {    @Input() id: DataTableLocationId;    @Input() items: T[];    @Input() itemsPerPage: number;    @Input() currentPage: number;    @Input() totalItems: number;    @Input() emptyStateLabel: string;    @Input() filters: DataTableFilterCollection;    @Input() activeIndex = -1;    @Input() trackByPath = 'id';    @Output() pageChange = new EventEmitter<number>();    @Output() itemsPerPageChange = new EventEmitter<number>();    @Output() visibleColumnsChange = new EventEmitter<Array<DataTable2ColumnComponent<T>>>();    
...
```

---

## DummyPaymentHandler

**URL:** https://docs.vendure.io/reference/typescript-api/payment/dummy-payment-handler

**Contents:**
- DummyPaymentHandler
- dummyPaymentHandler‚Äã

A dummy PaymentMethodHandler which simply creates a Payment without any integration with an external payment provider. Intended only for use in development.

By specifying certain metadata keys, failures can be simulated:

**Examples:**

Example 1 (graphql):
```graphql
addPaymentToOrder(input: {  method: 'dummy-payment-method',  metadata: {    shouldDecline: false,    shouldError: false,    shouldErrorOnSettle: true,  }}) {  # ...}
```

---

## ProductVariantPriceUpdateStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/product-variant-price-update-strategy

**Contents:**
- ProductVariantPriceUpdateStrategy
- ProductVariantPriceUpdateStrategy‚Äã
  - onPriceCreated‚Äã
  - onPriceUpdated‚Äã
  - onPriceDeleted‚Äã
- DefaultProductVariantPriceUpdateStrategyOptions‚Äã
  - syncPricesAcrossChannels‚Äã
- DefaultProductVariantPriceUpdateStrategy‚Äã
  - constructor‚Äã
  - onPriceCreated‚Äã

This strategy determines how updates to a ProductVariantPrice is handled in regard to any other prices which may be associated with the same ProductVariant.

For instance, in a multichannel setup, if a price is updated for a ProductVariant in one Channel, this strategy can be used to update the prices in other Channels.

Using custom logic, this can be made more sophisticated - for example, you could have a one-way sync that only updates prices in child channels when the price in the default channel is updated. You could also have a conditional sync which is dependent on the permissions of the current administrator, or based on custom field flags on the ProductVariant or Channel.

Another use-case might be to update the prices of a ProductVariant in other currencies when a price is updated in one currency, based on the current exchange rate.

This is configured via the catalogOptions.productVariantPriceUpdateStrategy property of your VendureConfig.

This method is called when a ProductVariantPrice is created. It receives the created ProductVariantPrice and the array of all prices associated with the ProductVariant.

It should return an array of UpdatedProductVariantPrice objects which will be used to update the prices of the specific ProductVariantPrices.

This method is called when a ProductVariantPrice is updated. It receives the updated ProductVariantPrice and the array of all prices associated with the ProductVariant.

It should return an array of UpdatedProductVariantPrice objects which will be used to update the prices of the specific ProductVariantPrices.

This method is called when a ProductVariantPrice is deleted. It receives the deleted ProductVariantPrice and the array of all prices associated with the ProductVariant.

It should return an array of UpdatedProductVariantPrice objects which will be used to update the prices of the specific ProductVariantPrices.

The options available to the DefaultProductVariantPriceUpdateStrategy.

When true, any price changes to a ProductVariant in one Channel will update any other prices of the same currencyCode in other Channels. Note that if there are different tax settings across the channels, these will not be taken into account. To handle this case, a custom strategy should be implemented.

The default ProductVariantPriceUpdateStrategy which by default will not update any other prices when a price is created, updated or deleted.

If the syncPricesAcrossChannels option is set to true, then when a price is up

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
interface ProductVariantPriceUpdateStrategy extends InjectableStrategy {    onPriceCreated(        ctx: RequestContext,        createdPrice: ProductVariantPrice,        prices: ProductVariantPrice[],    ): UpdatedProductVariantPrice[] | Promise<UpdatedProductVariantPrice[]>;    onPriceUpdated(        ctx: RequestContext,        updatedPrice: ProductVariantPrice,        prices: ProductVariantPrice[],    ): UpdatedProductVariantPrice[] | Promise<UpdatedProductVariantPrice[]>;    onPriceDeleted(        ctx: RequestContext,        deletedPrice: ProductVariantPrice,        prices: ProductVariantPri
...
```

Example 2 (ts):
```ts
interface DefaultProductVariantPriceUpdateStrategyOptions {    syncPricesAcrossChannels: boolean;}
```

Example 3 (ts):
```ts
import { DefaultProductVariantPriceUpdateStrategy, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  // ...  catalogOptions: {    productVariantPriceUpdateStrategy: new DefaultProductVariantPriceUpdateStrategy({      syncPricesAcrossChannels: true,    }),  },  // ...};
```

Example 4 (ts):
```ts
class DefaultProductVariantPriceUpdateStrategy implements ProductVariantPriceUpdateStrategy {    constructor(options: DefaultProductVariantPriceUpdateStrategyOptions)    onPriceCreated(ctx: RequestContext, price: ProductVariantPrice) => ;    onPriceUpdated(ctx: RequestContext, updatedPrice: ProductVariantPrice, prices: ProductVariantPrice[]) => ;    onPriceDeleted(ctx: RequestContext, deletedPrice: ProductVariantPrice, prices: ProductVariantPrice[]) => ;}
```

---

## Logger

**URL:** https://docs.vendure.io/reference/typescript-api/logger/

**Contents:**
- Logger
- Logger‚Äã
- Implementing a custom logger‚Äã
  - logger‚Äã
  - error‚Äã
  - warn‚Äã
  - info‚Äã
  - verbose‚Äã
  - debug‚Äã

The Logger is responsible for all logging in a Vendure application.

It is intended to be used as a static class:

The actual implementation - where the logs are written to - is defined by the VendureLogger instance configured in the VendureConfig. By default, the DefaultLogger is used, which logs to the console.

A custom logger can be passed to the logger config option by creating a class which implements the VendureLogger interface. For example, here is how you might go about implementing a logger which logs to a file:

**Examples:**

Example 1 (ts):
```ts
import { Logger } from '@vendure/core';Logger.info(`Some log message`, 'My Vendure Plugin');
```

Example 2 (ts):
```ts
import { VendureLogger } from '@vendure/core';import fs from 'fs';// A simple custom logger which writes all logs to a file.export class SimpleFileLogger implements VendureLogger {    private logfile: fs.WriteStream;    constructor(logfileLocation: string) {        this.logfile = fs.createWriteStream(logfileLocation, { flags: 'w' });    }    error(message: string, context?: string) {        this.logfile.write(`ERROR: [${context}] ${message}\n`);    }    warn(message: string, context?: string) {        this.logfile.write(`WARN: [${context}] ${message}\n`);    }    info(message: string, context?
...
```

Example 3 (ts):
```ts
class Logger implements LoggerService {    logger: VendureLogger    error(message: string, context?: string, trace?: string) => void;    warn(message: string, context?: string) => void;    info(message: string, context?: string) => void;    verbose(message: string, context?: string) => void;    debug(message: string, context?: string) => void;}
```

---

## GlobalSettings

**URL:** https://docs.vendure.io/reference/typescript-api/entities/global-settings

**Contents:**
- GlobalSettings
- GlobalSettings‚Äã
  - constructor‚Äã
  - availableLanguages‚Äã
  - trackInventory‚Äã
  - outOfStockThreshold‚Äã
  - customFields‚Äã

Stores global settings for the whole application

Extends: VendureEntity

Implements: HasCustomFields

Specifies the default value for inventory tracking for ProductVariants. Can be overridden per ProductVariant, but this value determines the default if not otherwise specified.

Specifies the value of stockOnHand at which a given ProductVariant is considered out of stock.

**Examples:**

Example 1 (ts):
```ts
class GlobalSettings extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<GlobalSettings>)    @Column('simple-array')    availableLanguages: LanguageCode[];    @Column({ default: true })    trackInventory: boolean;    @Column({ default: 0 })    outOfStockThreshold: number;    @Column(type => CustomGlobalSettingsFields)    customFields: CustomGlobalSettingsFields;}
```

---

## AssetServerOptions

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/asset-server-options

**Contents:**
- AssetServerOptions
- AssetServerOptions‚Äã
  - route‚Äã
  - assetUploadDir‚Äã
  - assetUrlPrefix‚Äã
  - previewMaxWidth‚Äã
  - previewMaxHeight‚Äã
  - presets‚Äã
  - imageTransformStrategy‚Äã
  - namingStrategy‚Äã

The configuration options for the AssetServerPlugin.

The route to the asset server.

The local directory to which assets will be uploaded when using the LocalAssetStorageStrategy.

The complete URL prefix of the asset files. For example, "https://demo.vendure.io/assets/". A function can also be provided to handle more complex cases, such as serving multiple domains from a single server. In this case, the function should return a string url prefix.

If not provided, the plugin will attempt to guess based off the incoming request and the configured route. However, in all but the simplest cases, this guess may not yield correct results.

The max width in pixels of a generated preview image.

The max height in pixels of a generated preview image.

An array of additional ImageTransformPreset objects.

The strategy or strategies to use to determine the parameters for transforming an image. This can be used to implement custom image transformation logic, for example to limit transform parameters to a known set of presets.

If multiple strategies are provided, they will be executed in the order in which they are defined. If a strategy throws an error, the image transformation will be aborted and the error will be logged, with an HTTP 400 response sent to the client.

Defines how asset files and preview images are named before being saved.

Defines how previews are generated for a given Asset binary. By default, this uses the SharpAssetPreviewStrategy

A function which can be used to configure an AssetStorageStrategy. This is useful e.g. if you wish to store your assets using a cloud storage provider. By default, the LocalAssetStorageStrategy is used.

Configures the Cache-Control directive for response to control caching in browsers and shared caches (e.g. Proxies, CDNs). Defaults to publicly cached for 6 months.

**Examples:**

Example 1 (ts):
```ts
interface AssetServerOptions {    route: string;    assetUploadDir: string;    assetUrlPrefix?: string | ((ctx: RequestContext, identifier: string) => string);    previewMaxWidth?: number;    previewMaxHeight?: number;    presets?: ImageTransformPreset[];    imageTransformStrategy?: ImageTransformStrategy | ImageTransformStrategy[];    namingStrategy?: AssetNamingStrategy;    previewStrategy?: AssetPreviewStrategy;    storageStrategyFactory?: (        options: AssetServerOptions,    ) => AssetStorageStrategy | Promise<AssetStorageStrategy>;    cacheHeader?: CacheConfig | string;}
```

---

## ListQueryBuilder

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/list-query-builder/

**Contents:**
- ListQueryBuilder
- ListQueryBuilder‚Äã
  - constructor‚Äã
  - filterObjectHasProperty‚Äã
  - build‚Äã
- ExtendedListQueryOptions‚Äã
  - relations‚Äã
  - channelId‚Äã
  - where‚Äã
  - orderBy‚Äã

This helper class is used when fetching entities the database from queries which return a PaginatedList type. These queries all follow the same format:

In the GraphQL definition, they return a type which implements the Node interface, and the query returns a type which implements the PaginatedList interface:

When Vendure bootstraps, it will find the BlogPostListOptions input and, because it is used in a query returning a PaginatedList type, it knows that it should dynamically generate this input. This means all primitive field of the BlogPost type (namely, "published", "title" and "body") will have filter and sort inputs created for them, as well a skip and take fields for pagination.

Your resolver function will then look like this:

and the corresponding service will use the ListQueryBuilder:

Used to determine whether a list query filter object contains the given property, either at the top level or nested inside a boolean _and or _or expression.

This is useful when a custom property map is used to map a filter field to a related entity, and we need to determine whether the filter object contains that property, which then means we would need to join that relation.

Options which can be passed to the ListQueryBuilder's build() method.

Allows you to specify the alias used for the entity T in the generated SQL query. Defaults to the entity class name lower-cased, i.e. ProductVariant -> 'productvariant'.

When a RequestContext is passed, then the query will be executed as part of any outer transaction.

One of the main tasks of the ListQueryBuilder is to auto-generate filter and sort queries based on the available columns of a given entity. However, it may also be sometimes desirable to allow filter/sort on a property of a relation. In this case, the customPropertyMap can be used to define a property of the options.sort or options.filter which does not correspond to a direct column of the current entity, and then provide a mapping to the related property to be sorted/filtered.

Example: we want to allow sort/filter by and Order's customerLastName. The actual lastName property is not a column in the Order table, it exists on the Customer entity, and Order has a relation to Customer via Order.customer. Therefore, we can define a customPropertyMap like this:

We can now use the customerLastName property to filter or sort on the list query:

When set to true, the configured shopListQueryLimit and adminListQueryLimit values will be ignored, allowing unlimite

*[Content truncated]*

**Examples:**

Example 1 (graphql):
```graphql
type BlogPost implements Node {  id: ID!  published: DateTime!  title: String!  body: String!}type BlogPostList implements PaginatedList {  items: [BlogPost!]!  totalItems: Int!}# Generated at run-time by Vendureinput BlogPostListOptionsextend type Query {   blogPosts(options: BlogPostListOptions): BlogPostList!}
```

Example 2 (ts):
```ts
@Resolver()export class BlogPostResolver  constructor(private blogPostService: BlogPostService) {}  @Query()  async blogPosts(    @Ctx() ctx: RequestContext,    @Args() args: any,  ): Promise<PaginatedList<BlogPost>> {    return this.blogPostService.findAll(ctx, args.options || undefined);  }}
```

Example 3 (ts):
```ts
@Injectable()export class BlogPostService {  constructor(private listQueryBuilder: ListQueryBuilder) {}  findAll(ctx: RequestContext, options?: ListQueryOptions<BlogPost>) {    return this.listQueryBuilder      .build(BlogPost, options)      .getManyAndCount()      .then(async ([items, totalItems]) => {        return { items, totalItems };      });  }}
```

Example 4 (ts):
```ts
class ListQueryBuilder implements OnApplicationBootstrap {    constructor(connection: TransactionalConnection, configService: ConfigService)    filterObjectHasProperty(filterObject: FP | NullOptionals<FP> | null | undefined, property: keyof FP) => boolean;    build(entity: Type<T>, options: ListQueryOptions<T> = {}, extendedOptions: ExtendedListQueryOptions<T> = {}) => SelectQueryBuilder<T>;}
```

---

## Relations Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/relations-decorator

**Contents:**
- Relations Decorator
- Relations‚Äã
- Depth‚Äã
- Omit‚Äã

Resolver param decorator which returns an array of relation paths which can be passed through to the TypeORM data layer in order to join only the required relations. This works by inspecting the GraphQL info object, examining the field selection, and then comparing this with information about the return type's relations.

In addition to analyzing the field selection, this decorator also checks for any @Calculated() properties on the entity, and additionally includes relations from the relations array of the calculated metadata, if defined.

So if, for example, the query only selects the id field of an Order, then no other relations need be joined in the resulting SQL query. This can massively speed up execution time for queries which do not include many deep nested relations.

In the above example, given the following query:

then the value of relations will be

The 'customer' comes from the fact that the query is nesting the "customer" object, and the 'lines' is taken from the Order entity's totalQuantity property, which uses Calculated decorator and defines those relations as dependencies for deriving the calculated value.

By default, when inspecting the GraphQL query, the Relations decorator will look 3 levels deep in any nested fields. So, e.g. if the above orders query were changed to:

then the relations array would include 'lines', 'lines.productVariant', & 'lines.productVariant.product' - 3 levels deep - but it would not include 'lines.productVariant.product.featuredAsset' since that exceeds the default depth. To specify a custom depth, you would use the decorator like this:

The omit option is used to explicitly omit certain relations from the calculated relations array. This is useful in certain cases where we know for sure that we need to run the field resolver anyway. A good example is the Collection.productVariants relation. When a GraphQL query comes in for a Collection and also requests its productVariants field, there is no point using a lookahead to eagerly join that relation, because we will throw that data away anyway when the productVariants field resolver executes, since it returns a PaginatedList query rather than a simple array.

**Examples:**

Example 1 (ts):
```ts
@Query()@Allow(Permission.ReadOrder)orders(    @Ctx() ctx: RequestContext,    @Args() args: QueryOrdersArgs,    @Relations(Order) relations: RelationPaths<Order>,): Promise<PaginatedList<Order>> {    return this.orderService.findAll(ctx, args.options || undefined, relations);}
```

Example 2 (graphql):
```graphql
{  orders(options: { take: 10 }) {    items {      id      customer {        id        firstName        lastName      }      totalQuantity      totalWithTax    }  }}
```

Example 3 (text):
```text
['customer', 'lines'']
```

Example 4 (graphql):
```graphql
{  orders(options: { take: 10 }) {    items {      id      lines {        productVariant {          product {            featuredAsset {              preview            }          }        }      }    }  }}
```

---

## FSM

**URL:** https://docs.vendure.io/reference/typescript-api/state-machine/fsm/

**Contents:**
- FSM
- FSM‚Äã
  - constructor‚Äã
  - initialState‚Äã
  - currentState‚Äã
  - transitionTo‚Äã
  - jumpTo‚Äã
  - getNextStates‚Äã
  - canTransitionTo‚Äã

A simple type-safe finite state machine. This is used internally to control the Order process, ensuring that the state of Orders, Payments, Fulfillments and Refunds follows a well-defined behaviour.

**Examples:**

Example 1 (ts):
```ts
class FSM<T extends string, Data = any> {    constructor(config: StateMachineConfig<T, Data>, initialState: T)    initialState: T    currentState: T    transitionTo(state: T, data: Data) => Promise<{ finalize: () => Promise<any> }>;    jumpTo(state: T) => ;    getNextStates() => readonly T[];    canTransitionTo(state: T) => boolean;}
```

---

## InstrumentationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/telemetry/instrumentation-strategy

**Contents:**
- InstrumentationStrategy
- InstrumentationStrategy‚Äã
  - wrapMethod‚Äã

This interface is used to define a strategy for instrumenting methods of classes which are decorated with the Instrument decorator.

When a method of an instrumented class is called, it will be wrapped (by means of a Proxy) and this method will be called. The applyOriginalFunction function will apply the original method and return the result.

**Examples:**

Example 1 (ts):
```ts
interface InstrumentationStrategy extends InjectableStrategy {    wrapMethod(args: WrappedMethodArgs): any;}
```

---

## Alerts

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/alerts

**Contents:**
- Alerts
- DashboardAlertDefinition‚Äã
  - id‚Äã
  - title‚Äã
  - description‚Äã
  - severity‚Äã
  - check‚Äã
  - shouldShow‚Äã
  - recheckInterval‚Äã
  - actions‚Äã

Allows you to define custom alerts that can be displayed in the dashboard.

A unique identifier for the alert.

The title of the alert. Can be a string or a function that returns a string based on the response data.

The description of the alert. Can be a string or a function that returns a string based on the response data.

The severity level of the alert.

A function that checks the condition and returns the response data.

A function that determines whether the alert should be rendered based on the response data.

The interval in milliseconds to recheck the condition.

Optional actions that can be performed when the alert is shown.

The onClick() handler will receive the data returned by the check function, as well as a dismiss() function that can be used to immediately dismiss the current alert.

**Examples:**

Example 1 (ts):
```ts
interface DashboardAlertDefinition<TResponse = any> {    id: string;    title: string | ((data: TResponse) => string);    description?: string | ((data: TResponse) => string);    severity: AlertSeverity | ((data: TResponse) => AlertSeverity);    check: () => Promise<TResponse> | TResponse;    shouldShow: (data: TResponse) => boolean;    recheckInterval?: number;    actions?: Array<{        label: string;        onClick: (args: { data: TResponse; dismiss: () => void }) => void | Promise<any>;    }>;}
```

---

## Importer

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/importer/

**Contents:**
- Importer
- Importer‚Äã
  - parseAndImport‚Äã
  - importProducts‚Äã
  - getFacetValueIds‚Äã
  - processCustomFieldValues‚Äã

Parses and imports Products using the CSV import format.

Internally it is using the ImportParser to parse the CSV file, and then the FastImporterService and the AssetImporter to actually create the resulting entities in the Vendure database.

Parses the contents of the product import CSV file and imports the resulting Product & ProductVariants, as well as any associated Assets, Facets & FacetValues.

The ctxOrLanguageCode argument is used to specify the languageCode to be used when creating the Products.

Imports the products specified in the rows object. Return an array of error messages.

**Examples:**

Example 1 (ts):
```ts
class Importer {    parseAndImport(input: string | Stream, ctxOrLanguageCode: RequestContext | LanguageCode, reportProgress: boolean = false) => Observable<ImportProgress>;    importProducts(ctx: RequestContext, rows: ParsedProductWithVariants[], onProgress: OnProgressFn) => Promise<string[]>;    getFacetValueIds(ctx: RequestContext, facets: ParsedFacet[], languageCode: LanguageCode) => Promise<ID[]>;    processCustomFieldValues(customFields: { [field: string]: string }, config: CustomFieldConfig[]) => ;}
```

---

## Data Access

**URL:** https://docs.vendure.io/reference/typescript-api/data-access/

**Contents:**
- Data Access
- üìÑÔ∏è CalculatedPropertySubscriber
- üìÑÔ∏è Calculated
- üìÑÔ∏è EntityHydrator
- üìÑÔ∏è GetEntityOrThrowOptions
- üìÑÔ∏è HydrateOptions
- üìÑÔ∏è ListQueryBuilder
- üìÑÔ∏è TransactionalConnection

CalculatedPropertySubscriber

GetEntityOrThrowOptions

TransactionalConnection

---

## WrappedMethodArgs

**URL:** https://docs.vendure.io/reference/typescript-api/telemetry/wrapped-method-args

**Contents:**
- WrappedMethodArgs
- WrappedMethodArgs‚Äã
  - instance‚Äã
  - target‚Äã
  - methodName‚Äã
  - args‚Äã
  - applyOriginalFunction‚Äã

The arguments that are passed to the wrapMethod method of the InstrumentationStrategy interface.

The instance of the class which is being instrumented.

The class which is being instrumented.

The name of the method which is being instrumented.

The arguments which are passed to the method.

A function which applies the original method and returns the result. This is used to call the original method after the instrumentation has been applied.

**Examples:**

Example 1 (ts):
```ts
interface WrappedMethodArgs {    instance: any;    target: Type<any>;    methodName: string;    args: any[];    applyOriginalFunction: () => any | Promise<any>;}
```

---

## OrderModification

**URL:** https://docs.vendure.io/reference/typescript-api/entities/order-modification

**Contents:**
- OrderModification
- OrderModification‚Äã
  - constructor‚Äã
  - note‚Äã
  - order‚Äã
  - lines‚Äã
  - surcharges‚Äã
  - priceChange‚Äã
  - payment‚Äã
  - refund‚Äã

An entity which represents a modification to an order which has been placed, and then modified afterwards by an administrator.

**Examples:**

Example 1 (ts):
```ts
class OrderModification extends VendureEntity {    constructor(input?: DeepPartial<OrderModification>)    @Column()    note: string;    @Index()    @ManyToOne(type => Order, order => order.modifications, { onDelete: 'CASCADE' })    order: Order;    @OneToMany(type => OrderModificationLine, line => line.modification)    lines: OrderModificationLine[];    @OneToMany(type => Surcharge, surcharge => surcharge.orderModification)    surcharges: Surcharge[];    @Money()    priceChange: number;    @ManyToOne(type => Payment)    @JoinColumn()    payment?: Payment;    @ManyToOne(type => Refund)    @Join
...
```

---

## CheckShippingEligibilityCheckerFn

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/check-shipping-eligibility-checker-fn

**Contents:**
- CheckShippingEligibilityCheckerFn
- CheckShippingEligibilityCheckerFn‚Äã

A function which implements logic to determine whether a given Order is eligible for a particular shipping method. Once a ShippingMethod has been assigned to an Order, this function will be called on every change to the Order (e.g. updating quantities, adding/removing items etc).

If the code running in this function is expensive, then consider also defining a ShouldRunCheckFn to avoid unnecessary calls.

**Examples:**

Example 1 (ts):
```ts
type CheckShippingEligibilityCheckerFn<T extends ConfigArgs> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    method: ShippingMethod,) => boolean | Promise<boolean>
```

---

## ImportExportOptions

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/import-export-options/

**Contents:**
- ImportExportOptions
- ImportExportOptions‚Äã
  - importAssetsDir‚Äã
  - assetImportStrategy‚Äã

Options related to importing & exporting data.

The directory in which assets to be imported are located.

This strategy determines how asset files get imported based on the path given in the import CSV or via the AssetImporter getAssets() method.

**Examples:**

Example 1 (ts):
```ts
interface ImportExportOptions {    importAssetsDir?: string;    assetImportStrategy?: AssetImportStrategy;}
```

---

## SettingsStoreService

**URL:** https://docs.vendure.io/reference/typescript-api/services/settings-store-service

**Contents:**
- SettingsStoreService
- SettingsStoreService‚Äã
- Usage‚Äã
  - constructor‚Äã
  - onModuleInit‚Äã
  - register‚Äã
  - get‚Äã
  - get‚Äã
  - get‚Äã
  - getMany‚Äã

The SettingsStoreService provides a flexible settings storage system with support for scoping, permissions, and validation. It allows plugins and the core system to store and retrieve configuration data with fine-grained control over access and isolation.

Values are automatically scoped according to their field configuration:

Register settings store fields. This is typically called during application bootstrap when processing the VendureConfig.

Get a value for the specified key. The value is automatically scoped according to the field's scope configuration.

Get multiple values efficiently. Each key is scoped according to its individual field configuration.

Set a value for the specified key with structured result feedback. This version returns detailed information about the success or failure of the operation instead of throwing errors.

Set multiple values with structured result feedback for each operation. This method will not throw errors but will return detailed results for each key-value pair.

Get the field configuration for a key.

Validate a value against its field definition.

Find orphaned settings store entries that no longer have corresponding field definitions.

Clean up orphaned settings store entries from the database.

Check if the current user has permission to access a field. This is not called internally in the get and set methods, so should be used by any methods which are exposing these methods via the GraphQL APIs.

Check if the current user has permission to read a field.

Check if the current user has permission to write a field.

Returns true if the settings field has the readonly: true configuration.

**Examples:**

Example 1 (ts):
```ts
// In a serviceconst userTheme = await this.settingsStoreService.get('dashboard.theme', ctx);await this.settingsStoreService.set('dashboard.theme', 'dark', ctx);// Get multiple valuesconst settings = await this.settingsStoreService.getMany([  'dashboard.theme',  'dashboard.tableFilters'], ctx);
```

Example 2 (ts):
```ts
class SettingsStoreService implements OnModuleInit {    constructor(connection: TransactionalConnection, moduleRef: ModuleRef, configService: ConfigService)    onModuleInit() => ;    register(registration: SettingsStoreRegistration) => void;    get(ctx: RequestContext, key: string) => Promise<T | undefined>;    get(key: string, ctx: RequestContext) => Promise<T | undefined>;    get(keyOrCtx: string | RequestContext, ctxOrKey: RequestContext | string) => Promise<T | undefined>;    getMany(ctx: RequestContext, keys: string[]) => Promise<Record<string, JsonCompatible<any>>>;    getMany(keys: stri
...
```

---

## OrderLineReference

**URL:** https://docs.vendure.io/reference/typescript-api/entities/order-line-reference

**Contents:**
- OrderLineReference
- FulfillmentLine‚Äã
  - constructor‚Äã
  - fulfillment‚Äã
  - fulfillmentId‚Äã
- OrderLineReference‚Äã
  - quantity‚Äã
  - orderLine‚Äã
  - orderLineId‚Äã
- OrderModificationLine‚Äã

This entity represents a line from an Order which has been fulfilled by a Fulfillment.

This is an abstract base class for entities which reference an OrderLine.

This entity represents a line from an Order which has been modified by an OrderModification.

This entity represents a line from an Order which has been refunded by a Refund.

**Examples:**

Example 1 (ts):
```ts
class FulfillmentLine extends OrderLineReference {    constructor(input?: DeepPartial<FulfillmentLine>)    @Index()    @ManyToOne(type => Fulfillment, fulfillment => fulfillment.lines)    fulfillment: Fulfillment;    @EntityId()    fulfillmentId: ID;}
```

Example 2 (ts):
```ts
class OrderLineReference extends VendureEntity {    @Column()    quantity: number;    @Index()    @ManyToOne(type => OrderLine, line => line.linesReferences, { onDelete: 'CASCADE' })    orderLine: OrderLine;    @EntityId()    orderLineId: ID;}
```

Example 3 (ts):
```ts
class OrderModificationLine extends OrderLineReference {    constructor(input?: DeepPartial<OrderModificationLine>)    @Index()    @ManyToOne(type => OrderModification, modification => modification.lines)    modification: OrderModification;    @EntityId()    modificationId: ID;}
```

Example 4 (ts):
```ts
class RefundLine extends OrderLineReference {    constructor(input?: DeepPartial<RefundLine>)    @Index()    @ManyToOne(type => Refund, refund => refund.lines)    refund: Refund;    @EntityId()    refundId: ID;}
```

---

## OrderService

**URL:** https://docs.vendure.io/reference/typescript-api/services/order-service

**Contents:**
- OrderService
- OrderService‚Äã
  - constructor‚Äã
  - getOrderProcessStates‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findOneByCode‚Äã
  - findOneByOrderLineId‚Äã
  - findByCustomerId‚Äã
  - getOrderPayments‚Äã

Contains methods relating to Order entities.

Returns an array of all the configured states and transitions of the order process. This is based on the default order process plus all configured OrderProcess objects defined in the OrderOptions process array.

Returns all Payment entities associated with the Order.

Returns an array of any OrderModification entities associated with the Order.

Returns any Refunds associated with a Payment.

Returns any Order associated with the specified User's Customer account that is still in the active state.

Creates a new, empty Order. If a userId is passed, the Order will get associated with that User's Customer account.

Updates the custom fields of an Order.

Updates the Customer which is assigned to a given Order. The target Customer must be assigned to the same Channels as the Order, otherwise an error will be thrown.

Adds an item to the Order, either creating a new OrderLine or incrementing an existing one.

If you need to add multiple items to an Order, use addItemsToOrder() instead.

Adds multiple items to an Order. This method is more efficient than calling addItemToOrder multiple times, as it only needs to fetch the entire Order once, and only performs price adjustments once at the end.

Since this method can return multiple error results, it is recommended to check the errorResults array to determine if any errors occurred.

Adjusts the quantity and/or custom field values of an existing OrderLine.

If you need to adjust multiple OrderLines, use adjustOrderLines() instead.

Adjusts the quantity and/or custom field values of existing OrderLines. This method is more efficient than calling adjustOrderLine multiple times, as it only needs to fetch the entire Order once, and only performs price adjustments once at the end. Since this method can return multiple error results, it is recommended to check the errorResults array to determine if any errors occurred.

Removes the specified OrderLine from the Order.

If you need to remove multiple OrderLines, use removeItemsFromOrder() instead.

Removes the specified OrderLines from the Order. This method is more efficient than calling removeItemFromOrder multiple times, as it only needs to fetch the entire Order once, and only performs price adjustments once at the end.

Removes all OrderLines from the Order.

Adds a Surcharge to the Order.

Removes a Surcharge from the Order.

Applies a coupon code to the Order, which should be a valid coupon code as specified in the con

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
class OrderService {    constructor(connection: TransactionalConnection, configService: ConfigService, productVariantService: ProductVariantService, customerService: CustomerService, countryService: CountryService, orderCalculator: OrderCalculator, shippingCalculator: ShippingCalculator, orderStateMachine: OrderStateMachine, orderMerger: OrderMerger, paymentService: PaymentService, paymentMethodService: PaymentMethodService, fulfillmentService: FulfillmentService, listQueryBuilder: ListQueryBuilder, refundStateMachine: RefundStateMachine, historyService: HistoryService, promotionService: Promo
...
```

---

## InMemoryJobQueueStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/in-memory-job-queue-strategy

**Contents:**
- InMemoryJobQueueStrategy
- InMemoryJobQueueStrategy‚Äã
  - jobs‚Äã
  - unsettledJobs‚Äã
  - init‚Äã
  - destroy‚Äã
  - add‚Äã
  - findOne‚Äã
  - findMany‚Äã
  - findManyById‚Äã

An in-memory JobQueueStrategy. This is the default strategy if not using a dedicated JobQueue plugin (e.g. DefaultJobQueuePlugin). Not recommended for production, since the queue will be cleared when the server stops, and can only be used when the JobQueueService is started from the main server process:

Attempting to use this strategy when running the worker in a separate process (using bootstrapWorker()) will result in an error on startup.

Completed jobs will be evicted from the store every 2 hours to prevent a memory leak.

Extends: PollingJobQueueStrategy

Implements: InspectableJobQueueStrategy

**Examples:**

Example 1 (ts):
```ts
bootstrap(config)  .then(app => app.get(JobQueueService).start());
```

Example 2 (ts):
```ts
class InMemoryJobQueueStrategy extends PollingJobQueueStrategy implements InspectableJobQueueStrategy {    protected jobs = new Map<ID, Job>();    protected unsettledJobs: { [queueName: string]: Array<{ job: Job; updatedAt: Date }> } = {};    init(injector: Injector) => ;    destroy() => ;    add(job: Job<Data>) => Promise<Job<Data>>;    findOne(id: ID) => Promise<Job | undefined>;    findMany(options?: JobListOptions) => Promise<PaginatedList<Job>>;    findManyById(ids: ID[]) => Promise<Job[]>;    next(queueName: string, waitingJobs: Job[] = []) => Promise<Job | undefined>;    update(job: Job
...
```

---

## RoleService

**URL:** https://docs.vendure.io/reference/typescript-api/services/role-service

**Contents:**
- RoleService
- RoleService‚Äã
  - constructor‚Äã
  - initRoles‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - getChannelsForRole‚Äã
  - getSuperAdminRole‚Äã
  - getCustomerRole‚Äã
  - getAllPermissions‚Äã

Contains methods relating to Role entities.

Returns the special SuperAdmin Role, which always exists in Vendure.

Returns the special Customer Role, which always exists in Vendure.

Returns all the valid Permission values

Returns true if the User has the specified permission on that Channel

Returns true if the User has any of the specified permissions on that Channel

Returns true if the User has all the specified permissions on that Channel

**Examples:**

Example 1 (ts):
```ts
class RoleService {    constructor(connection: TransactionalConnection, channelService: ChannelService, listQueryBuilder: ListQueryBuilder, configService: ConfigService, eventBus: EventBus, requestContextCache: RequestContextCacheService)    initRoles() => ;    findAll(ctx: RequestContext, options?: ListQueryOptions<Role>, relations?: RelationPaths<Role>) => Promise<PaginatedList<Role>>;    findOne(ctx: RequestContext, roleId: ID, relations?: RelationPaths<Role>) => Promise<Role | undefined>;    getChannelsForRole(ctx: RequestContext, roleId: ID) => Promise<Channel[]>;    getSuperAdminRole(ctx
...
```

---

## Navigation

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/navigation

**Contents:**
- Navigation
- DashboardNavSectionDefinition‚Äã
  - id‚Äã
  - title‚Äã
  - icon‚Äã
  - order‚Äã
- NavMenuItem‚Äã
  - id‚Äã
  - title‚Äã
  - url‚Äã

Defines a custom navigation section in the dashboard sidebar.

Individual items can then be added to the section by defining routes in the routes property of your Dashboard extension.

A unique identifier for the navigation section.

The display title for the navigation section.

Optional icon to display next to the section title. The icons should be imported from 'lucide-react'.

Optional order number to control the position of this section in the sidebar.

Defines an items in the navigation menu.

A unique ID for this nav menu item

The title that will appear in the nav menu

The url of the route which this nav item links to.

An optional icon component to represent the item, which should be imported from lucide-react.

The order is an number which allows you to control the relative position in relation to other items in the menu. A higher number appears further down the list.

This can be used to restrict the menu item to the given permission or permissions.

**Examples:**

Example 1 (ts):
```ts
interface DashboardNavSectionDefinition {    id: string;    title: string;    icon?: LucideIcon;    order?: number;}
```

Example 2 (ts):
```ts
import { PlusIcon } from 'lucide-react';
```

Example 3 (ts):
```ts
interface NavMenuItem {    id: string;    title: string;    url: string;    icon?: LucideIcon;    order?: number;    placement?: NavMenuSectionPlacement;    requiresPermission?: string | string[];}
```

---

## StockLocation

**URL:** https://docs.vendure.io/reference/typescript-api/entities/stock-location

**Contents:**
- StockLocation
- StockLocation‚Äã
  - constructor‚Äã
  - name‚Äã
  - description‚Äã
  - customFields‚Äã
  - channels‚Äã
  - stockMovements‚Äã

A StockLocation represents a physical location where stock is held. For example, a warehouse or a shop.

When the stock of a ProductVariant is adjusted, the adjustment is applied to a specific StockLocation, and the stockOnHand of that ProductVariant is updated accordingly. When there are multiple StockLocations configured, the StockLocationStrategy is used to determine which StockLocation should be used for a given operation.

Extends: VendureEntity

Implements: HasCustomFields, ChannelAware

**Examples:**

Example 1 (ts):
```ts
class StockLocation extends VendureEntity implements HasCustomFields, ChannelAware {    constructor(input: DeepPartial<StockLocation>)    @Column()    name: string;    @Column()    description: string;    @Column(type => CustomStockLocationFields)    customFields: CustomStockLocationFields;    @ManyToMany(type => Channel, channel => channel.stockLocations)    @JoinTable()    channels: Channel[];    @OneToMany(type => StockMovement, movement => movement.stockLocation)    stockMovements: StockMovement[];}
```

---

## UiDevkitClient

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/ui-devkit-client/

**Contents:**
- UiDevkitClient
- setTargetOrigin‚Äã
  - value‚Äã
- getActivatedRoute‚Äã
- graphQlQuery‚Äã
  - document‚Äã
  - variables‚Äã
  - fetchPolicy‚Äã
- graphQlMutation‚Äã
  - document‚Äã

Set the window.postMessage API targetOrigin. The Vendure ui-devkit uses the postMessage API to enable cross-frame and cross-origin communication between the ui extension code and the Admin UI app. The targetOrigin is a security feature intended to provide control over where messages are sent.

Retrieves information about the current route of the host application, since it is not possible to otherwise get this information from within the child iframe.

Perform a GraphQL query and returns either an Observable or a Promise of the result.

Perform a GraphQL mutation and returns either an Observable or a Promise of the result.

Display a toast notification.

**Examples:**

Example 1 (ts):
```ts
function setTargetOrigin(value: string): void
```

Example 2 (ts):
```ts
import { getActivatedRoute } from '@vendure/ui-devkit';const route = await getActivatedRoute();const slug = route.params.slug;
```

Example 3 (ts):
```ts
function getActivatedRoute(): Promise<ActiveRouteData>
```

Example 4 (ts):
```ts
import { graphQlQuery } from '@vendure/ui-devkit';const productList = await graphQlQuery(`  query GetProducts($skip: Int, $take: Int) {      products(options: { skip: $skip, take: $take }) {          items { id, name, enabled },          totalItems      }  }`, {    skip: 0,    take: 10,  }).then(data => data.products);
```

---

## Transaction Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/request/transaction-decorator/

**Contents:**
- Transaction Decorator
- Transaction‚Äã
- TransactionMode‚Äã
- TransactionIsolationLevel‚Äã

Runs the decorated method in a TypeORM transaction. It works by creating a transactional QueryRunner which gets attached to the RequestContext object. When the RequestContext is the passed to the TransactionalConnection getRepository() method, this QueryRunner is used to execute the queries within this transaction.

Essentially, the entire resolver function is wrapped in a try-catch block which commits the transaction on successful completion of the method, or rolls back the transaction in an unhandled error is thrown.

The Transaction decorator can handle transactions automatically (which is the default) or be set to "manual" mode, where the TransactionalConnection .startTransaction() and .commitOpenTransaction() methods must them be used.

Note that even in manual mode, a rollback will be automatically performed in the case that an uncaught error is thrown within the resolver.

Transactions can be run at different isolation levels. The default is undefined, which falls back to the default of your database. See the documentation of your database for more information on available isolation levels.

**Examples:**

Example 1 (ts):
```ts
// in a GraphQL resolver file@Transaction()async myMutation(@Ctx() ctx: RequestContext) {  // as long as the `ctx` object is passed in to  // all database operations, the entire mutation  // will be run as an atomic transaction, and rolled  // back if an error is thrown.  const result = this.myService.createThing(ctx);  return this.myService.updateOtherThing(ctx, result.id);}
```

Example 2 (ts):
```ts
// in a GraphQL resolver file@Transaction('manual')async myMutation(@Ctx() ctx: RequestContext) {  await this.connection.startTransaction(ctx);  const result = this.myService.createThing(ctx);  const thing = this.myService.updateOtherThing(ctx, result.id);  await this.connection.commitOpenTransaction(ctx);  return thing;}
```

Example 3 (ts):
```ts
type TransactionMode = 'auto' | 'manual'
```

Example 4 (ts):
```ts
type TransactionIsolationLevel = | 'READ UNCOMMITTED'    | 'READ COMMITTED'    | 'REPEATABLE READ'    | 'SERIALIZABLE'
```

---

## Bulk Actions

**URL:** https://docs.vendure.io/reference/dashboard/list-views/bulk-actions

**Contents:**
- Bulk Actions
- DataTableBulkActionItemProps‚Äã
  - label‚Äã
  - icon‚Äã
  - confirmationText‚Äã
  - onClick‚Äã
  - className‚Äã
  - requiresPermission‚Äã
  - disabled‚Äã
- DataTableBulkActionItem‚Äã

A component that should be used to implement any bulk actions for list pages & data tables.

A bulk action is a component that will be rendered in the bulk actions dropdown.

The component receives the following props:

For the common action of deletion, we provide a ready-made helper component:

Optional order number to control the position of this bulk action in the dropdown. A larger number will appear lower in the list.

The React component that will be rendered as the bulk action item.

**Examples:**

Example 1 (ts):
```ts
interface DataTableBulkActionItemProps {    label: React.ReactNode;    icon?: LucideIcon;    confirmationText?: React.ReactNode;    onClick: () => void;    className?: string;    requiresPermission?: string[];    disabled?: boolean;}
```

Example 2 (tsx):
```tsx
import { DataTableBulkActionItem, Trans } from '@vendure/dashboard';import { Check } from 'lucide-react';export const MyBulkAction: BulkActionComponent<any> = ({ selection, table }) => {  return (    <DataTableBulkActionItem      requiresPermission={['ReadMyCustomEntity']}      onClick={() => {        console.log('Selected items:', selection);      }}      label={<Trans>Delete</Trans>}      confirmationText={<Trans>Are you sure?</Trans>}      icon={Check}      className="text-destructive"    />  );}
```

Example 3 (ts):
```ts
function DataTableBulkActionItem(props: Readonly<DataTableBulkActionItemProps>): void
```

Example 4 (tsx):
```tsx
import { BulkActionComponent, DataTableBulkActionItem, usePaginatedList } from '@vendure/dashboard';// This is an example of a bulk action that shows some typical// uses of the provided propsexport const MyBulkAction: BulkActionComponent<any> = ({ selection, table }) => {  const { refetchPaginatedList } = usePaginatedList();  const doTheAction = async () => {    // Actual logic of the action    // goes here...    // On success, we refresh the list    refetchPaginatedList();    // and un-select any selected rows in the table    table.resetRowSelection();  }; return (   <DataTableBulkActionItem 
...
```

---

## ShippingLineAssignmentStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-line-assignment-strategy/

**Contents:**
- ShippingLineAssignmentStrategy
- ShippingLineAssignmentStrategy‚Äã
  - assignShippingLineToOrderLines‚Äã

This strategy is used to assign a given ShippingLine to one or more OrderLines of the Order. This allows you to set multiple shipping methods for a single order, each assigned a different subset of OrderLines.

The DefaultShippingLineAssignmentStrategy simply assigns all OrderLines, so is suitable for the most common scenario of a single shipping method per Order.

This is configured via the shippingOptions.shippingLineAssignmentStrategy property of your VendureConfig.

Here's an example of a custom ShippingLineAssignmentStrategy which assigns digital products to a different ShippingLine to physical products:

**Examples:**

Example 1 (ts):
```ts
import {    Order,    OrderLine,    RequestContext,    ShippingLine,    ShippingLineAssignmentStrategy,} from '@vendure/core';export class DigitalShippingLineAssignmentStrategy implements ShippingLineAssignmentStrategy {    assignShippingLineToOrderLines(        ctx: RequestContext,        shippingLine: ShippingLine,        order: Order,    ): OrderLine[] | Promise<OrderLine[]> {        if (shippingLine.shippingMethod.customFields.isDigital) {            return order.lines.filter(l => l.productVariant.customFields.isDigital);        } else {            return order.lines.filter(l => !l.product
...
```

Example 2 (ts):
```ts
interface ShippingLineAssignmentStrategy extends InjectableStrategy {    assignShippingLineToOrderLines(        ctx: RequestContext,        shippingLine: ShippingLine,        order: Order,    ): OrderLine[] | Promise<OrderLine[]>;}
```

---

## VendureImage

**URL:** https://docs.vendure.io/reference/dashboard/components/vendure-image

**Contents:**
- VendureImage
- VendureImage‚Äã
  - props‚Äã
- VendureImageProps‚Äã
  - asset‚Äã
  - preset‚Äã
  - mode‚Äã
  - width‚Äã
  - height‚Äã
  - format‚Äã

A component for displaying an image from a Vendure asset.

Supports the following features:

The props for the VendureImage component.

The asset to display.

The preset to use for the image.

The crop/resize mode to use for the image.

The width of the image.

The height of the image.

The format of the image.

The quality of the image.

Whether to use the asset's focal point in crop mode.

The fallback to show if no asset is provided. If no fallback is provided, a default placeholder will be shown.

The ref to the image element.

The type of object that can be used as an asset in the VendureImage component.

The presets that can be used for the VendureImage component.

The formats that can be used for the VendureImage component.

The modes that can be used for the VendureImage component.

**Examples:**

Example 1 (tsx):
```tsx
<VendureImage     asset={asset}     preset="thumb"     className="w-full h-full object-contain" />
```

Example 2 (ts):
```ts
function VendureImage(props: VendureImageProps): void
```

Example 3 (ts):
```ts
interface VendureImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {    asset: AssetLike | null | undefined;    preset?: ImagePreset;    mode?: ImageMode;    width?: number;    height?: number;    format?: ImageFormat;    quality?: number;    useFocalPoint?: boolean;    fallback?: React.ReactNode;    ref?: React.Ref<HTMLImageElement>;}
```

Example 4 (ts):
```ts
interface AssetLike {    id: string;    preview: string;    name?: string | null;    focalPoint?: { x: number; y: number } | null;}
```

---

## DefaultSlugStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/default-slug-strategy

**Contents:**
- DefaultSlugStrategy
- DefaultSlugStrategy‚Äã
  - generate‚Äã

The default strategy for generating slugs. This strategy:

**Examples:**

Example 1 (ts):
```ts
const strategy = new DefaultSlugStrategy();strategy.generate(ctx, { value: "Hello World!" }); // "hello-world"strategy.generate(ctx, { value: "Caf√© Fran√ßais" }); // "cafe-francais"strategy.generate(ctx, { value: "100% Natural" }); // "100-natural"
```

Example 2 (ts):
```ts
class DefaultSlugStrategy implements SlugStrategy {    generate(ctx: RequestContext, params: SlugGenerateParams) => string;}
```

---

## SettingsStoreEntry

**URL:** https://docs.vendure.io/reference/typescript-api/entities/settings-store-entry

**Contents:**
- SettingsStoreEntry
- SettingsStoreEntry‚Äã
  - constructor‚Äã
  - key‚Äã
  - value‚Äã
  - scope‚Äã

An entity for storing arbitrary settings data with scoped isolation. This is used by the SettingsStore system to provide flexible key-value storage with support for user, channel, and custom scoping.

The settings key, typically in the format 'namespace.fieldName'

The JSON value stored for this setting

The scope string that isolates this setting (e.g., 'user:123', 'channel:456', '')

**Examples:**

Example 1 (ts):
```ts
class SettingsStoreEntry extends VendureEntity {    constructor(input?: Partial<SettingsStoreEntry>)    @Index()    @Column()    key: string;    @Column('json', { nullable: true })    value: any | null;    @Index()    @Column({ type: 'varchar', nullable: true })    scope: string | null;}
```

---

## Routes

**URL:** https://docs.vendure.io/reference/admin-ui-api/routes/

**Contents:**
- Routes
- üìÑÔ∏è RegisterRouteComponentOptions
- üìÑÔ∏è RegisterRouteComponent

RegisterRouteComponentOptions

registerRouteComponent

---

## OrderItemPriceCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-item-price-calculation-strategy

**Contents:**
- OrderItemPriceCalculationStrategy
- OrderItemPriceCalculationStrategy‚Äã
  - When is the strategy invoked ?‚Äã
  - OrderItemPriceCalculationStrategy vs Promotions‚Äã
  - Example use-cases‚Äã
  - calculateUnitPrice‚Äã

The OrderItemPriceCalculationStrategy defines the listPrice of an OrderLine when adding an item to an Order. By default the DefaultOrderItemPriceCalculationStrategy is used.

This is configured via the orderOptions.orderItemPriceCalculationStrategy property of your VendureConfig.

Both the OrderItemPriceCalculationStrategy and Promotions can be used to alter the price paid for a product.

The main difference is when a Promotion is applied, it adds a discount line to the Order, and the regular price is used for the value of OrderLine.listPrice property, whereas the OrderItemPriceCalculationStrategy actually alters the value of OrderLine.listPrice itself, and does not add any discounts to the Order.

Use OrderItemPriceCalculationStrategy if:

A custom OrderItemPriceCalculationStrategy can be used to implement things like:

Receives the ProductVariant to be added to the Order as well as any OrderLine custom fields and returns the price for a single unit.

Note: if you have any relation type custom fields defined on the OrderLine entity, they will only be passed in to this method if they are set to eager: true. Otherwise, you can use the EntityHydratorto join the missing relations.

Note: the quantity argument was added in v2.0.0

**Examples:**

Example 1 (ts):
```ts
interface OrderItemPriceCalculationStrategy extends InjectableStrategy {    calculateUnitPrice(        ctx: RequestContext,        productVariant: ProductVariant,        orderLineCustomFields: { [key: string]: any },        order: Order,        quantity: number,    ): PriceCalculationResult | Promise<PriceCalculationResult>;}
```

---

## ProductService

**URL:** https://docs.vendure.io/reference/typescript-api/services/product-service

**Contents:**
- ProductService
- ProductService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findByIds‚Äã
  - getProductChannels‚Äã
  - getFacetValuesForProduct‚Äã
  - findOneBySlug‚Äã
  - create‚Äã

Contains methods relating to Product entities.

Returns all Channels to which the Product is assigned.

Assigns a Product to the specified Channel, and optionally uses a priceFactor to set the ProductVariantPrices on the new Channel.

Internally, this method will also call ProductVariantService assignProductVariantsToChannel() for each of the Product's variants, and will assign the Product's Assets to the Channel too.

**Examples:**

Example 1 (ts):
```ts
class ProductService {    constructor(connection: TransactionalConnection, channelService: ChannelService, assetService: AssetService, productVariantService: ProductVariantService, facetValueService: FacetValueService, listQueryBuilder: ListQueryBuilder, translatableSaver: TranslatableSaver, eventBus: EventBus, slugValidator: SlugValidator, customFieldRelationService: CustomFieldRelationService, translator: TranslatorService, productOptionGroupService: ProductOptionGroupService)    findAll(ctx: RequestContext, options?: ListQueryOptions<Product>, relations?: RelationPaths<Product>) => Promise<
...
```

---

## ErrorResultGuard

**URL:** https://docs.vendure.io/reference/typescript-api/testing/error-result-guard

**Contents:**
- ErrorResultGuard
- ErrorResultGuard‚Äã
  - constructor‚Äã
  - isSuccess‚Äã
  - assertSuccess‚Äã
  - assertErrorResult‚Äã

A utility class which is used to assert the success of an operation which returns a union type of SuccessType | ErrorResponse [ | ErrorResponse ]. The methods of this class are used to:

A type guard which returns true if the input passes the testFn predicate.

Asserts (using the testing library's fail() function) that the input is successful, i.e. it passes the testFn.

Asserts (using the testing library's fail() function) that the input is not successful, i.e. it does not pass the testFn.

**Examples:**

Example 1 (ts):
```ts
const orderResultGuard: ErrorResultGuard<AddItemToOrderResult>  = createErrorResultGuard(order => !!order.lines);it('errors when quantity is negative', async () => {   const { addItemToOrder } = await shopClient.query<AddItemToOrder.Query, AddItemToOrder.Mutation>(ADD_ITEM_TO_ORDER, {     productVariantId: 42, quantity: -1,   });   // The test will fail   orderResultGuard.assertErrorResult(addItemToOrder);   // the type of `addItemToOrder` has now been   // narrowed to only include the ErrorResult types.   expect(addItemToOrder.errorCode).toBe(ErrorCode.NegativeQuantityError);}
```

Example 2 (ts):
```ts
class ErrorResultGuard<T> {    constructor(testFn: (input: T) => boolean)    isSuccess(input: T | any) => input is T;    assertSuccess(input: T | R) => asserts input is T;    assertErrorResult(input: T | R) => asserts input is R;}
```

---

## DefaultActiveOrderStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/default-active-order-strategy

**Contents:**
- DefaultActiveOrderStrategy
- DefaultActiveOrderStrategy‚Äã
  - name‚Äã
  - init‚Äã
  - createActiveOrder‚Äã
  - determineActiveOrder‚Äã

The default ActiveOrderStrategy, which uses the current Session to determine the active Order, and requires no additional input in the Shop API since it is based on the session which is part of the RequestContext.

**Examples:**

Example 1 (ts):
```ts
class DefaultActiveOrderStrategy implements ActiveOrderStrategy {    name: 'default-active-order-strategy';    init(injector: Injector) => ;    createActiveOrder(ctx: RequestContext) => ;    determineActiveOrder(ctx: RequestContext) => ;}
```

---

## AssetPickerDialogComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/asset-picker-dialog-component

**Contents:**
- AssetPickerDialogComponent
- AssetPickerDialogComponent‚Äã
  - assets$‚Äã
  - allTags$‚Äã
  - paginationConfig‚Äã
  - multiSelect‚Äã
  - initialTags‚Äã
  - resolveWith‚Äã
  - selection‚Äã
  - searchTerm$‚Äã

A dialog which allows the creation and selection of assets.

**Examples:**

Example 1 (ts):
```ts
selectAssets() {  this.modalService    .fromComponent(AssetPickerDialogComponent, {        size: 'xl',    })    .subscribe(result => {        if (result && result.length) {            // ...        }    });}
```

Example 2 (ts):
```ts
class AssetPickerDialogComponent implements OnInit, AfterViewInit, OnDestroy, Dialog<Asset[]> {    assets$: Observable<AssetLike[]>;    allTags$: Observable<TagFragment[]>;    paginationConfig: PaginationInstance = {        currentPage: 1,        itemsPerPage: 25,        totalItems: 1,    };    multiSelect = true;    initialTags: string[] = [];    resolveWith: (result?: Asset[]) => void;    selection: Asset[] = [];    searchTerm$ = new BehaviorSubject<string | undefined>(undefined);    filterByTags$ = new BehaviorSubject<TagFragment[] | undefined>(undefined);    uploading = false;    construct
...
```

---

## LocaleCurrencyNamePipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/locale-currency-name-pipe

**Contents:**
- LocaleCurrencyNamePipe
- LocaleCurrencyNamePipe‚Äã
  - constructor‚Äã
  - transform‚Äã

Displays a human-readable name for a given ISO 4217 currency code.

Extends: LocaleBasePipe

Implements: PipeTransform

**Examples:**

Example 1 (html):
```html
{{ order.currencyCode | localeCurrencyName }}
```

Example 2 (ts):
```ts
class LocaleCurrencyNamePipe extends LocaleBasePipe implements PipeTransform {    constructor(dataService?: DataService, changeDetectorRef?: ChangeDetectorRef)    transform(value: any, display: 'full' | 'symbol' | 'name' = 'full', locale?: unknown) => any;}
```

---

## BcryptPasswordHashingStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/bcrypt-password-hashing-strategy

**Contents:**
- BcryptPasswordHashingStrategy
- BcryptPasswordHashingStrategy‚Äã
  - hash‚Äã
  - check‚Äã

A hashing strategy which uses bcrypt (https://en.wikipedia.org/wiki/Bcrypt) to hash plaintext password strings.

**Examples:**

Example 1 (ts):
```ts
class BcryptPasswordHashingStrategy implements PasswordHashingStrategy {    hash(plaintext: string) => Promise<string>;    check(plaintext: string, hash: string) => Promise<boolean>;}
```

---

## PaymentService

**URL:** https://docs.vendure.io/reference/typescript-api/services/payment-service

**Contents:**
- PaymentService
- PaymentService‚Äã
  - constructor‚Äã
  - create‚Äã
  - findOneOrThrow‚Äã
  - transitionToState‚Äã
  - getNextStates‚Äã
  - createPayment‚Äã
  - settlePayment‚Äã
  - cancelPayment‚Äã

Contains methods relating to Payment entities.

Transitions a Payment to the given state.

When updating a Payment in the context of an Order, it is preferable to use the OrderService transitionPaymentToState() method, which will also handle updating the Order state too.

Creates a new Payment.

When creating a Payment in the context of an Order, it is preferable to use the OrderService addPaymentToOrder() method, which will also handle updating the Order state too.

When settling a Payment in the context of an Order, it is preferable to use the OrderService settlePayment() method, which will also handle updating the Order state too.

Creates a Payment from the manual payment mutation in the Admin API

When creating a manual Payment in the context of an Order, it is preferable to use the OrderService addManualPaymentToOrder() method, which will also handle updating the Order state too.

Creates a Refund against the specified Payment. If the amount to be refunded exceeds the value of the specified Payment (in the case of multiple payments on a single Order), then the remaining outstanding refund amount will be refunded against the next available Payment from the Order.

When creating a Refund in the context of an Order, it is preferable to use the OrderService refundOrder() method, which performs additional validation.

**Examples:**

Example 1 (ts):
```ts
class PaymentService {    constructor(connection: TransactionalConnection, paymentStateMachine: PaymentStateMachine, refundStateMachine: RefundStateMachine, paymentMethodService: PaymentMethodService, eventBus: EventBus)    create(ctx: RequestContext, input: DeepPartial<Payment>) => Promise<Payment>;    findOneOrThrow(ctx: RequestContext, id: ID, relations: string[] = ['order']) => Promise<Payment>;    transitionToState(ctx: RequestContext, paymentId: ID, state: PaymentState) => Promise<Payment | PaymentStateTransitionError>;    getNextStates(payment: Payment) => readonly PaymentState[];    cr
...
```

---

## ChipComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/chip-component

**Contents:**
- ChipComponent
- ChipComponent‚Äã
  - icon‚Äã
  - invert‚Äã
  - colorFrom‚Äã
  - colorType‚Äã
  - iconClick‚Äã

A chip component for displaying a label with an optional action icon.

The icon should be the name of one of the available Clarity icons: https://clarity.design/foundation/icons/shapes/

If set, the chip will have an auto-generated background color based on the string value passed in.

The color of the chip can also be one of the standard status colors.

**Examples:**

Example 1 (html):
```html
<vdr-chip [colorFrom]="item.value"          icon="close"          (iconClick)="clear(item)">{{ item.value }}</vdr-chip>
```

Example 2 (ts):
```ts
class ChipComponent {    @Input() icon: string;    @Input() invert = false;    @Input() colorFrom = '';    @Input() colorType: 'error' | 'success' | 'warning';    @Output() iconClick = new EventEmitter<MouseEvent>();}
```

---

## ProductVariantService

**URL:** https://docs.vendure.io/reference/typescript-api/services/product-variant-service

**Contents:**
- ProductVariantService
- ProductVariantService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findByIds‚Äã
  - getVariantsByProductId‚Äã
  - getVariantsByCollectionId‚Äã
  - getProductVariantChannels‚Äã
  - getProductVariantPrices‚Äã

Contains methods relating to ProductVariant entities.

Returns a PaginatedList of all ProductVariants associated with the given Collection.

Returns all Channels to which the ProductVariant is assigned.

Returns the ProductVariant associated with the given OrderLine.

Returns the ProductOptions for the given ProductVariant.

Returns the Product associated with the ProductVariant. Whereas the ProductService.findOne() method performs a large multi-table join with all the typical data needed for a "product detail" page, this method returns only the Product itself.

Returns the number of saleable units of the ProductVariant, i.e. how many are available for purchase by Customers. This is determined by the ProductVariant's stockOnHand value, as well as the local and global outOfStockThreshold settings.

Returns the stockLevel to display to the customer, as specified by the configured StockDisplayStrategy.

Returns the number of fulfillable units of the ProductVariant, equivalent to stockOnHand for those variants which are tracking inventory.

Creates a ProductVariantPrice for the given ProductVariant/Channel combination. If the currencyCode is not specified, the default currency of the Channel will be used.

This method is intended to be used by the ProductVariant GraphQL entity resolver to resolve the price-related fields which need to be populated at run-time using the applyChannelPriceAndTax method.

Is optimized to make as few DB calls as possible using caching based on the open request.

Populates the price field with the price for the specified channel.

Assigns the specified ProductVariants to the specified Channel. In doing so, it will create a new ProductVariantPrice and also assign the associated Product and any Assets to the Channel too.

**Examples:**

Example 1 (ts):
```ts
class ProductVariantService {    constructor(connection: TransactionalConnection, configService: ConfigService, taxCategoryService: TaxCategoryService, facetValueService: FacetValueService, assetService: AssetService, translatableSaver: TranslatableSaver, eventBus: EventBus, listQueryBuilder: ListQueryBuilder, globalSettingsService: GlobalSettingsService, stockMovementService: StockMovementService, stockLevelService: StockLevelService, channelService: ChannelService, roleService: RoleService, customFieldRelationService: CustomFieldRelationService, requestCache: RequestContextCacheService, prod
...
```

---

## IsGraphQlErrorResult

**URL:** https://docs.vendure.io/reference/typescript-api/errors/is-graph-ql-error-result

**Contents:**
- IsGraphQlErrorResult
- isGraphQlErrorResult‚Äã
  - input‚Äã

Returns true if the ErrorResultUnion is actually an ErrorResult type. This is useful when dealing with certain internal service method that return an ErrorResultUnion.

**Examples:**

Example 1 (ts):
```ts
import { isGraphQlErrorResult } from '@vendure/core';// ...const transitionResult = await this.orderService.transitionToState(ctx, order.id, newState);if (isGraphQlErrorResult(transitionResult)) {    // The transition failed with an ErrorResult    throw transitionResult;} else {    // TypeScript will correctly infer the type of `transitionResult` to be `Order`    return transitionResult;}
```

Example 2 (ts):
```ts
function isGraphQlErrorResult<T extends GraphQLErrorResult | U, U = any>(input: T): input is JustErrorResults<T>
```

---

## BootstrapWorker

**URL:** https://docs.vendure.io/reference/typescript-api/worker/bootstrap-worker

**Contents:**
- BootstrapWorker
- bootstrapWorker‚Äã
  - userConfig‚Äã
  - options‚Äã
- BootstrapWorkerOptions‚Äã
  - nestApplicationContextOptions‚Äã
  - ignoreCompatibilityErrorsForPlugins‚Äã

Bootstraps a Vendure worker. Resolves to a VendureWorker object containing a reference to the underlying NestJs standalone application as well as convenience methods for starting the job queue and health check server.

Read more about the Vendure Worker.

Additional options that can be used to configure the bootstrap process of the Vendure worker.

These options get passed directly to the NestFactory.createApplicationContext method.

See the ignoreCompatibilityErrorsForPlugins option in BootstrapOptions.

**Examples:**

Example 1 (ts):
```ts
import { bootstrapWorker } from '@vendure/core';import { config } from './vendure-config';bootstrapWorker(config)  .then(worker => worker.startJobQueue())  .then(worker => worker.startHealthCheckServer({ port: 3020 }))  .catch(err => {    console.log(err);    process.exit(1);  });
```

Example 2 (ts):
```ts
function bootstrapWorker(userConfig: Partial<VendureConfig>, options?: BootstrapWorkerOptions): Promise<VendureWorker>
```

Example 3 (ts):
```ts
interface BootstrapWorkerOptions {    nestApplicationContextOptions?: NestApplicationContextOptions;    ignoreCompatibilityErrorsForPlugins?: Array<DynamicModule | Type<any>>;}
```

---

## PromotionOptions

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/promotion-options

**Contents:**
- PromotionOptions
- PromotionOptions‚Äã
  - promotionConditions‚Äã
  - promotionActions‚Äã

An array of conditions which can be used to construct Promotions

An array of actions which can be used to construct Promotions

**Examples:**

Example 1 (ts):
```ts
interface PromotionOptions {    promotionConditions?: Array<PromotionCondition<any>>;    promotionActions?: Array<PromotionAction<any>>;}
```

---

## Services

**URL:** https://docs.vendure.io/reference/typescript-api/services/

**Contents:**
- Services
- üìÑÔ∏è AdministratorService
- üìÑÔ∏è AssetService
- üìÑÔ∏è AuthService
- üìÑÔ∏è ChannelService
- üìÑÔ∏è CollectionService
- üìÑÔ∏è CountryService
- üìÑÔ∏è CustomerGroupService
- üìÑÔ∏è CustomerService
- üìÑÔ∏è EntitySlugService

GlobalSettingsService

ProductOptionGroupService

ProductVariantService

ShippingMethodService

---

## VerificationTokenStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/verification-token-strategy

**Contents:**
- VerificationTokenStrategy
- VerificationTokenStrategy‚Äã
  - generateVerificationToken‚Äã
  - verifyVerificationToken‚Äã

Defines a custom strategy for creating and validating verification tokens.

This is configured via the authOptions.verificationTokenStrategy property of your VendureConfig.

Generates a verification token.

Checks the validity of a verification token.

**Examples:**

Example 1 (ts):
```ts
interface VerificationTokenStrategy extends InjectableStrategy {    generateVerificationToken(ctx: RequestContext): Promise<string> | string;    verifyVerificationToken(ctx: RequestContext, token: string): Promise<boolean> | boolean;}
```

---

## JobQueueStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job-queue-strategy

**Contents:**
- JobQueueStrategy
- JobQueueStrategy‚Äã
  - add‚Äã
  - start‚Äã
  - stop‚Äã

Defines how the jobs in the JobQueueService are persisted and accessed. Custom strategies can be defined to make use of external services such as Redis.

This is configured via the jobQueueOptions.jobQueueStrategy property of your VendureConfig.

Add a new job to the queue.

Stops a queue from running. Its not guaranteed to stop immediately.

**Examples:**

Example 1 (ts):
```ts
interface JobQueueStrategy extends InjectableStrategy {    add<Data extends JobData<Data> = object>(job: Job<Data>, jobOptions?: JobQueueStrategyJobOptions<Data>): Promise<Job<Data>>;    start<Data extends JobData<Data> = object>(        queueName: string,        process: (job: Job<Data>) => Promise<any>,    ): Promise<void>;    stop<Data extends JobData<Data> = object>(        queueName: string,        process: (job: Job<Data>) => Promise<any>,    ): Promise<void>;}
```

---

## HardenPluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/harden-plugin/harden-plugin-options

**Contents:**
- HardenPluginOptions
- HardenPluginOptions‚Äã
  - maxQueryComplexity‚Äã
  - queryComplexityEstimators‚Äã
  - logComplexityScore‚Äã
  - customComplexityFactors‚Äã
  - hideFieldSuggestions‚Äã
  - apiMode‚Äã
  - skip‚Äã

Options that can be passed to the .init() static method of the HardenPlugin.

Defines the maximum permitted complexity score of a query. The complexity score is based on the number of fields being selected as well as other factors like whether there are nested lists.

A query which exceeds the maximum score will result in an error.

An array of custom estimator functions for calculating the complexity of a query. By default, the plugin will use the defaultVendureComplexityEstimator which is specifically tuned to accurately estimate Vendure queries.

When set to true, the complexity score of each query will be logged at the Verbose log level, and a breakdown of the calculation for each field will be logged at the Debug level.

This is very useful for tuning your complexity scores.

This object allows you to tune the complexity weight of specific fields. For example, if you have a custom stockLocations field defined on the ProductVariant type, and you know that it is a particularly expensive operation to execute, you can increase its complexity like this:

Graphql-js will make suggestions about the names of fields if an invalid field name is provided. This would allow an attacker to find out the available fields by brute force even if introspection is disabled.

Setting this option to true will prevent these suggestion error messages from being returned, instead replacing the message with a generic "Invalid request" message.

When set to 'prod', the plugin will disable dev-mode features of the GraphQL APIs:

Allows you to skip the complexity check for certain requests.

**Examples:**

Example 1 (ts):
```ts
interface HardenPluginOptions {    maxQueryComplexity?: number;    queryComplexityEstimators?: ComplexityEstimator[];    logComplexityScore?: boolean;    customComplexityFactors?: {        [path: string]: number;    };    hideFieldSuggestions?: boolean;    apiMode?: 'dev' | 'prod';    skip?: (context: GraphQLRequestContext<any>) => Promise<boolean> | boolean;}
```

Example 2 (ts):
```ts
HardenPlugin.init({  maxQueryComplexity: 650,  customComplexityFactors: {    'ProductVariant.stockLocations': 10  }}),
```

Example 3 (ts):
```ts
HardenPlugin.init({  skip: (context) => context.request.http.headers['x-storefront-ssr-auth'] === 'some-secret-token'}),
```

---

## CustomerGroupService

**URL:** https://docs.vendure.io/reference/typescript-api/services/customer-group-service

**Contents:**
- CustomerGroupService
- CustomerGroupService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - getGroupCustomers‚Äã
  - create‚Äã
  - update‚Äã
  - delete‚Äã
  - addCustomersToGroup‚Äã

Contains methods relating to CustomerGroup entities.

Returns a PaginatedList of all the Customers in the group.

**Examples:**

Example 1 (ts):
```ts
class CustomerGroupService {    constructor(connection: TransactionalConnection, listQueryBuilder: ListQueryBuilder, historyService: HistoryService, eventBus: EventBus, customFieldRelationService: CustomFieldRelationService)    findAll(ctx: RequestContext, options?: CustomerGroupListOptions, relations: RelationPaths<CustomerGroup> = []) => Promise<PaginatedList<CustomerGroup>>;    findOne(ctx: RequestContext, customerGroupId: ID, relations: RelationPaths<CustomerGroup> = []) => Promise<CustomerGroup | undefined>;    getGroupCustomers(ctx: RequestContext, customerGroupId: ID, options?: Customer
...
```

---

## PromotionService

**URL:** https://docs.vendure.io/reference/typescript-api/services/promotion-service

**Contents:**
- PromotionService
- PromotionService‚Äã
  - availableConditions‚Äã
  - availableActions‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - getPromotionConditions‚Äã
  - getPromotionActions‚Äã
  - createPromotion‚Äã

Contains methods relating to Promotion entities.

Checks the validity of a coupon code, by checking that it is associated with an existing, enabled and non-expired Promotion. Additionally, if there is a usage limit on the coupon code, this method will enforce that limit against the specified Customer.

Used internally to associate a Promotion with an Order, once an Order has been placed.

**Examples:**

Example 1 (ts):
```ts
class PromotionService {    availableConditions: PromotionCondition[] = [];    availableActions: PromotionAction[] = [];    constructor(connection: TransactionalConnection, configService: ConfigService, channelService: ChannelService, listQueryBuilder: ListQueryBuilder, configArgService: ConfigArgService, customFieldRelationService: CustomFieldRelationService, eventBus: EventBus, translatableSaver: TranslatableSaver, translator: TranslatorService)    findAll(ctx: RequestContext, options?: ListQueryOptions<Promotion>, relations: RelationPaths<Promotion> = []) => Promise<PaginatedList<Promotion>
...
```

---

## ChannelService

**URL:** https://docs.vendure.io/reference/typescript-api/services/channel-service

**Contents:**
- ChannelService
- ChannelService‚Äã
  - constructor‚Äã
  - assignToCurrentChannel‚Äã
  - assignToChannels‚Äã
  - removeFromChannels‚Äã
  - getChannelFromToken‚Äã
  - getChannelFromToken‚Äã
  - getChannelFromToken‚Äã
  - getDefaultChannel‚Äã

Contains methods relating to Channel entities.

Assigns a ChannelAware entity to the default Channel as well as any channel specified in the RequestContext. This method will not save the entity to the database, but assigns the channels property of the entity.

Assigns the entity to the given Channels and saves all changes to the database.

Removes the entity from the given Channels and saves.

Given a channel token, returns the corresponding Channel if it exists, else will throw a ChannelNotFoundError.

Returns the default Channel.

Type guard method which returns true if the given entity is an instance of a class which implements the ChannelAware interface.

**Examples:**

Example 1 (ts):
```ts
class ChannelService {    constructor(connection: TransactionalConnection, configService: ConfigService, globalSettingsService: GlobalSettingsService, customFieldRelationService: CustomFieldRelationService, eventBus: EventBus, listQueryBuilder: ListQueryBuilder)    assignToCurrentChannel(entity: T, ctx: RequestContext) => Promise<T>;    assignToChannels(ctx: RequestContext, entityType: Type<T>, entityId: ID, channelIds: ID[]) => Promise<T>;    removeFromChannels(ctx: RequestContext, entityType: Type<T>, entityId: ID, channelIds: ID[]) => Promise<T | undefined>;    getChannelFromToken(token: st
...
```

---

## FacetValueSelectorComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/facet-value-selector-component

**Contents:**
- FacetValueSelectorComponent
- FacetValueSelectorComponent‚Äã
  - selectedValuesChange‚Äã
  - readonly‚Äã
  - transformControlValueAccessorValue‚Äã
  - searchInput$‚Äã
  - searchLoading‚Äã
  - searchResults$‚Äã
  - selectedIds$‚Äã
  - onChangeFn‚Äã

A form control for selecting facet values.

The selectedValuesChange event will emit an array of FacetValue objects.

**Examples:**

Example 1 (html):
```html
<vdr-facet-value-selector  (selectedValuesChange)="selectedValues = $event"></vdr-facet-value-selector>
```

Example 2 (ts):
```ts
class FacetValueSelectorComponent implements OnInit, OnDestroy, ControlValueAccessor {    @Output() selectedValuesChange = new EventEmitter<FacetValueFragment[]>();    @Input() readonly = false;    @Input() transformControlValueAccessorValue: (value: FacetValueFragment[]) => any[] = value => value;    searchInput$ = new Subject<string>();    searchLoading = false;    searchResults$: Observable<FacetValueFragment[]>;    selectedIds$ = new Subject<string[]>();    onChangeFn: (val: any) => void;    onTouchFn: () => void;    disabled = false;    value: Array<string | FacetValueFragment>;    constr
...
```

---

## CustomFieldConfig

**URL:** https://docs.vendure.io/reference/typescript-api/custom-fields/custom-field-config

**Contents:**
- CustomFieldConfig
- CustomFieldConfig‚Äã

An object used to configure a custom field.

**Examples:**

Example 1 (ts):
```ts
type CustomFieldConfig = | StringCustomFieldConfig    | LocaleStringCustomFieldConfig    | TextCustomFieldConfig    | LocaleTextCustomFieldConfig    | IntCustomFieldConfig    | FloatCustomFieldConfig    | BooleanCustomFieldConfig    | DateTimeCustomFieldConfig    | RelationCustomFieldConfig    | StructCustomFieldConfig
```

---

## Promotions

**URL:** https://docs.vendure.io/reference/typescript-api/promotions/

**Contents:**
- Promotions
- üìÑÔ∏è FacetValueChecker
- üìÑÔ∏è Promotion Action
- üìÑÔ∏è Promotion Condition
- üìÑÔ∏è PromotionOptions

---

## PaymentMethodConfigOptions

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-method-config-options/

**Contents:**
- PaymentMethodConfigOptions
- PaymentMethodConfigOptions‚Äã
  - createPayment‚Äã
  - settlePayment‚Äã
  - cancelPayment‚Äã
  - createRefund‚Äã
  - onStateTransitionStart‚Äã

Defines the object which is used to construct the PaymentMethodHandler.

This function provides the logic for creating a payment. For example, it may call out to a third-party service with the data and should return a CreatePaymentResult object contains the details of the payment.

This function provides the logic for settling a payment, also known as "capturing". For payment integrations that settle/capture the payment on creation (i.e. the createPayment() method returns with a state of 'Settled') this method need only return { success: true }.

This function provides the logic for cancelling a payment, which would be invoked when a call is made to the cancelPayment mutation in the Admin API. Cancelling a payment can apply if, for example, you have created a "payment intent" with the payment provider but not yet completed the payment. It allows the incomplete payment to be cleaned up on the provider's end if it gets cancelled via Vendure.

This function provides the logic for refunding a payment created with this payment method. Some payment providers may not provide the facility to programmatically create a refund. In such a case, this method should be omitted and any Refunds will have to be settled manually by an administrator.

This function, when specified, will be invoked before any transition from one PaymentState to another. The return value (a sync / async boolean) is used to determine whether the transition is permitted.

**Examples:**

Example 1 (ts):
```ts
interface PaymentMethodConfigOptions<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {    createPayment: CreatePaymentFn<T>;    settlePayment: SettlePaymentFn<T>;    cancelPayment?: CancelPaymentFn<T>;    createRefund?: CreateRefundFn<T>;    onStateTransitionStart?: OnTransitionStartFn<PaymentState, PaymentTransitionData>;}
```

---

## PaymentOptions

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-options

**Contents:**
- PaymentOptions
- PaymentOptions‚Äã
  - paymentMethodHandlers‚Äã
  - paymentMethodEligibilityCheckers‚Äã
  - customPaymentProcess‚Äã
  - process‚Äã
  - refundProcess‚Äã

Defines payment-related options in the VendureConfig.

Defines which PaymentMethodHandlers are available when configuring PaymentMethods

Defines which PaymentMethodEligibilityCheckers are available when configuring PaymentMethods

Allows the definition of custom states and transition logic for the payment process state machine. Takes an array of objects implementing the PaymentProcess interface.

Allows the definition of custom states and transition logic for the refund process state machine. Takes an array of objects implementing the RefundProcess interface.

**Examples:**

Example 1 (ts):
```ts
interface PaymentOptions {    paymentMethodHandlers: PaymentMethodHandler[];    paymentMethodEligibilityCheckers?: PaymentMethodEligibilityChecker[];    customPaymentProcess?: Array<PaymentProcess<any>>;    process?: Array<PaymentProcess<any>>;    refundProcess?: Array<RefundProcess<any>>;}
```

---

## SettingsStoreFieldConfig

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/settings-store-field-config

**Contents:**
- SettingsStoreFieldConfig
- SettingsStoreFieldConfig‚Äã
  - name‚Äã
  - scope‚Äã
  - readonly‚Äã
  - requiresPermission‚Äã
  - validate‚Äã

Configuration for a settings store field, defining how it should be stored, scoped, validated, and accessed.

The name of the field. This will be combined with the namespace to create the full key (e.g., 'dashboard.theme').

Function that determines how this field should be scoped. Defaults to global scoping (no isolation).

Whether this field is readonly via the GraphQL API. Readonly fields can still be modified programmatically via a service.

Permissions required to access this field. If not specified, basic authentication is required for admin API access.

Custom validation function for field values.

**Examples:**

Example 1 (ts):
```ts
interface SettingsStoreFieldConfig {    name: string;    scope?: SettingsStoreScopeFunction;    readonly?: boolean;    requiresPermission?:        | Array<Permission | string>        | Permission        | string        | {              read?: Array<Permission | string> | Permission | string;              write?: Array<Permission | string> | Permission | string;          };    validate?: (        value: any,        injector: Injector,        ctx: RequestContext,    ) => string | LocalizedString[] | void | Promise<string | LocalizedString[] | void>;}
```

Example 2 (ts):
```ts
// Single permission for both read and writerequiresPermission: Permission.UpdateSettings// Separate read and write permissionsrequiresPermission: {  read: Permission.ReadSettings,  write: Permission.UpdateSettings}// Using custom RwPermissionDefinitionrequiresPermission: {  read: dashboardSavedViews.Read,  write: dashboardSavedViews.Write}
```

---

## DefaultJobQueuePlugin

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/default-job-queue-plugin

**Contents:**
- DefaultJobQueuePlugin
- DefaultJobQueuePlugin‚Äã
- Configuration‚Äã
  - pollInterval‚Äã
  - concurrency‚Äã
  - backoffStrategy‚Äã
  - Removing old jobs‚Äã
  - init‚Äã
- cleanJobsTask‚Äã
- DefaultJobQueueOptions‚Äã

A plugin which configures Vendure to use the SQL database to persist the JobQueue jobs using the SqlJobQueueStrategy. If you add this plugin to an existing Vendure installation, you'll need to run a database migration, since this plugin will add a new "job_record" table to the database.

It is possible to configure the behaviour of the SqlJobQueueStrategy by passing options to the static init() function:

The interval in ms between polling for new jobs. The default is 200ms. Using a longer interval reduces load on the database but results in a slight delay in processing jobs. For more control, it is possible to supply a function which can specify a pollInterval based on the queue name:

The number of jobs to process concurrently per worker. Defaults to 1.

Defines the backoff strategy used when retrying failed jobs. In other words, if a job fails and is configured to be re-tried, how long should we wait before the next attempt?

By default, a job will be retried as soon as possible, but in some cases this is not desirable. For example, a job may interact with an unreliable 3rd-party API which is sensitive to too many requests. In this case, an exponential backoff may be used which progressively increases the delay between each subsequent retry.

Since v3.3, the job queue will automatically remove old jobs from the database. This is done by a scheduled task which runs every 2 hours by default. The number of jobs to keep in the database can be configured using the keepJobsCount option. The default is 1000.

A ScheduledTask that cleans up old jobs from the database when using the DefaultJobQueuePlugin. You can configure the settings & schedule of the task via the DefaultJobQueuePlugin options.

Configuration options for the DefaultJobQueuePlugin. These values get passed into the SqlJobQueueStrategy.

The interval in ms between polling the database for new jobs. If many job queues are active, the polling may cause undue load on the database, in which case this value should be increased to e.g. 1000.

How many jobs from a given queue to process concurrently.

The strategy used to decide how long to wait before retrying a failed job.

When a job is added to the JobQueue using JobQueue.add(), the calling code may specify the number of retries in case of failure. This option allows you to override that number and specify your own number of retries based on the job being added.

If set to true, the database will be used to store buffered jobs. This is recommended f

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { DefaultJobQueuePlugin, VendureConfig } from '@vendure/core';export const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    DefaultJobQueuePlugin,  ],};
```

Example 2 (ts):
```ts
export const config: VendureConfig = {  plugins: [    DefaultJobQueuePlugin.init({      pollInterval: queueName => {        if (queueName === 'cart-recovery-email') {          // This queue does not need to be polled so frequently,          // so we set a longer interval in order to reduce load          // on the database.          return 10000;        }        return 200;      },    }),  ],};
```

Example 3 (ts):
```ts
export const config: VendureConfig = {  plugins: [    DefaultJobQueuePlugin.init({      pollInterval: 5000,      concurrency: 2      backoffStrategy: (queueName, attemptsMade, job) => {        if (queueName === 'transcode-video') {          // exponential backoff example          return (attemptsMade ** 2) * 1000;        }        // A default delay for all other queues        return 1000;      },      setRetries: (queueName, job) => {        if (queueName === 'send-email') {          // Override the default number of retries          // for the 'send-email' job because we have          // a ve
...
```

Example 4 (ts):
```ts
export const config: VendureConfig = {  plugins: [    DefaultJobQueuePlugin.init({      // The number of completed/failed/cancelled      // jobs to keep in the database. The default is 1000.      keepJobsCount: 100,      // The interval at which to run the clean-up task.      // This can be a standard cron expression or a function      // that returns a cron expression. The default is every 2 hours.      cleanJobsSchedule: cron => cron.every(5).hours(),    }),  ],};
```

---

## ProductVariant

**URL:** https://docs.vendure.io/reference/typescript-api/entities/product-variant

**Contents:**
- ProductVariant
- ProductVariant‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - name‚Äã
  - enabled‚Äã
  - sku‚Äã
  - listPrice‚Äã
  - listPriceIncludesTax‚Äã
  - currencyCode‚Äã

A ProductVariant represents a single stock keeping unit (SKU) in the store's inventory. Whereas a Product is a "container" of variants, the variant itself holds the data on price, tax category etc. When one adds items to their cart, they are adding ProductVariants, not Products.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, SoftDeletable, ChannelAware

Specifies the value of stockOnHand at which the ProductVariant is considered out of stock.

When true, the outOfStockThreshold value will be taken from the GlobalSettings and the value set on this ProductVariant will be ignored.

**Examples:**

Example 1 (ts):
```ts
class ProductVariant extends VendureEntity implements Translatable, HasCustomFields, SoftDeletable, ChannelAware {    constructor(input?: DeepPartial<ProductVariant>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    name: LocaleString;    @Column({ default: true })    enabled: boolean;    @Column()    sku: string;    listPrice: number;    listPriceIncludesTax: boolean;    currencyCode: CurrencyCode;    price: number    priceWithTax: number    taxRateApplied: TaxRate;    @Index()    @ManyToOne(type => Asset, asset => asset.featuredInVariants, { onDelete: 'SET NULL' })   
...
```

---

## MigrationOptions

**URL:** https://docs.vendure.io/reference/typescript-api/migration/migration-options

**Contents:**
- MigrationOptions
- MigrationOptions‚Äã
  - name‚Äã
  - outputDir‚Äã

Configuration for generating a new migration script via generateMigration.

The name of the migration. The resulting migration script will be named {TIMESTAMP}-{name}.ts.

The output directory of the generated migration scripts.

**Examples:**

Example 1 (ts):
```ts
interface MigrationOptions {    name: string;    outputDir?: string;}
```

---

## DefineDashboardExtension

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/define-dashboard-extension

**Contents:**
- DefineDashboardExtension
- defineDashboardExtension‚Äã
  - extension‚Äã
- DashboardExtension‚Äã
  - routes‚Äã
  - navSections‚Äã
  - pageBlocks‚Äã
  - actionBarItems‚Äã
  - alerts‚Äã
  - widgets‚Äã

The main entry point for extensions to the React-based dashboard. Every dashboard extension must contain a call to this function, usually in the entry point file that is referenced by the dashboard property of the plugin decorator.

Every type of customisation of the dashboard can be defined here, including:

This is the main interface for defining all extensions to the dashboard.

Every type of customisation of the dashboard can be defined here, including:

Allows you to define custom routes such as list or detail views.

Allows you to define custom nav sections for the dashboard.

Allows you to define custom page blocks for any page in the dashboard.

Allows you to define custom action bar items for any page in the dashboard.

Allows you to define custom alerts that can be displayed in the dashboard.

Allows you to define custom routes for the dashboard, which will render the given components and optionally also add a nav menu item.

Unified registration for custom form custom field components.

Allows you to customize aspects of existing data tables in the dashboard.

Allows you to customize the detail form for any page in the dashboard.

Allows you to customize the login page with custom components.

Allows a custom component to be used to render a history entry item in the Order or Customer history lists.

**Examples:**

Example 1 (tsx):
```tsx
defineDashboardExtension({ navSections: [], routes: [], pageBlocks: [], actionBarItems: [],});
```

Example 2 (ts):
```ts
function defineDashboardExtension(extension: DashboardExtension): void
```

Example 3 (ts):
```ts
interface DashboardExtension {    routes?: DashboardRouteDefinition[];    navSections?: DashboardNavSectionDefinition[];    pageBlocks?: DashboardPageBlockDefinition[];    actionBarItems?: DashboardActionBarItem[];    alerts?: DashboardAlertDefinition[];    widgets?: DashboardWidgetDefinition[];    customFormComponents?: DashboardCustomFormComponents;    dataTables?: DashboardDataTableExtensionDefinition[];    detailForms?: DashboardDetailFormExtensionDefinition[];    login?: DashboardLoginExtensions;    historyEntries?: DashboardHistoryEntryComponent[];}
```

---

## AuthenticationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/auth/authentication-strategy

**Contents:**
- AuthenticationStrategy
- AuthenticationStrategy‚Äã
  - name‚Äã
  - defineInputType‚Äã
  - authenticate‚Äã
  - onLogOut‚Äã

An AuthenticationStrategy defines how a User (which can be a Customer in the Shop API or and Administrator in the Admin API) may be authenticated.

Real-world examples can be found in the Authentication guide.

This is configured via the authOptions.shopAuthenticationStrategy and authOptions.adminAuthenticationStrategy properties of your VendureConfig.

The name of the strategy, for example 'facebook', 'google', 'keycloak'.

Defines the type of the GraphQL Input object expected by the authenticate mutation. The final input object will be a map, with the key being the name of the strategy. The shape of the input object should match the generic Data type argument.

For example, given the following:

assuming the strategy name is "my_auth", then the resulting call to authenticate would look like:

Note: if more than one graphql input type is being defined (as in a nested input type), then the first input will be assumed to be the top-level input.

Used to authenticate a user with the authentication provider. This method will implement the provider-specific authentication logic, and should resolve to either a User object on success, or false | string on failure. A string return could be used to describe what error happened, otherwise false to an unknown error.

Called when a user logs out, and may perform any required tasks related to the user logging out with the external provider.

**Examples:**

Example 1 (ts):
```ts
interface AuthenticationStrategy<Data = unknown> extends InjectableStrategy {    readonly name: string;    defineInputType(): DocumentNode;    authenticate(ctx: RequestContext, data: Data): Promise<User | false | string>;    onLogOut?(ctx: RequestContext, user: User): Promise<void>;}
```

Example 2 (ts):
```ts
defineInputType() {  return gql`     input MyAuthInput {       token: String!     }  `;}
```

Example 3 (graphql):
```graphql
authenticate(input: {  my_auth: {    token: "foo"  }}) {  # ...}
```

---

## PaymentState

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-state

**Contents:**
- PaymentState
- PaymentState‚Äã

These are the default states of the payment process.

**Examples:**

Example 1 (ts):
```ts
type PaymentState = | 'Created'    | 'Error'    | 'Cancelled'    | keyof CustomPaymentStates    | keyof PaymentStates
```

---

## ShippingMethod

**URL:** https://docs.vendure.io/reference/typescript-api/entities/shipping-method

**Contents:**
- ShippingMethod
- ShippingMethod‚Äã
  - constructor‚Äã
  - deletedAt‚Äã
  - code‚Äã
  - name‚Äã
  - description‚Äã
  - checker‚Äã
  - calculator‚Äã
  - fulfillmentHandlerCode‚Äã

A ShippingMethod is used to apply a shipping price to an Order. It is composed of a ShippingEligibilityChecker and a ShippingCalculator. For a given Order, the checker is used to determine whether this ShippingMethod can be used. If yes, then the ShippingMethod can be applied and the calculator is used to determine the price of shipping.

Extends: VendureEntity

Implements: ChannelAware, SoftDeletable, HasCustomFields, Translatable

**Examples:**

Example 1 (ts):
```ts
class ShippingMethod extends VendureEntity implements ChannelAware, SoftDeletable, HasCustomFields, Translatable {    constructor(input?: DeepPartial<ShippingMethod>)    @Column({ type: Date, nullable: true })    deletedAt: Date | null;    @Column() code: string;    name: LocaleString;    description: LocaleString;    @Column('simple-json') checker: ConfigurableOperation;    @Column('simple-json') calculator: ConfigurableOperation;    @Column()    fulfillmentHandlerCode: string;    @ManyToMany(type => Channel, channel => channel.shippingMethods)    @JoinTable()    channels: Channel[];    @OneT
...
```

---

## DefaultFormConfigHash

**URL:** https://docs.vendure.io/reference/typescript-api/configurable-operation-def/default-form-config-hash/

**Contents:**
- DefaultFormConfigHash
- DefaultFormConfigHash‚Äã
  - 'boolean-form-input'‚Äã
  - 'currency-form-input'‚Äã
  - 'customer-group-form-input'‚Äã
  - 'date-form-input'‚Äã
  - 'facet-value-form-input'‚Äã
  - 'json-editor-form-input'‚Äã
  - 'html-editor-form-input'‚Äã
  - 'number-form-input'‚Äã

Used to define the expected arguments for a given default form input component.

**Examples:**

Example 1 (ts):
```ts
type DefaultFormConfigHash = {    'boolean-form-input': Record<string, never>;    'currency-form-input': Record<string, never>;    'customer-group-form-input': Record<string, never>;    'date-form-input': { min?: string; max?: string; yearRange?: number };    'facet-value-form-input': Record<string, never>;    'json-editor-form-input': { height?: string };    'html-editor-form-input': { height?: string };    'number-form-input': { min?: number; max?: number; step?: number; prefix?: string; suffix?: string };    'password-form-input': Record<string, never>;    'product-selector-form-input': Rec
...
```

---

## EventBus

**URL:** https://docs.vendure.io/reference/typescript-api/events/event-bus

**Contents:**
- EventBus
- EventBus‚Äã
  - constructor‚Äã
  - publish‚Äã
  - ofType‚Äã
  - filter‚Äã
  - registerBlockingEventHandler‚Äã

The EventBus is used to globally publish events which can then be subscribed to.

Events are published whenever certain actions take place within the Vendure server, for example:

Using the EventBus it is possible to subscribe to an take action when these events occur. This is done with the .ofType() method, which takes an event type and returns an rxjs observable stream of events:

Publish an event which any subscribers can react to.

Returns an RxJS Observable stream of events of the given type. If the event contains a RequestContext object, the subscriber will only get called after any active database transactions are complete.

This means that the subscriber function can safely access all updated data related to the event.

Returns an RxJS Observable stream of events filtered by a custom predicate. If the event contains a RequestContext object, the subscriber will only get called after any active database transactions are complete.

This means that the subscriber function can safely access all updated data related to the event.

Register an event handler function which will be executed when an event of the given type is published, and will block execution of the code which published the event until the handler has completed.

This is useful when you need assurance that the event handler has successfully completed, and you want the triggering code to fail if the handler fails.

::: warning This API should be used with caution, as errors or performance issues in the handler can cause the associated operation to be slow or fail entirely. For this reason, any handler which takes longer than 100ms to execute will log a warning. Any non-trivial task to be performed in a blocking event handler should be offloaded to a background job using the JobQueueService.

Also, be aware that the handler will be executed in the same database transaction as the code which published the event (as long as you pass the ctx object from the event to any TransactionalConnection calls). :::

**Examples:**

Example 1 (ts):
```ts
import { OnApplicationBootstrap } from '@nestjs/common';import { EventBus, PluginCommonModule, VendurePlugin } from '@vendure/core';import { filter } from 'rxjs/operators';@VendurePlugin({    imports: [PluginCommonModule]})export class MyPlugin implements OnApplicationBootstrap {  constructor(private eventBus: EventBus) {}  async onApplicationBootstrap() {    this.eventBus      .ofType(OrderStateTransitionEvent)      .pipe(        filter(event => event.toState === 'PaymentSettled'),      )      .subscribe((event) => {        // do some action when this event fires      });  }}
```

Example 2 (ts):
```ts
class EventBus implements OnModuleDestroy {    constructor(transactionSubscriber: TransactionSubscriber)    publish(event: T) => Promise<void>;    ofType(type: Type<T>) => Observable<T>;    filter(predicate: (event: VendureEvent) => boolean) => Observable<T>;    registerBlockingEventHandler(handlerOptions: BlockingEventHandlerOptions<T>) => ;}
```

Example 3 (ts):
```ts
await eventBus.publish(new SomeEvent());
```

Example 4 (ts):
```ts
eventBus.registerBlockingEventHandler({  event: OrderStateTransitionEvent,  id: 'my-order-state-transition-handler',  handler: async (event) => {    // perform some synchronous task  }});
```

---

## CustomerGroup

**URL:** https://docs.vendure.io/reference/typescript-api/entities/customer-group

**Contents:**
- CustomerGroup
- CustomerGroup‚Äã
  - constructor‚Äã
  - name‚Äã
  - customers‚Äã
  - customFields‚Äã
  - taxRates‚Äã

A grouping of Customers which enables features such as group-based promotions or tax rules.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class CustomerGroup extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<CustomerGroup>)    @Column() name: string;    @ManyToMany(type => Customer, customer => customer.groups)    customers: Customer[];    @Column(type => CustomCustomerGroupFields)    customFields: CustomCustomerGroupFields;    @OneToMany(type => TaxRate, taxRate => taxRate.zone)    taxRates: TaxRate[];}
```

---

## S3AssetStorageStrategy

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/s3asset-storage-strategy

**Contents:**
- S3AssetStorageStrategy
- S3AssetStorageStrategy‚Äã
- Use with S3-compatible services (MinIO)‚Äã
  - constructor‚Äã
  - init‚Äã
  - destroy‚Äã
  - writeFileFromBuffer‚Äã
  - writeFileFromStream‚Äã
  - readFileToBuffer‚Äã
  - readFileToStream‚Äã

An AssetStorageStrategy which uses Amazon S3 object storage service. To us this strategy you must first have access to an AWS account. See their getting started guide for how to get set up.

Before using this strategy, make sure you have the @aws-sdk/client-s3 and @aws-sdk/lib-storage package installed:

Note: Rather than instantiating this manually, use the configureS3AssetStorage function.

This strategy will also work with any S3-compatible object storage solutions, such as MinIO. See the configureS3AssetStorage for an example with MinIO.

Configuration for connecting to AWS S3.

The credentials used to access your s3 account. You can supply either the access key ID & secret, or you can make use of a shared credentials file To use a shared credentials file, import the fromIni() function from the "@aws-sdk/credential-provider-ini" or "@aws-sdk/credential-providers" package and supply the profile name (e.g. { profile: 'default' }) as its argument.

The S3 bucket in which to store the assets. If it does not exist, it will be created on startup.

Configuration object passed directly to the AWS SDK. S3.Types.ClientConfiguration can be used after importing aws-sdk. Using type any in order to avoid the need to include aws-sdk dependency in general.

Configuration object passed directly to the AWS SDK. ManagedUpload.ManagedUploadOptions can be used after importing aws-sdk. Using type any in order to avoid the need to include aws-sdk dependency in general.

Returns a configured instance of the S3AssetStorageStrategy which can then be passed to the AssetServerOptionsstorageStrategyFactory property.

Before using this strategy, make sure you have the @aws-sdk/client-s3 and @aws-sdk/lib-storage package installed:

Reference: How to use AWS SDK for Javascript with MinIO Server

**Examples:**

Example 1 (sh):
```sh
npm install @aws-sdk/client-s3 @aws-sdk/lib-storage
```

Example 2 (ts):
```ts
class S3AssetStorageStrategy implements AssetStorageStrategy {    constructor(s3Config: S3Config, toAbsoluteUrl: (request: Request, identifier: string) => string)    init() => ;    destroy?: (() => void | Promise<void>) | undefined;    writeFileFromBuffer(fileName: string, data: Buffer) => ;    writeFileFromStream(fileName: string, data: Readable) => ;    readFileToBuffer(identifier: string) => ;    readFileToStream(identifier: string) => ;    deleteFile(identifier: string) => ;    fileExists(fileName: string) => ;}
```

Example 3 (ts):
```ts
interface S3Config {    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;    bucket: string;    nativeS3Configuration?: any;    nativeS3UploadConfiguration?: any;}
```

Example 4 (sh):
```sh
npm install @aws-sdk/client-s3 @aws-sdk/lib-storage
```

---

## PurgeRule

**URL:** https://docs.vendure.io/reference/core-plugins/stellate-plugin/purge-rule

**Contents:**
- PurgeRule
- PurgeRule‚Äã
  - eventType‚Äã
  - bufferTimeMs‚Äã
  - handle‚Äã
  - constructor‚Äã
- PurgeRuleConfig‚Äã
  - eventType‚Äã
  - bufferTime‚Äã
  - handler‚Äã

Defines a rule that listens for a particular VendureEvent and uses that to make calls to the Stellate Purging API via the provided StellateService instance.

Configures a PurgeRule.

Specifies which VendureEvent will trigger this purge rule.

How long to buffer events for in milliseconds before executing the handler. This allows us to efficiently batch calls to the Stellate Purge API.

The function to invoke when the specified event is published. This function should use the StellateService instance to call the Stellate Purge API.

**Examples:**

Example 1 (ts):
```ts
class PurgeRule<Event extends VendureEvent = VendureEvent> {    eventType: Type<Event>    bufferTimeMs: number | undefined    handle(handlerArgs: { events: Event[]; stellateService: StellateService; injector: Injector }) => ;    constructor(config: PurgeRuleConfig<Event>)}
```

Example 2 (ts):
```ts
interface PurgeRuleConfig<Event extends VendureEvent> {    eventType: Type<Event>;    bufferTime?: number;    handler: (handlerArgs: {        events: Event[];        stellateService: StellateService;        injector: Injector;    }) => void | Promise<void>;}
```

---

## CleanupOrphanedSettingsStoreEntriesResult

**URL:** https://docs.vendure.io/reference/typescript-api/settings-store/cleanup-orphaned-settings-store-entries-result

**Contents:**
- CleanupOrphanedSettingsStoreEntriesResult
- CleanupOrphanedSettingsStoreEntriesResult‚Äã
  - deletedCount‚Äã
  - dryRun‚Äã
  - deletedEntries‚Äã

Result of a cleanup operation for orphaned settings store entries.

Number of entries that were (or would be) deleted.

Whether this was a dry run.

Sample of deleted entries (for logging/audit purposes).

**Examples:**

Example 1 (ts):
```ts
interface CleanupOrphanedSettingsStoreEntriesResult {    deletedCount: number;    dryRun: boolean;    deletedEntries: OrphanedSettingsStoreEntry[];}
```

---

## OrderOptions

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-options

**Contents:**
- OrderOptions
- OrderOptions‚Äã
  - orderItemsLimit‚Äã
  - orderLineItemsLimit‚Äã
  - orderItemPriceCalculationStrategy‚Äã
  - process‚Äã
  - stockAllocationStrategy‚Äã
  - mergeStrategy‚Äã
  - checkoutMergeStrategy‚Äã
  - orderCodeStrategy‚Äã

The maximum number of individual items allowed in a single order. This option exists to prevent excessive resource usage when dealing with very large orders. For example, if an order contains a million items, then any operations on that order (modifying a quantity, adding or removing an item) will require Vendure to loop through all million items to perform price calculations against active promotions and taxes. This can have a significant performance impact for very large values.

Attempting to exceed this limit will cause Vendure to throw a OrderLimitError.

The maximum number of items allowed per order line. This option is an addition on the orderItemsLimit for more granular control. Note orderItemsLimit is still important in order to prevent excessive resource usage.

Attempting to exceed this limit will cause Vendure to throw a OrderLimitError`.

Defines the logic used to calculate the unit price of an OrderLine when adding an item to an Order.

Allows the definition of custom states and transition logic for the order process state machine. Takes an array of objects implementing the OrderProcess interface.

Determines the point of the order process at which stock gets allocated.

Defines the strategy used to merge a guest Order and an existing Order when signing in.

Defines the strategy used to merge a guest Order and an existing Order when signing in as part of the checkout flow.

Allows a user-defined function to create Order codes. This can be useful when integrating with existing systems. By default, Vendure will generate a 16-character alphanumeric string.

Note: when using a custom function for Order codes, bear in mind the database limit for string types (e.g. 255 chars for a varchar field in MySQL), and also the need for codes to be unique.

Defines the strategy used to check if and how an Order may be retrieved via the orderByCode query.

The default strategy permits permanent access to the Customer owning the Order and anyone within 2 hours after placing the Order.

Defines how we handle the situation where an item exists in an Order, and then later on another is added but in the meantime the price of the ProductVariant has changed.

By default, the latest price will be used. Any price changes resulting from using a newer price will be reflected in the GraphQL OrderLine.unitPrice[WithTax]ChangeSinceAdded field.

Defines the point of the order process at which the Order is set as "placed".

Defines the strategy used to determine the active Order when performing Shop API operations such as `activeOrder` and `addItemToOrder`. The strategy uses the active Session as its foundation mechanism.

Since v1.9.0, you can define multiple strategies which will be checked in order, using the first one that returns an Order.

**Examples:**

Example 1 (ts):
```ts
interface OrderOptions {    orderItemsLimit?: number;    orderLineItemsLimit?: number;    orderItemPriceCalculationStrategy?: OrderItemPriceCalculationStrategy;    process?: Array<OrderProcess<any>>;    stockAllocationStrategy?: StockAllocationStrategy;    mergeStrategy?: OrderMergeStrategy;    checkoutMergeStrategy?: OrderMergeStrategy;    orderCodeStrategy?: OrderCodeStrategy;    orderByCodeAccessStrategy?: OrderByCodeAccessStrategy;    changedPriceHandlingStrategy?: ChangedPriceHandlingStrategy;    orderPlacedStrategy?: OrderPlacedStrategy;    activeOrderStrategy?: ActiveOrderStrategy<any> 
...
```

---

## ShouldRunCheckFn

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/should-run-check-fn

**Contents:**
- ShouldRunCheckFn
- ShouldRunCheckFn‚Äã

An optional method which is used to decide whether to run the check() function. Returns a JSON-compatible object which is cached and compared between calls. If the value is the same, then the check() function is not called.

Use of this function is an optimization technique which can be useful when the check() function is expensive and should be kept to an absolute minimum.

**Examples:**

Example 1 (ts):
```ts
const optimizedChecker = new ShippingEligibilityChecker({  code: 'example',  description: [],  args: {},  check: async (ctx, order) => {    // some slow, expensive function here  },  shouldRunCheck: (ctx, order) => {    // Will only run the `check()` function any time    // the shippingAddress object has changed.    return order.shippingAddress;  },});
```

Example 2 (ts):
```ts
type ShouldRunCheckFn<T extends ConfigArgs> = (    ctx: RequestContext,    order: Order,    args: ConfigArgValues<T>,    method: ShippingMethod,) => Json | Promise<Json>
```

---

## BootstrapWorker

**URL:** https://docs.vendure.io/reference/typescript-api/worker/bootstrap-worker/

**Contents:**
- BootstrapWorker
- bootstrapWorker‚Äã
  - userConfig‚Äã
  - options‚Äã
- BootstrapWorkerOptions‚Äã
  - nestApplicationContextOptions‚Äã
  - ignoreCompatibilityErrorsForPlugins‚Äã

Bootstraps a Vendure worker. Resolves to a VendureWorker object containing a reference to the underlying NestJs standalone application as well as convenience methods for starting the job queue and health check server.

Read more about the Vendure Worker.

Additional options that can be used to configure the bootstrap process of the Vendure worker.

These options get passed directly to the NestFactory.createApplicationContext method.

See the ignoreCompatibilityErrorsForPlugins option in BootstrapOptions.

**Examples:**

Example 1 (ts):
```ts
import { bootstrapWorker } from '@vendure/core';import { config } from './vendure-config';bootstrapWorker(config)  .then(worker => worker.startJobQueue())  .then(worker => worker.startHealthCheckServer({ port: 3020 }))  .catch(err => {    console.log(err);    process.exit(1);  });
```

Example 2 (ts):
```ts
function bootstrapWorker(userConfig: Partial<VendureConfig>, options?: BootstrapWorkerOptions): Promise<VendureWorker>
```

Example 3 (ts):
```ts
interface BootstrapWorkerOptions {    nestApplicationContextOptions?: NestApplicationContextOptions;    ignoreCompatibilityErrorsForPlugins?: Array<DynamicModule | Type<any>>;}
```

---

## RuntimeVendureConfig

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/runtime-vendure-config

**Contents:**
- RuntimeVendureConfig
- RuntimeVendureConfig‚Äã
  - apiOptions‚Äã
  - assetOptions‚Äã
  - authOptions‚Äã
  - catalogOptions‚Äã
  - customFields‚Äã
  - entityOptions‚Äã
  - importExportOptions‚Äã
  - jobQueueOptions‚Äã

This interface represents the VendureConfig object available at run-time, i.e. the user-supplied config values have been merged with the defaultConfig values.

**Examples:**

Example 1 (ts):
```ts
interface RuntimeVendureConfig extends Required<VendureConfig> {    apiOptions: Required<ApiOptions>;    assetOptions: Required<AssetOptions>;    authOptions: Required<AuthOptions>;    catalogOptions: Required<CatalogOptions>;    customFields: Required<CustomFields>;    entityOptions: Required<Omit<EntityOptions, 'entityIdStrategy'>> & EntityOptions;    importExportOptions: Required<ImportExportOptions>;    jobQueueOptions: Required<JobQueueOptions>;    schedulerOptions: Required<SchedulerOptions>;    orderOptions: Required<OrderOptions>;    promotionOptions: Required<PromotionOptions>;    shi
...
```

---

## GlobalSettingsService

**URL:** https://docs.vendure.io/reference/typescript-api/services/global-settings-service

**Contents:**
- GlobalSettingsService
- GlobalSettingsService‚Äã
  - constructor‚Äã
  - getSettings‚Äã
  - updateSettings‚Äã

Contains methods relating to the GlobalSettings entity.

Returns the GlobalSettings entity.

**Examples:**

Example 1 (ts):
```ts
class GlobalSettingsService {    constructor(connection: TransactionalConnection, configService: ConfigService, customFieldRelationService: CustomFieldRelationService, eventBus: EventBus, requestCache: RequestContextCacheService)    getSettings(ctx: RequestContext) => Promise<GlobalSettings>;    updateSettings(ctx: RequestContext, input: UpdateGlobalSettingsInput) => Promise<GlobalSettings>;}
```

---

## EntityDuplicatorService

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/entity-duplicator-service

**Contents:**
- EntityDuplicatorService
- EntityDuplicatorService‚Äã
  - constructor‚Äã
  - getEntityDuplicators‚Äã
  - duplicateEntity‚Äã

This service is used to duplicate entities using one of the configured EntityDuplicator functions.

Returns all configured EntityDuplicator definitions.

Duplicates an entity using the specified EntityDuplicator. The duplication is performed within a transaction, so if an error occurs, the transaction will be rolled back.

**Examples:**

Example 1 (ts):
```ts
class EntityDuplicatorService {    constructor(configService: ConfigService, configArgService: ConfigArgService, connection: TransactionalConnection)    getEntityDuplicators(ctx: RequestContext) => EntityDuplicatorDefinition[];    duplicateEntity(ctx: RequestContext, input: DuplicateEntityInput) => Promise<DuplicateEntityResult>;}
```

---

## RegisterReactDataTableComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/react-extensions/register-react-data-table-component

**Contents:**
- RegisterReactDataTableComponent
- registerReactDataTableComponent‚Äã
  - config‚Äã

Registers a React component to be rendered in a data table in the given location. The component will receive the rowItem prop which is the data object for the row, e.g. the Product object if used in the product-list table.

**Examples:**

Example 1 (ts):
```ts
import { ReactDataTableComponentProps } from '@vendure/admin-ui/react';import React from 'react';export function SlugWithLink({ rowItem }: ReactDataTableComponentProps<{ slug: string }>) {    return (        <a href={`https://example.com/products/${rowItem.slug}`} target="_blank">            {rowItem.slug}        </a>    );}
```

Example 2 (ts):
```ts
import { registerReactDataTableComponent } from '@vendure/admin-ui/react';import { SlugWithLink } from './components/SlugWithLink';export default [    registerReactDataTableComponent({        component: SlugWithLink,        tableId: 'product-list',        columnId: 'slug',        props: {          foo: 'bar',        },    }),];
```

Example 3 (ts):
```ts
function registerReactDataTableComponent(config: ReactDataTableComponentConfig): void
```

---

## TelemetryPluginOptions

**URL:** https://docs.vendure.io/reference/core-plugins/telemetry-plugin/telemetry-plugin-options

**Contents:**
- TelemetryPluginOptions
- TelemetryPluginOptions‚Äã
  - loggerOptions‚Äã
  - methodHooks‚Äã

Configuration options for the TelemetryPlugin.

The options for the OtelLogger.

For example, to also include logging to the console, you can use the following:

Status: Developer Preview

This API may change in a future release.

Method hooks allow you to add extra telemetry actions to specific methods. To define hooks on a method, use the registerMethodHooks function.

**Examples:**

Example 1 (ts):
```ts
interface TelemetryPluginOptions {    loggerOptions?: OtelLoggerOptions;    methodHooks?: Array<MethodHookConfig<any>>;}
```

Example 2 (ts):
```ts
import { LogLevel } from '@vendure/core';import { TelemetryPlugin } from '@vendure/telemetry-plugin';TelemetryPlugin.init({    loggerOptions: {        console: LogLevel.Verbose,    },});
```

Example 3 (ts):
```ts
import { TelemetryPlugin, registerMethodHooks } from '@vendure/telemetry-plugin';TelemetryPlugin.init({  methodHooks: [    registerMethodHooks(ProductService, {      // Define some hooks for the `findOne` method      findOne: {        // This will be called before the method is executed        pre: ({ args: [ctx, productId], span }) => {          span.setAttribute('productId', productId);        },        // This will be called after the method is executed        post: ({ result, span }) => {          span.setAttribute('found', !!result);        },      },    }),  ],});
```

---

## ZoneSelectorComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/components/zone-selector-component

**Contents:**
- ZoneSelectorComponent
- ZoneSelectorComponent‚Äã
  - selectedValuesChange‚Äã
  - readonly‚Äã
  - transformControlValueAccessorValue‚Äã
  - selectedId$‚Äã
  - onChangeFn‚Äã
  - onTouchFn‚Äã
  - disabled‚Äã
  - value‚Äã

A form control for selecting zones.

**Examples:**

Example 1 (ts):
```ts
class ZoneSelectorComponent implements ControlValueAccessor {    @Output() selectedValuesChange = new EventEmitter<Zone>();    @Input() readonly = false;    @Input() transformControlValueAccessorValue: (value: Zone | undefined) => any = value => value?.id;    selectedId$ = new Subject<string>();    onChangeFn: (val: any) => void;    onTouchFn: () => void;    disabled = false;    value: string | Zone;    zones$ = this.dataService        .query(GetZoneSelectorListDocument, { options: { take: 999 } })        .mapSingle(result => result.zones.items);    constructor(dataService: DataService, change
...
```

---

## Event Types

**URL:** https://docs.vendure.io/reference/typescript-api/events/event-types

**Contents:**
- Event Types
- AccountRegistrationEvent‚Äã
  - constructor‚Äã
- AccountVerifiedEvent‚Äã
  - constructor‚Äã
- AdministratorEvent‚Äã
  - constructor‚Äã
- AssetChannelEvent‚Äã
  - constructor‚Äã
- AssetEvent‚Äã

This event is fired when a new user registers an account, either as a stand-alone signup or after placing an order.

This event is fired when a users email address successfully gets verified after the verifyCustomerAccount mutation was executed.

This event is fired whenever a Administrator is added, updated or deleted.

This event is fired whenever an Asset is assigned or removed From a channel.

This event is fired whenever a Asset is added, updated or deleted.

This event is fired when an attempt is made to log in via the shop or admin API login mutation. The strategy represents the name of the AuthenticationStrategy used in the login attempt. If the "native" strategy is used, the additional identifier property will be available.

This event is fired whenever an ChannelAware entity is assigned or removed from a channel. The entity property contains the value before updating the channels.

This event is fired whenever a Channel is added, updated or deleted.

This event is fired whenever a Collection is added, updated or deleted.

This event is fired whenever a Collection is modified in some way. The productVariantIds argument is an array of ids of all ProductVariants which:

This event is fired whenever a Country is added, updated or deleted.

This event is fired whenever an coupon code of an active Promotion is assigned or removed to an Order.

This event is fired whenever a Address is added, updated or deleted.

This event is fired whenever a Customer is added, updated or deleted.

This event is fired whenever one or more Customer is assigned to or removed from a CustomerGroup.

This event is fired whenever a CustomerGroup is added, updated or deleted.

This event is fired whenever a Facet is added, updated or deleted.

This event is fired whenever a FacetValue is added, updated or deleted.

This event is fired whenever a Fulfillment is added. The type is always created.

This event is fired whenever an Fulfillment transitions from one FulfillmentState to another.

This event is fired whenever a GlobalSettings is added. The type is always updated, because it's only created once and never deleted.

This event is fired whenever one HistoryEntry is added, updated or deleted.

This event is fired when a registered user successfully changes the identifier (ie email address) associated with their account.

This event is fired when a registered user requests to update the identifier (ie email address) associated with the account.

This event is fired when ven

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
class AccountRegistrationEvent extends VendureEvent {    constructor(ctx: RequestContext, user: User)}
```

Example 2 (ts):
```ts
class AccountVerifiedEvent extends VendureEvent {    constructor(ctx: RequestContext, customer: Customer)}
```

Example 3 (ts):
```ts
class AdministratorEvent extends VendureEntityEvent<Administrator, AdministratorInputTypes> {    constructor(ctx: RequestContext, entity: Administrator, type: 'created' | 'updated' | 'deleted', input?: AdministratorInputTypes)}
```

Example 4 (ts):
```ts
class AssetChannelEvent extends VendureEvent {    constructor(ctx: RequestContext, asset: Asset, channelId: ID, type: 'assigned' | 'removed')}
```

---

## List Views

**URL:** https://docs.vendure.io/reference/dashboard/list-views/

**Contents:**
- List Views
- üìÑÔ∏è Bulk Actions
- üìÑÔ∏è DataTableCellComponent
- üìÑÔ∏è DataTable
- üìÑÔ∏è ListPage
- üìÑÔ∏è PaginatedListDataTable

DataTableBulkActionItemProps

DataTableCellComponent

PaginatedListDataTable

---

## Instrument

**URL:** https://docs.vendure.io/reference/typescript-api/telemetry/instrument

**Contents:**
- Instrument
- Instrument‚Äã

This decorator is used to apply instrumentation to a class. It is intended to be used in conjunction with an InstrumentationStrategy which defines how the instrumentation should be applied.

In order for the instrumentation to be applied, the VENDURE_ENABLE_INSTRUMENTATION environment variable (exported from the @vendure/core package as ENABLE_INSTRUMENTATION_ENV_VAR) must be set to true. This is done to avoid the overhead of instrumentation in environments where it is not needed.

For more information on how instrumentation is used, see docs on the TelemetryPlugin.

**Examples:**

Example 1 (ts):
```ts
import { Instrument } from '@vendure/core';import { Injectable } from '@nestjs/common';@Injectable()@Instrument()export class MyService {  // Calls to this method will be instrumented  myMethod() {    // ...  }}
```

Example 2 (ts):
```ts
function Instrument(): ClassDecorator
```

---

## BullMQJobQueuePlugin

**URL:** https://docs.vendure.io/reference/core-plugins/job-queue-plugin/bull-mqjob-queue-plugin

**Contents:**
- BullMQJobQueuePlugin
- BullMQJobQueuePlugin‚Äã
- Advantages over the DefaultJobQueuePlugin‚Äã
- Installation‚Äã
  - Running Redis locally‚Äã
- Concurrency‚Äã
- Removing old jobs‚Äã
- Job Priority‚Äã
- Setting Redis Prefix‚Äã
  - options‚Äã

This plugin is a drop-in replacement of the DefaultJobQueuePlugin, which implements a push-based job queue strategy built on top of the popular BullMQ library.

The advantage of this approach is that jobs are stored in Redis rather than in the database. For more complex applications with many job queues and/or multiple worker instances, this can massively reduce the load on the DB server. The reason for this is that the DefaultJobQueuePlugin uses polling to check for new jobs. By default it will poll every 200ms. A typical Vendure instance uses at least 3 queues (handling emails, collections, search index), so even with a single worker instance this results in 15 queries per second to the DB constantly. Adding more custom queues and multiple worker instances can easily result in 50 or 100 queries per second. At this point performance may be impacted.

Using this plugin, no polling is needed, as BullMQ will push jobs to the worker(s) as and when they are added to the queue. This results in significantly more scalable performance characteristics, as well as lower latency in processing jobs.

Note: To use this plugin, you need to manually install the bullmq package:

Note: The v1.x version of this plugin is designed to work with bullmq v1.x, etc.

To develop with this plugin, you'll need an instance of Redis to connect to. Here's a docker-compose config that will set up Redis as well as Redis Commander, which is a web-based UI for interacting with Redis:

The default concurrency of a single worker is 3, i.e. up to 3 jobs will be processed at the same time. You can change the concurrency in the workerOptions passed to the init() method:

By default, BullMQ will keep completed jobs in the completed set and failed jobs in the failed set. Over time, these sets can grow very large. Since Vendure v2.1, the default behaviour is to remove jobs from these sets after 30 days or after a maximum of 5,000 completed or failed jobs.

This can be configured using the removeOnComplete and removeOnFail options:

The count option specifies the maximum number of jobs to keep in the set, while the age option specifies the maximum age of a job in seconds. If both options are specified, then the jobs kept will be the ones that satisfy both properties.

Some jobs are more important than others. For example, sending out a timely email after a customer places an order is probably more important than a routine data import task. Sometimes you can get the situation where lower-priority j

*[Content truncated]*

**Examples:**

Example 1 (shell):
```shell
npm install bullmq@^5.4.2
```

Example 2 (ts):
```ts
import { BullMQJobQueuePlugin } from '@vendure/job-queue-plugin/package/bullmq';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    // DefaultJobQueuePlugin should be removed from the plugins array    BullMQJobQueuePlugin.init({      connection: {        port: 6379      }    }),  ],};
```

Example 3 (yaml):
```yaml
version: "3"services:  redis:    image: redis:7.4    hostname: redis    container_name: redis    ports:      - "6379:6379"  redis-commander:    container_name: redis-commander    hostname: redis-commander    image: rediscommander/redis-commander:latest    environment:      - REDIS_HOSTS=local:redis:6379    ports:      - "8085:8081"
```

Example 4 (ts):
```ts
const config: VendureConfig = {  plugins: [    BullMQJobQueuePlugin.init({      workerOptions: {        concurrency: 10,      },    }),  ],};
```

---

## Plugin Utilities

**URL:** https://docs.vendure.io/reference/typescript-api/plugin/plugin-utilities

**Contents:**
- Plugin Utilities
- createProxyHandler‚Äã
  - options‚Äã
- ProxyOptions‚Äã
  - label‚Äã
  - route‚Äã
  - port‚Äã
  - hostname‚Äã
  - basePath‚Äã

Creates a proxy middleware which proxies the given route to the given port. Useful for plugins which start their own servers but should be accessible via the main Vendure url.

Options to configure proxy middleware via createProxyHandler.

A human-readable label for the service which is being proxied. Used to generate more informative logs.

The route of the Vendure server which will act as the proxy url.

The port on which the service being proxied is running.

The hostname of the server on which the service being proxied is running.

An optional base path on the proxied server.

**Examples:**

Example 1 (ts):
```ts
// Example usage in the `configuration` method of a VendurePlugin.// Imagine that we have started a Node server on port 5678// running some service which we want to access via the `/my-plugin/`// route of the main Vendure server.@VendurePlugin({  configuration: (config: Required<VendureConfig>) => {      config.apiOptions.middleware.push({          handler: createProxyHandler({              label: 'Admin UI',              route: 'my-plugin',              port: 5678,          }),          route: 'my-plugin',      });      return config;  }})export class MyPlugin {}
```

Example 2 (ts):
```ts
function createProxyHandler(options: ProxyOptions): RequestHandler
```

Example 3 (ts):
```ts
interface ProxyOptions {    label: string;    route: string;    port: number;    hostname?: string;    basePath?: string;}
```

---

## Types

**URL:** https://docs.vendure.io/reference/graphql-api/admin/object-types

**Contents:**
- Types
- AddFulfillmentToOrderResult‚Äã
- AddManualPaymentToOrderResult‚Äã
- Address‚Äã
- Adjustment‚Äã
- Administrator‚Äã
- AdministratorList‚Äã
- Allocation‚Äã
- AlreadyRefundedError‚Äã
- ApplyCouponCodeResult‚Äã

---

## AssetOptions

**URL:** https://docs.vendure.io/reference/typescript-api/assets/asset-options

**Contents:**
- AssetOptions
- AssetOptions‚Äã
  - assetNamingStrategy‚Äã
  - assetStorageStrategy‚Äã
  - assetPreviewStrategy‚Äã
  - permittedFileTypes‚Äã
  - uploadMaxFileSize‚Äã

The AssetOptions define how assets (images and other files) are named and stored, and how preview images are generated.

Note: If you are using the AssetServerPlugin, it is not necessary to configure these options.

Defines how asset files and preview images are named before being saved.

Defines the strategy used for storing uploaded binary files.

Defines the strategy used for creating preview images of uploaded assets.

An array of the permitted file types that may be uploaded as Assets. Each entry should be in the form of a valid unique file type specifier i.e. either a file extension (".pdf") or a mime type ("image/*", "audio/mpeg" etc.).

The max file size in bytes for uploaded assets.

**Examples:**

Example 1 (ts):
```ts
interface AssetOptions {    assetNamingStrategy?: AssetNamingStrategy;    assetStorageStrategy?: AssetStorageStrategy;    assetPreviewStrategy?: AssetPreviewStrategy;    permittedFileTypes?: string[];    uploadMaxFileSize?: number;}
```

---

## Zone

**URL:** https://docs.vendure.io/reference/typescript-api/entities/zone/

**Contents:**
- Zone
- Zone‚Äã
  - constructor‚Äã
  - name‚Äã
  - members‚Äã
  - customFields‚Äã
  - defaultShippingZoneChannels‚Äã
  - defaultTaxZoneChannels‚Äã
  - taxRates‚Äã

A Zone is a grouping of one or more Country entities. It is used for calculating applicable shipping and taxes.

Extends: VendureEntity

Implements: HasCustomFields

**Examples:**

Example 1 (ts):
```ts
class Zone extends VendureEntity implements HasCustomFields {    constructor(input?: DeepPartial<Zone>)    @Column() name: string;    @ManyToMany(type => Region)    @JoinTable()    members: Region[];    @Column(type => CustomZoneFields)    customFields: CustomZoneFields;    @OneToMany(type => Channel, country => country.defaultShippingZone)    defaultShippingZoneChannels: Channel[];    @OneToMany(type => Channel, country => country.defaultTaxZone)    defaultTaxZoneChannels: Channel[];    @OneToMany(type => TaxRate, taxRate => taxRate.zone)    taxRates: TaxRate[];}
```

---

## Bootstrap

**URL:** https://docs.vendure.io/reference/typescript-api/common/bootstrap

**Contents:**
- Bootstrap
- bootstrap‚Äã
  - Passing additional options‚Äã
  - Ignoring compatibility errors for plugins‚Äã
  - userConfig‚Äã
  - options‚Äã
- BootstrapOptions‚Äã
  - nestApplicationOptions‚Äã
  - ignoreCompatibilityErrorsForPlugins‚Äã

Bootstraps the Vendure server. This is the entry point to the application.

Since v2.2.0, you can pass additional options to the NestJs application via the options parameter. For example, to integrate with the Nest Devtools, you need to pass the snapshot option:

Since v3.1.0, you can ignore compatibility errors for specific plugins by passing the ignoreCompatibilityErrorsForPlugins option.

This should be used with caution, only if you are sure that the plugin will still work as expected with the current version of Vendure.

Additional options that can be used to configure the bootstrap process of the Vendure server.

These options get passed directly to the NestFactory.create() method.

By default, if a plugin specifies a compatibility range which does not include the current Vendure version, the bootstrap process will fail. This option allows you to ignore compatibility errors for specific plugins.

This setting should be used with caution, only if you are sure that the plugin will still work as expected with the current version of Vendure.

**Examples:**

Example 1 (ts):
```ts
import { bootstrap } from '@vendure/core';import { config } from './vendure-config';bootstrap(config).catch(err => {  console.log(err);  process.exit(1);});
```

Example 2 (ts):
```ts
import { bootstrap } from '@vendure/core';import { config } from './vendure-config';bootstrap(config, {  nestApplicationOptions: {    snapshot: true,  }}).catch(err => {  console.log(err);  process.exit(1);});
```

Example 3 (ts):
```ts
import { bootstrap } from '@vendure/core';import { config } from './vendure-config';import { MyPlugin } from './plugins/my-plugin';bootstrap(config, {  // Let's say that `MyPlugin` is not yet compatible with the current version of Vendure  // but we know that it will still work as expected, and we are not able to publish  // a new version of the plugin right now.  ignoreCompatibilityErrorsForPlugins: [MyPlugin],});
```

Example 4 (ts):
```ts
function bootstrap(userConfig: Partial<VendureConfig>, options?: BootstrapOptions): Promise<INestApplication>
```

---

## AnonymousSession

**URL:** https://docs.vendure.io/reference/typescript-api/entities/anonymous-session

**Contents:**
- AnonymousSession
- AnonymousSession‚Äã
  - constructor‚Äã

An anonymous session is created when a unauthenticated user interacts with restricted operations, such as calling the activeOrder query in the Shop API. Anonymous sessions allow a guest Customer to maintain an order without requiring authentication and a registered account beforehand.

**Examples:**

Example 1 (ts):
```ts
class AnonymousSession extends Session {    constructor(input: DeepPartial<AnonymousSession>)}
```

---

## Queries

**URL:** https://docs.vendure.io/reference/graphql-api/admin/queries

**Contents:**
- Queries
- activeAdministrator‚Äã
- activeChannel‚Äã
- administrator‚Äã
- administrators‚Äã
- asset‚Äã
- assets‚Äã
- channel‚Äã
- channels‚Äã
- collection‚Äã

---

## Payment Method Types

**URL:** https://docs.vendure.io/reference/typescript-api/payment/payment-method-types

**Contents:**
- Payment Method Types
- CreatePaymentResult‚Äã
  - amount‚Äã
  - state‚Äã
  - transactionId‚Äã
  - errorMessage‚Äã
  - metadata‚Äã
- CreatePaymentErrorResult‚Äã
  - amount‚Äã
  - state‚Äã

This object is the return value of the CreatePaymentFn.

The amount (as an integer - i.e. $10 = 1000) that this payment is for. Typically this should equal the Order total, unless multiple payment methods are being used for the order.

The PaymentState of the resulting Payment.

In a single-step payment flow, this should be set to 'Settled'. In a two-step flow, this should be set to 'Authorized'.

If using a PaymentProcess, may be something else entirely according to your business logic.

The unique payment reference code typically assigned by the payment provider.

If the payment is declined or fails for ome other reason, pass the relevant error message here, and it gets returned with the ErrorResponse of the addPaymentToOrder mutation.

This field can be used to store other relevant data which is often provided by the payment provider, such as security data related to the payment method or data used in troubleshooting or debugging.

Any data stored in the optional public property will be available via the Shop API. This is useful for certain checkout flows such as external gateways, where the payment provider returns a unique url which must then be passed to the storefront app.

This object is the return value of the CreatePaymentFn when there has been an error.

This object is the return value of the CreateRefundFn.

This object is the return value of the SettlePaymentFn when the Payment has been successfully settled.

This object is the return value of the SettlePaymentFn when the Payment could not be settled.

The state to transition this Payment to upon unsuccessful settlement. Defaults to Error. Note that if using a different state, it must be legal to transition to that state from the Authorized state according to the PaymentState config (which can be customized using the PaymentProcess).

The message that will be returned when attempting to settle the payment, and will also be persisted as Payment.errorMessage.

This object is the return value of the CancelPaymentFn when the Payment has been successfully cancelled.

This object is the return value of the CancelPaymentFn when the Payment could not be cancelled.

The state to transition this Payment to upon unsuccessful cancellation. Defaults to Error. Note that if using a different state, it must be legal to transition to that state from the Authorized state according to the PaymentState config (which can be customized using the PaymentProcess).

The message that will be returned when attempting to

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
interface CreatePaymentResult {    amount: number;    state: Exclude<PaymentState, 'Error'>;    transactionId?: string;    errorMessage?: string;    metadata?: PaymentMetadata;}
```

Example 2 (ts):
```ts
interface CreatePaymentErrorResult {    amount: number;    state: 'Error';    transactionId?: string;    errorMessage: string;    metadata?: PaymentMetadata;}
```

Example 3 (ts):
```ts
interface CreateRefundResult {    state: RefundState;    transactionId?: string;    metadata?: PaymentMetadata;}
```

Example 4 (ts):
```ts
interface SettlePaymentResult {    success: true;    metadata?: PaymentMetadata;}
```

---

## DefaultStockDisplayStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/products-stock/default-stock-display-strategy

**Contents:**
- DefaultStockDisplayStrategy
- DefaultStockDisplayStrategy‚Äã
  - constructor‚Äã
  - getStockLevel‚Äã

Displays the ProductVariant.stockLevel as either 'IN_STOCK', 'OUT_OF_STOCK' or 'LOW_STOCK'. Low stock is defined as a saleable stock level less than or equal to the lowStockLevel as passed in to the constructor (defaults to 2).

**Examples:**

Example 1 (ts):
```ts
class DefaultStockDisplayStrategy implements StockDisplayStrategy {    constructor(lowStockLevel: number = 2)    getStockLevel(ctx: RequestContext, productVariant: ProductVariant, saleableStockLevel: number) => string;}
```

---

## ListPage

**URL:** https://docs.vendure.io/reference/dashboard/list-views/list-page

**Contents:**
- ListPage
- ListPage‚Äã
  - props‚Äã
- ListPageProps‚Äã
  - pageId‚Äã
  - route‚Äã
  - title‚Äã
  - listQuery‚Äã
  - deleteMutation‚Äã
  - transformVariables‚Äã

Auto-generates a list page with columns generated based on the provided query document fields.

Props to configure the ListPage component.

A unique identifier for the list page. This is important to support customization functionality that relies on page IDs and makes your component extensible.

This DocumentNode of the list query, i.e. a query that fetches PaginatedList data with "items" and "totalItems", such as:

Providing the deleteMutation will automatically add a "delete" menu item to the actions column dropdown. Note that if this table already has a "delete" bulk action, you don't need to additionally provide a delete mutation, because the bulk action will be added to the action column dropdown already.

This prop can be used to intercept and transform the list query variables before they are sent to the Admin API.

This allows you to implement specific logic that differs from the standard filter/sort handling.

Allows you to customize how the search term is used in the list query options. For instance, when you want the term to filter on specific fields.

Allows you to define extra columns that are not related to actual fields returned in the query result.

For example, in the Administrator list, we define an additional "name" column composed of the firstName and lastName fields.

Allows you to specify the default order of columns in the table. When not defined, the order of fields in the list query document will be used.

Allows you to specify the default sorting applied to the table.

Allows you to specify the default columns that are visible in the table. If you set them to true, then only those will show by default. If you set them to false, then all other columns will be visible by default.

Allows you to define pre-set filters based on an array of possible selections

Allows you to specify additional "actions" that will be made available in the "actions" column. By default, the actions column includes all bulk actions defined in the bulkActions prop.

Allows the returned list query data to be transformed in some way. This is an advanced feature that is not often required.

Allows you to directly manipulate the Tanstack Table TableOptions object before the table is created. And advanced option that is not often required.

Bulk actions are actions that can be applied to one or more table rows, and include things like

See the BulkAction docs for an example of how to build the component.

Register a function that allows you to assign a refresh 

*[Content truncated]*

**Examples:**

Example 1 (tsx):
```tsx
import {    Button,    DashboardRouteDefinition,    ListPage,    PageActionBarRight,    DetailPageButton,} from '@vendure/dashboard';import { Link } from '@tanstack/react-router';import { PlusIcon } from 'lucide-react';// This function is generated for you by the `vendureDashboardPlugin` in your Vite config.// It uses gql-tada to generate TypeScript types which give you type safety as you write// your queries and mutations.import { graphql } from '@/gql';// The fields you select here will be automatically used to generate the appropriate columns in the// data table below.const getArticleList =
...
```

Example 2 (ts):
```ts
function ListPage<T extends TypedDocumentNode<U, V>, U extends Record<string, any> = any, V extends ListQueryOptionsShape = ListQueryOptionsShape, AC extends AdditionalColumns<T> = AdditionalColumns<T>>(props: Readonly<ListPageProps<T, U, V, AC>>): void
```

Example 3 (ts):
```ts
interface ListPageProps<T extends TypedDocumentNode<U, V>, U extends ListQueryShape, V extends ListQueryOptionsShape, AC extends AdditionalColumns<T>> {    pageId?: string;    route: AnyRoute | (() => AnyRoute);    title: string | React.ReactElement;    listQuery: T;    deleteMutation?: TypedDocumentNode<any, { id: string }>;    transformVariables?: (variables: V) => V;    onSearchTermChange?: (searchTerm: string) => NonNullable<V['options']>['filter'];    customizeColumns?: CustomizeColumnConfig<T>;    additionalColumns?: AC;    defaultColumnOrder?: (keyof ListQueryFields<T> | keyof AC | Cust
...
```

Example 4 (tsx):
```tsx
export const collectionListDocument = graphql(`  query CollectionList($options: CollectionListOptions) {    collections(options: $options) {      items {        id        createdAt        updatedAt        name        slug        breadcrumbs {          id          name          slug        }        children {          id          name        }        # ... etc      }      totalItems    }  }`);// ...<ListPage  pageId="collection-list"  listQuery={collectionListDocument}  // .../>
```

---

## OrderByCodeAccessStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-by-code-access-strategy/

**Contents:**
- OrderByCodeAccessStrategy
- OrderByCodeAccessStrategy‚Äã
  - canAccessOrder‚Äã
- DefaultOrderByCodeAccessStrategy‚Äã
  - constructor‚Äã
  - canAccessOrder‚Äã

The OrderByCodeAccessStrategy determines how access to a placed Order via the orderByCode query is granted. With a custom strategy anonymous access could be made permanent or tied to specific conditions like IP range or an Order status.

This example grants access to the requested Order to anyone ‚Äì unless it's Monday.

This is configured via the orderOptions.orderByCodeAccessStrategy property of your VendureConfig.

Gives or denies permission to access the requested Order

The default OrderByCodeAccessStrategy used by Vendure. It permitts permanent access to the Customer owning the Order and anyone within a given time period after placing the Order (defaults to 2h).

**Examples:**

Example 1 (ts):
```ts
export class NotMondayOrderByCodeAccessStrategy implements OrderByCodeAccessStrategy {    canAccessOrder(ctx: RequestContext, order: Order): boolean {        const MONDAY = 1;        const today = (new Date()).getDay();        return today !== MONDAY;    }}
```

Example 2 (ts):
```ts
interface OrderByCodeAccessStrategy extends InjectableStrategy {    canAccessOrder(ctx: RequestContext, order: Order): boolean | Promise<boolean>;}
```

Example 3 (ts):
```ts
class DefaultOrderByCodeAccessStrategy implements OrderByCodeAccessStrategy {    constructor(anonymousAccessDuration: string)    canAccessOrder(ctx: RequestContext, order: Order) => boolean;}
```

---

## JobBufferStorageStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/job-buffer-storage-strategy

**Contents:**
- JobBufferStorageStrategy
- JobBufferStorageStrategy‚Äã
  - add‚Äã
  - bufferSize‚Äã
  - flush‚Äã

This strategy defines where to store jobs that have been collected by a JobBuffer.

This is configured via the jobQueueOptions.jobBufferStorageStrategy property of your VendureConfig.

Persist a job to the storage medium. The storage format should take into account the bufferId argument, as it is necessary to be able to later retrieve jobs by that id.

Returns an object containing the number of buffered jobs arranged by bufferId.

Passing bufferIds limits the results to the specified bufferIds. If the array is empty, sizes will be returned for all bufferIds.

Clears all jobs from the storage medium which match the specified bufferIds (if the array is empty, clear for all bufferIds), and returns those jobs in an object arranged by bufferId

**Examples:**

Example 1 (ts):
```ts
interface JobBufferStorageStrategy extends InjectableStrategy {    add(bufferId: string, job: Job): Promise<Job>;    bufferSize(bufferIds?: string[]): Promise<{ [bufferId: string]: number }>;    flush(bufferIds?: string[]): Promise<{ [bufferId: string]: Job[] }>;}
```

Example 2 (ts):
```ts
const sizes = await myJobBufferStrategy.bufferSize(['buffer-1', 'buffer-2']);// sizes = { 'buffer-1': 12, 'buffer-2': 3 }
```

Example 3 (ts):
```ts
const result = await myJobBufferStrategy.flush(['buffer-1', 'buffer-2']);// result = {//   'buffer-1': [Job, Job, Job, ...],//   'buffer-2': [Job, Job, Job, ...],// };
```

---

## RegisterCustomDetailComponent

**URL:** https://docs.vendure.io/reference/admin-ui-api/custom-detail-components/register-custom-detail-component

**Contents:**
- RegisterCustomDetailComponent
- registerCustomDetailComponent‚Äã
  - config‚Äã

Registers a CustomDetailComponent to be placed in a given location. This allows you to embed any type of custom Angular component in the entity detail pages of the Admin UI.

**Examples:**

Example 1 (ts):
```ts
import { Component, OnInit } from '@angular/core';import { switchMap } from 'rxjs';import { FormGroup } from '@angular/forms';import { CustomFieldConfig } from '@vendure/common/lib/generated-types';import {    DataService,    SharedModule,    CustomDetailComponent,    registerCustomDetailComponent,    GetProductWithVariants} from '@vendure/admin-ui/core';@Component({    template: `{{ extraInfo$ | async | json }}`,    standalone: true,    imports: [SharedModule],})export class ProductInfoComponent implements CustomDetailComponent, OnInit {    // These two properties are provided by Vendure and 
...
```

Example 2 (ts):
```ts
function registerCustomDetailComponent(config: CustomDetailComponentConfig): void
```

---

## RevertLastMigration

**URL:** https://docs.vendure.io/reference/typescript-api/migration/revert-last-migration/

**Contents:**
- RevertLastMigration
- revertLastMigration‚Äã
  - userConfig‚Äã

Reverts the last applied database migration. See TypeORM migration docs for more information about the underlying migration mechanism.

**Examples:**

Example 1 (ts):
```ts
function revertLastMigration(userConfig: Partial<VendureConfig>): void
```

---

## StockAllocationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/stock-allocation-strategy/

**Contents:**
- StockAllocationStrategy
- StockAllocationStrategy‚Äã
  - shouldAllocateStock‚Äã

This strategy is responsible for deciding at which stage in the order process stock will be allocated.

This is configured via the orderOptions.stockAllocationStrategy property of your VendureConfig.

This method is called whenever an Order transitions from one state to another. If it resolves to true, then stock will be allocated for this order.

**Examples:**

Example 1 (ts):
```ts
interface StockAllocationStrategy extends InjectableStrategy {    shouldAllocateStock(        ctx: RequestContext,        fromState: OrderState,        toState: OrderState,        order: Order,    ): boolean | Promise<boolean>;}
```

---

## MoneyStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/money/money-strategy

**Contents:**
- MoneyStrategy
- MoneyStrategy‚Äã
- Range‚Äã
- Precision‚Äã
  - moneyColumnOptions‚Äã
  - precision‚Äã
  - round‚Äã

The MoneyStrategy defines how monetary values are stored and manipulated. The MoneyStrategy is defined in EntityOptions:

The DefaultMoneyStrategy uses an int field in the database, which puts an effective limit of ~21.4 million on any stored value. For certain use cases (e.g. business sales with very high amounts, or currencies with very large denominations), this may cause issues. In this case, you can use the BigIntMoneyStrategy which will use the bigint type to store monetary values, giving an effective upper limit of over 9 quadrillion.

Both the DefaultMoneyStrategy and BigIntMoneyStrategy store monetary values as integers, representing the price in the minor units of the currency (i.e. cents in USD or pennies in GBP).

Since v2.2.0, you can configure the precision of the stored values via the precision property of the strategy. Changing the precision has no effect on the stored value. It is merely a hint to the UI as to how many decimal places to display.

This is configured via the entityOptions.moneyStrategy property of your VendureConfig.

Defines the TypeORM column used to store monetary values.

Defines the precision (i.e. number of decimal places) represented by the monetary values. For example, consider a product variant with a price value of 12345.

Changing the precision has no effect on the stored value. It is merely a hint to the UI as to how many decimal places to display.

Defines the logic used to round monetary values. For instance, the default behavior in the DefaultMoneyStrategy is to round the value, then multiply.

However, it may be desirable to instead round only after the unit amount has been multiplied. In this case you can define a custom strategy with logic like this:

**Examples:**

Example 1 (ts):
```ts
const config: VendureConfig = {  entityOptions: {    moneyStrategy: new MyCustomMoneyStrategy(),  }};
```

Example 2 (ts):
```ts
import { DefaultMoneyStrategy, VendureConfig } from '@vendure/core';export class ThreeDecimalPlacesMoneyStrategy extends DefaultMoneyStrategy {  readonly precision = 3;}export const config: VendureConfig = {  // ...  entityOptions: {    moneyStrategy: new ThreeDecimalPlacesMoneyStrategy(),  }};
```

Example 3 (ts):
```ts
interface MoneyStrategy extends InjectableStrategy {    readonly moneyColumnOptions: ColumnOptions;    readonly precision?: number;    round(value: number, quantity?: number): number;}
```

Example 4 (ts):
```ts
return Math.round(value * quantity);
```

---

## Vite Plugin

**URL:** https://docs.vendure.io/reference/dashboard/vite-plugin/

**Contents:**
- Vite Plugin
- üìÑÔ∏è VendureDashboardPlugin

vendureDashboardPlugin

---

## Alerts

**URL:** https://docs.vendure.io/reference/admin-ui-api/alerts/

**Contents:**
- Alerts
- üìÑÔ∏è AlertConfig
- üìÑÔ∏è AlertContext
- üìÑÔ∏è RegisterAlert

---

## StockMovement

**URL:** https://docs.vendure.io/reference/typescript-api/entities/stock-movement/

**Contents:**
- StockMovement
- StockMovement‚Äã
  - type‚Äã
  - productVariant‚Äã
  - stockLocation‚Äã
  - stockLocationId‚Äã
  - quantity‚Äã
  - customFields‚Äã
- Allocation‚Äã
  - type‚Äã

A StockMovement is created whenever stock of a particular ProductVariant goes in or out.

Extends: VendureEntity

Implements: HasCustomFields

An Allocation is created for each ProductVariant in an Order when the checkout is completed (as configured by the StockAllocationStrategy. This prevents stock being sold twice.

A Cancellation is created when OrderItems from a fulfilled Order are cancelled.

A Release is created when OrderItems which have been allocated (but not yet fulfilled) are cancelled.

A Sale is created when OrderItems are fulfilled.

A StockAdjustment is created when the stockOnHand level of a ProductVariant is manually adjusted.

**Examples:**

Example 1 (ts):
```ts
class StockMovement extends VendureEntity implements HasCustomFields {    @Column({ nullable: false, type: 'varchar' })    readonly type: StockMovementType;    @Index()    @ManyToOne(type => ProductVariant, variant => variant.stockMovements)    productVariant: ProductVariant;    @Index()    @ManyToOne(type => StockLocation, stockLocation => stockLocation.stockMovements, { onDelete: 'CASCADE' })    stockLocation: StockLocation;    @EntityId()    stockLocationId: ID;    @Column()    quantity: number;    @Column(type => CustomStockMovementFields)    customFields: CustomStockMovementFields;}
```

Example 2 (ts):
```ts
class Allocation extends StockMovement {    readonly type = StockMovementType.ALLOCATION;    constructor(input: DeepPartial<Allocation>)    @Index()    @ManyToOne(type => OrderLine, orderLine => orderLine.allocations)    orderLine: OrderLine;}
```

Example 3 (ts):
```ts
class Cancellation extends StockMovement {    readonly type = StockMovementType.CANCELLATION;    constructor(input: DeepPartial<Cancellation>)    @ManyToOne(type => OrderLine, orderLine => orderLine.cancellations)    orderLine: OrderLine;}
```

Example 4 (ts):
```ts
class Release extends StockMovement {    readonly type = StockMovementType.RELEASE;    constructor(input: DeepPartial<Release>)    @ManyToOne(type => OrderLine)    orderLine: OrderLine;}
```

---

## FastImporterService

**URL:** https://docs.vendure.io/reference/typescript-api/import-export/fast-importer-service

**Contents:**
- FastImporterService
- FastImporterService‚Äã
  - initialize‚Äã
  - createProduct‚Äã
  - createProductOptionGroup‚Äã
  - createProductOption‚Äã
  - addOptionGroupToProduct‚Äã
  - createProductVariant‚Äã

A service to import entities into the database. This replaces the regular create methods of the service layer with faster versions which skip much of the defensive checks and other DB calls which are not needed when running an import. It also does not publish any events, so e.g. will not trigger search index jobs.

In testing, the use of the FastImporterService approximately doubled the speed of bulk imports.

This should be called prior to any of the import methods, as it establishes the default Channel as well as the context in which the new entities will be created.

Passing a channel argument means that Products and ProductVariants will be assigned to that Channel.

**Examples:**

Example 1 (ts):
```ts
class FastImporterService {    initialize(channel?: Channel) => ;    createProduct(input: CreateProductInput) => Promise<ID>;    createProductOptionGroup(input: CreateProductOptionGroupInput) => Promise<ID>;    createProductOption(input: CreateProductOptionInput) => Promise<ID>;    addOptionGroupToProduct(productId: ID, optionGroupId: ID) => ;    createProductVariant(input: CreateProductVariantInput) => Promise<ID>;}
```

---

## ShippingOptions

**URL:** https://docs.vendure.io/reference/typescript-api/shipping/shipping-options

**Contents:**
- ShippingOptions
- ShippingOptions‚Äã
  - shippingEligibilityCheckers‚Äã
  - shippingCalculators‚Äã
  - shippingLineAssignmentStrategy‚Äã
  - customFulfillmentProcess‚Äã
  - process‚Äã
  - fulfillmentHandlers‚Äã

An array of available ShippingEligibilityCheckers for use in configuring ShippingMethods

An array of available ShippingCalculators for use in configuring ShippingMethods

This strategy is used to assign a given ShippingLine to one or more OrderLines of the Order. This allows you to set multiple shipping methods for a single order, each assigned a different subset of OrderLines.

Allows the definition of custom states and transition logic for the fulfillment process state machine. Takes an array of objects implementing the FulfillmentProcess interface.

Allows the definition of custom states and transition logic for the fulfillment process state machine. Takes an array of objects implementing the FulfillmentProcess interface.

An array of available FulfillmentHandlers.

**Examples:**

Example 1 (ts):
```ts
interface ShippingOptions {    shippingEligibilityCheckers?: Array<ShippingEligibilityChecker<any>>;    shippingCalculators?: Array<ShippingCalculator<any>>;    shippingLineAssignmentStrategy?: ShippingLineAssignmentStrategy;    customFulfillmentProcess?: Array<FulfillmentProcess<any>>;    process?: Array<FulfillmentProcess<any>>;    fulfillmentHandlers?: Array<FulfillmentHandler<any>>;}
```

---

## SlugValidator

**URL:** https://docs.vendure.io/reference/typescript-api/service-helpers/slug-validator

**Contents:**
- SlugValidator
- SlugValidator‚Äã
  - constructor‚Äã
  - validateSlugs‚Äã
- InputWithSlug‚Äã
  - id‚Äã
  - translations‚Äã
- TranslationEntity‚Äã

Used to validate slugs to ensure they are URL-safe and unique. Designed to be used with translatable entities such as Product and Collection.

**Examples:**

Example 1 (ts):
```ts
class SlugValidator {    constructor(connection: TransactionalConnection)    validateSlugs(ctx: RequestContext, input: T, translationEntity: Type<E>) => Promise<T>;}
```

Example 2 (ts):
```ts
type InputWithSlug = {    id?: ID | null;    translations?: Array<{        id?: ID | null;        languageCode: LanguageCode;        slug?: string | null;    }> | null;}
```

Example 3 (ts):
```ts
type TranslationEntity = VendureEntity & {    id: ID;    languageCode: LanguageCode;    slug: string;    base: any;}
```

---

## AssetServerPlugin

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/

**Contents:**
- AssetServerPlugin
- AssetServerPlugin‚Äã
- Installation‚Äã
- Image transformation‚Äã
  - Preview mode‚Äã
  - Focal point‚Äã
  - Format‚Äã
  - Quality‚Äã
  - Transform presets‚Äã
  - Caching‚Äã

The AssetServerPlugin serves assets (images and other files) from the local file system, and can also be configured to use other storage strategies (e.g. S3AssetStorageStrategy. It can also perform on-the-fly image transformations and caches the results for subsequent calls.

yarn add @vendure/asset-server-plugin

npm install @vendure/asset-server-plugin

The full configuration is documented at AssetServerOptions

Asset preview images can be transformed (resized & cropped) on the fly by appending query parameters to the url:

http://localhost:3000/assets/some-asset.jpg?w=500&h=300&mode=resize

The above URL will return some-asset.jpg, resized to fit in the bounds of a 500px x 300px rectangle.

The mode parameter can be either crop or resize. See the ImageTransformMode docs for details.

When cropping an image (mode=crop), Vendure will attempt to keep the most "interesting" area of the image in the cropped frame. It does this by finding the area of the image with highest entropy (the busiest area of the image). However, sometimes this does not yield a satisfactory result - part or all of the main subject may still be cropped out.

This is where specifying the focal point can help. The focal point of the image may be specified by passing the fpx and fpy query parameters. These are normalized coordinates (i.e. a number between 0 and 1), so the fpx=0&fpy=0 corresponds to the top left of the image.

For example, let's say there is a very wide landscape image which we want to crop to be square. The main subject is a house to the far left of the image. The following query would crop it to a square with the house centered:

http://localhost:3000/assets/landscape.jpg?w=150&h=150&mode=crop&fpx=0.2&fpy=0.7

Since v1.7.0, the image format can be specified by adding the format query parameter:

http://localhost:3000/assets/some-asset.jpg?format=webp

This means that, no matter the format of your original asset files, you can use more modern formats in your storefront if the browser supports them. Supported values for format are:

The format parameter can also be combined with presets (see below).

Since v2.2.0, the image quality can be specified by adding the q query parameter:

http://localhost:3000/assets/some-asset.jpg?q=75

This applies to the jpg, webp and avif formats. The default quality value for jpg and webp is 80, and for avif is 50.

The q parameter can also be combined with presets (see below).

Presets can be defined which allow a single preset name to be 

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
import { AssetServerPlugin } from '@vendure/asset-server-plugin';const config: VendureConfig = {  // Add an instance of the plugin to the plugins array  plugins: [    AssetServerPlugin.init({      route: 'assets',      assetUploadDir: path.join(__dirname, 'assets'),    }),  ],};
```

Example 2 (ts):
```ts
AssetServerPlugin.init({  // ...  presets: [    { name: 'my-preset', width: 85, height: 85, mode: 'crop' },  ],}),
```

Example 3 (ts):
```ts
import { AssetServerPlugin, PresetOnlyStrategy } from '@vendure/core';// ...AssetServerPlugin.init({  //...  imageTransformStrategy: new PresetOnlyStrategy({    defaultPreset: 'thumbnail',    permittedQuality: [0, 50, 75, 85, 95],    permittedFormats: ['jpg', 'webp', 'avif'],    allowFocalPoint: false,  }),});
```

Example 4 (ts):
```ts
class AssetServerPlugin implements NestModule, OnApplicationBootstrap, OnApplicationShutdown {    init(options: AssetServerOptions) => Type<AssetServerPlugin>;    constructor(options: AssetServerOptions, processContext: ProcessContext, moduleRef: ModuleRef, assetServer: AssetServer)    configure(consumer: MiddlewareConsumer) => ;}
```

---

## Merge Strategies

**URL:** https://docs.vendure.io/reference/typescript-api/orders/merge-strategies

**Contents:**
- Merge Strategies
- MergeOrdersStrategy‚Äã
  - merge‚Äã
- UseExistingStrategy‚Äã
  - merge‚Äã
- UseGuestIfExistingEmptyStrategy‚Äã
  - merge‚Äã
- UseGuestStrategy‚Äã
  - merge‚Äã

Merges both Orders. If the guest order contains items which are already in the existing Order, the guest Order quantity will replace that of the existing Order.

The guest order is discarded and the existing order is used as the active order.

If the existing order is empty, then the guest order is used. Otherwise the existing order is used.

Any existing order is discarded and the guest order is set as the active order.

**Examples:**

Example 1 (ts):
```ts
class MergeOrdersStrategy implements OrderMergeStrategy {    merge(ctx: RequestContext, guestOrder: Order, existingOrder: Order) => MergedOrderLine[];}
```

Example 2 (ts):
```ts
class UseExistingStrategy implements OrderMergeStrategy {    merge(ctx: RequestContext, guestOrder: Order, existingOrder: Order) => MergedOrderLine[];}
```

Example 3 (ts):
```ts
class UseGuestIfExistingEmptyStrategy implements OrderMergeStrategy {    merge(ctx: RequestContext, guestOrder: Order, existingOrder: Order) => MergedOrderLine[];}
```

Example 4 (ts):
```ts
class UseGuestStrategy implements OrderMergeStrategy {    merge(ctx: RequestContext, guestOrder: Order, existingOrder: Order) => MergedOrderLine[];}
```

---

## UsePageBlock

**URL:** https://docs.vendure.io/reference/dashboard/page-layout/use-page-block

**Contents:**
- UsePageBlock
- usePageBlock‚Äã
  - props‚Äã

Returns the current PageBlock context, which means there must be a PageBlock ancestor component higher in the tree.

If optional is set to true, the hook will not throw if no PageBlock exists higher in the tree, but will just return undefined.

**Examples:**

Example 1 (tsx):
```tsx
const { blockId, title, description, column } = usePageBlock();
```

Example 2 (ts):
```ts
function usePageBlock(props: { optional?: boolean } = {}): void
```

---

## FileSizePipe

**URL:** https://docs.vendure.io/reference/admin-ui-api/pipes/file-size-pipe

**Contents:**
- FileSizePipe
- FileSizePipe‚Äã
  - transform‚Äã

Formats a number into a human-readable file size string.

**Examples:**

Example 1 (ts):
```ts
{{ fileSizeInBytes | filesize }}
```

Example 2 (ts):
```ts
class FileSizePipe implements PipeTransform {    transform(value: number, useSiUnits:  = true) => any;}
```

---

## AdminUiExtension

**URL:** https://docs.vendure.io/reference/admin-ui-api/ui-devkit/admin-ui-extension/

**Contents:**
- AdminUiExtension
- AdminUiExtension‚Äã
  - id‚Äã
  - extensionPath‚Äã
  - ngModules‚Äã
  - providers‚Äã
  - routes‚Äã
  - pathAlias‚Äã
  - exclude‚Äã
- TranslationExtension‚Äã

Defines extensions to the Admin UI application by specifying additional Angular NgModules which are compiled into the application.

See Extending the Admin UI for detailed instructions.

An optional ID for the extension module. Only used internally for generating import paths to your module. If not specified, a unique hash will be used as the id.

The path to the directory containing the extension module(s). The entire contents of this directory will be copied into the Admin UI app, including all TypeScript source files, html templates, scss style sheets etc.

One or more Angular modules which extend the default Admin UI.

Defines the paths to a file that exports an array of shared providers such as nav menu items, custom form inputs, custom detail components, action bar items, custom history entry components.

Defines routes that will be lazy-loaded at the /extensions/ route. The filePath should point to a file relative to the extensionPath which exports an array of Angular route definitions.

An optional alias for the module so it can be referenced by other UI extension modules.

By default, Angular modules declared in an AdminUiExtension do not have access to code outside the directory defined by the extensionPath. A scenario in which that can be useful though is in a monorepo codebase where a common NgModule is shared across different plugins, each defined in its own package. An example can be found below - note that the main tsconfig.json also maps the target module but using a path relative to the project's root folder. The UI module is not part of the main TypeScript build task as explained in Extending the Admin UI but having paths properly configured helps with usual IDE code editing features such as code completion and quick navigation, as well as linting.

Optional array specifying filenames or glob patterns that should be skipped when copying the directory defined by extensionPath.

Defines extensions to the Admin UI translations. Can be used as a stand-alone extension definition which only adds translations without adding new UI functionality, or as part of a full AdminUiExtension.

Optional object defining any translation files for the Admin UI. The value should be an object with the key as a 2-character ISO 639-1 language code, and the value being a glob for any relevant translation files in JSON format.

Defines extensions which copy static assets to the custom Admin UI application source asset directory.

Optional array of paths to static 

*[Content truncated]*

**Examples:**

Example 1 (ts):
```ts
interface AdminUiExtension extends Partial<TranslationExtension>,        Partial<StaticAssetExtension>,        Partial<GlobalStylesExtension> {    id?: string;    extensionPath: string;    ngModules?: Array<AdminUiExtensionSharedModule | AdminUiExtensionLazyModule>;    providers?: string[];    routes?: UiExtensionRouteDefinition[];    pathAlias?: string;    exclude?: string[];}
```

Example 2 (ts):
```ts
import { NgModule } from '@angular/core';import { SharedModule } from '@vendure/admin-ui/core';import { CommonUiComponent } from './components/common-ui/common-ui.component';export { CommonUiComponent };@NgModule({ imports: [SharedModule], exports: [CommonUiComponent], declarations: [CommonUiComponent],})export class CommonSharedUiModule {}
```

Example 3 (ts):
```ts
import path from 'path';import { AdminUiExtension } from '@vendure/ui-devkit/compiler';export const uiExtensions: AdminUiExtension = {  pathAlias: '@common-ui-module',     // this is the important part  extensionPath: path.join(__dirname, 'ui'),  ngModules: [    {      type: 'shared' as const,      ngModuleFileName: 'ui-shared.module.ts',      ngModuleName: 'CommonSharedUiModule',    },  ],};
```

Example 4 (json):
```json
{  "compilerOptions": {    "baseUrl": ".",    "paths": {      "@common-ui-module/*": ["packages/common-ui-module/src/ui/*"]    }  }}
```

---

## Money Decorator

**URL:** https://docs.vendure.io/reference/typescript-api/money/money-decorator

**Contents:**
- Money Decorator
- Money‚Äã
  - options‚Äã

Use this decorator for any entity field that is storing a monetary value. This allows the column type to be defined by the configured MoneyStrategy.

**Examples:**

Example 1 (ts):
```ts
function Money(options?: MoneyColumnOptions): void
```

---

## List Detail Views

**URL:** https://docs.vendure.io/reference/admin-ui-api/list-detail-views/

**Contents:**
- List Detail Views
- üìÑÔ∏è BaseDetailComponent
- üìÑÔ∏è BaseEntityResolver
- üìÑÔ∏è BaseListComponent
- üìÑÔ∏è DetailComponentWithResolver
- üìÑÔ∏è TypedBaseDetailComponent
- üìÑÔ∏è TypedBaseListComponent

detailComponentWithResolver

TypedBaseDetailComponent

TypedBaseListComponent

---

## CustomOrderStates

**URL:** https://docs.vendure.io/reference/typescript-api/orders/custom-order-states

**Contents:**
- CustomOrderStates
- CustomOrderStates‚Äã

An interface to extend standard OrderState.

**Examples:**

Example 1 (ts):
```ts
interface CustomOrderStates {}
```

---

## AssetServerOptions

**URL:** https://docs.vendure.io/reference/core-plugins/asset-server-plugin/asset-server-options/

**Contents:**
- AssetServerOptions
- AssetServerOptions‚Äã
  - route‚Äã
  - assetUploadDir‚Äã
  - assetUrlPrefix‚Äã
  - previewMaxWidth‚Äã
  - previewMaxHeight‚Äã
  - presets‚Äã
  - imageTransformStrategy‚Äã
  - namingStrategy‚Äã

The configuration options for the AssetServerPlugin.

The route to the asset server.

The local directory to which assets will be uploaded when using the LocalAssetStorageStrategy.

The complete URL prefix of the asset files. For example, "https://demo.vendure.io/assets/". A function can also be provided to handle more complex cases, such as serving multiple domains from a single server. In this case, the function should return a string url prefix.

If not provided, the plugin will attempt to guess based off the incoming request and the configured route. However, in all but the simplest cases, this guess may not yield correct results.

The max width in pixels of a generated preview image.

The max height in pixels of a generated preview image.

An array of additional ImageTransformPreset objects.

The strategy or strategies to use to determine the parameters for transforming an image. This can be used to implement custom image transformation logic, for example to limit transform parameters to a known set of presets.

If multiple strategies are provided, they will be executed in the order in which they are defined. If a strategy throws an error, the image transformation will be aborted and the error will be logged, with an HTTP 400 response sent to the client.

Defines how asset files and preview images are named before being saved.

Defines how previews are generated for a given Asset binary. By default, this uses the SharpAssetPreviewStrategy

A function which can be used to configure an AssetStorageStrategy. This is useful e.g. if you wish to store your assets using a cloud storage provider. By default, the LocalAssetStorageStrategy is used.

Configures the Cache-Control directive for response to control caching in browsers and shared caches (e.g. Proxies, CDNs). Defaults to publicly cached for 6 months.

**Examples:**

Example 1 (ts):
```ts
interface AssetServerOptions {    route: string;    assetUploadDir: string;    assetUrlPrefix?: string | ((ctx: RequestContext, identifier: string) => string);    previewMaxWidth?: number;    previewMaxHeight?: number;    presets?: ImageTransformPreset[];    imageTransformStrategy?: ImageTransformStrategy | ImageTransformStrategy[];    namingStrategy?: AssetNamingStrategy;    previewStrategy?: AssetPreviewStrategy;    storageStrategyFactory?: (        options: AssetServerOptions,    ) => AssetStorageStrategy | Promise<AssetStorageStrategy>;    cacheHeader?: CacheConfig | string;}
```

---

## ActionBar

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/action-bar

**Contents:**
- ActionBar
- DashboardActionBarItem‚Äã
  - pageId‚Äã
  - component‚Äã
  - type‚Äã
  - requiresPermission‚Äã

Allows you to define custom action bar items for any page in the dashboard, which is the top bar that normally contains the main call-to-action buttons such as "update" or "create".

This API also allows you to specify dropdown menu items, which when defined, will appear in a context menu to the very right of the ActionBar.

The ID of the page where the action bar item should be displayed.

A React component that will be rendered in the action bar. Typically, you would use the default Shadcn <Button> component.

The type of action bar item to display. Defaults to button. The 'dropdown' type is used to display the action bar item as a dropdown menu item.

When using the dropdown type, use a suitable dropdown item component, such as:

Any permissions that are required to display this action bar item.

**Examples:**

Example 1 (ts):
```ts
interface DashboardActionBarItem {    pageId: string;    component: React.FunctionComponent<{ context: PageContextValue }>;    type?: 'button' | 'dropdown';    requiresPermission?: string | string[];}
```

Example 2 (tsx):
```tsx
import { DropdownMenuItem } from '@vendure/dashboard';// ...{  component: () => <DropdownMenuItem>My Item</DropdownMenuItem>}
```

---

## VendureEntity

**URL:** https://docs.vendure.io/reference/typescript-api/entities/vendure-entity

**Contents:**
- VendureEntity
- VendureEntity‚Äã
  - constructor‚Äã
  - id‚Äã
  - createdAt‚Äã
  - updatedAt‚Äã

This is the base class from which all entities inherit. The type of the id property is defined by the EntityIdStrategy.

**Examples:**

Example 1 (ts):
```ts
class VendureEntity {    constructor(input?: DeepPartial<VendureEntity>)    @PrimaryGeneratedId()    id: ID;    @CreateDateColumn() createdAt: Date;    @UpdateDateColumn() updatedAt: Date;}
```

---

## RegisterBulkAction

**URL:** https://docs.vendure.io/reference/admin-ui-api/bulk-actions/register-bulk-action/

**Contents:**
- RegisterBulkAction
- registerBulkAction‚Äã
  - bulkAction‚Äã

Registers a custom BulkAction which can be invoked from the bulk action menu of any supported list view.

This allows you to provide custom functionality that can operate on any of the selected items in the list view.

In this example, imagine we have an integration with a 3rd-party text translation service. This bulk action allows us to select multiple products from the product list view, and send them for translation via a custom service which integrates with the translation service's API.

**Examples:**

Example 1 (ts):
```ts
import { ModalService, registerBulkAction, SharedModule } from '@vendure/admin-ui/core';import { ProductDataTranslationService } from './product-data-translation.service';export default [    ProductDataTranslationService,    registerBulkAction({        location: 'product-list',        label: 'Send to translation service',        icon: 'language',        onClick: ({ injector, selection }) => {            const modalService = injector.get(ModalService);            const translationService = injector.get(ProductDataTranslationService);            modalService                .dialog({             
...
```

Example 2 (ts):
```ts
function registerBulkAction(bulkAction: BulkAction): void
```

---

## ProductVariantService

**URL:** https://docs.vendure.io/reference/typescript-api/services/product-variant-service/

**Contents:**
- ProductVariantService
- ProductVariantService‚Äã
  - constructor‚Äã
  - findAll‚Äã
  - findOne‚Äã
  - findByIds‚Äã
  - getVariantsByProductId‚Äã
  - getVariantsByCollectionId‚Äã
  - getProductVariantChannels‚Äã
  - getProductVariantPrices‚Äã

Contains methods relating to ProductVariant entities.

Returns a PaginatedList of all ProductVariants associated with the given Collection.

Returns all Channels to which the ProductVariant is assigned.

Returns the ProductVariant associated with the given OrderLine.

Returns the ProductOptions for the given ProductVariant.

Returns the Product associated with the ProductVariant. Whereas the ProductService.findOne() method performs a large multi-table join with all the typical data needed for a "product detail" page, this method returns only the Product itself.

Returns the number of saleable units of the ProductVariant, i.e. how many are available for purchase by Customers. This is determined by the ProductVariant's stockOnHand value, as well as the local and global outOfStockThreshold settings.

Returns the stockLevel to display to the customer, as specified by the configured StockDisplayStrategy.

Returns the number of fulfillable units of the ProductVariant, equivalent to stockOnHand for those variants which are tracking inventory.

Creates a ProductVariantPrice for the given ProductVariant/Channel combination. If the currencyCode is not specified, the default currency of the Channel will be used.

This method is intended to be used by the ProductVariant GraphQL entity resolver to resolve the price-related fields which need to be populated at run-time using the applyChannelPriceAndTax method.

Is optimized to make as few DB calls as possible using caching based on the open request.

Populates the price field with the price for the specified channel.

Assigns the specified ProductVariants to the specified Channel. In doing so, it will create a new ProductVariantPrice and also assign the associated Product and any Assets to the Channel too.

**Examples:**

Example 1 (ts):
```ts
class ProductVariantService {    constructor(connection: TransactionalConnection, configService: ConfigService, taxCategoryService: TaxCategoryService, facetValueService: FacetValueService, assetService: AssetService, translatableSaver: TranslatableSaver, eventBus: EventBus, listQueryBuilder: ListQueryBuilder, globalSettingsService: GlobalSettingsService, stockMovementService: StockMovementService, stockLevelService: StockLevelService, channelService: ChannelService, roleService: RoleService, customFieldRelationService: CustomFieldRelationService, requestCache: RequestContextCacheService, prod
...
```

---

## ActionBarLocationId

**URL:** https://docs.vendure.io/reference/admin-ui-api/action-bar/action-bar-location-id

**Contents:**
- ActionBarLocationId
- ActionBarLocationId‚Äã

The valid locationIds for registering action bar items. For a list of values, see PageLocationId.

**Examples:**

Example 1 (ts):
```ts
type ActionBarLocationId = PageLocationId
```

---

## FulfillmentHandler

**URL:** https://docs.vendure.io/reference/typescript-api/fulfillment/fulfillment-handler

**Contents:**
- FulfillmentHandler
- FulfillmentHandler‚Äã
  - constructor‚Äã
- FulfillmentHandlerConfig‚Äã
  - createFulfillment‚Äã
  - onFulfillmentTransition‚Äã
- CreateFulfillmentFn‚Äã
- CreateFulfillmentResult‚Äã

A FulfillmentHandler is used when creating a new Fulfillment. When the addFulfillmentToOrder mutation is executed, the specified handler will be used and it's createFulfillment method is called. This method may perform async tasks such as calling a 3rd-party shipping API to register a new shipment and receive a tracking code. This data can then be returned and will be incorporated into the created Fulfillment.

If the args property is defined, this means that arguments passed to the addFulfillmentToOrder mutation will be passed through to the createFulfillment method as the last argument.

The configuration object used to instantiate a FulfillmentHandler.

Invoked when the addFulfillmentToOrder mutation is executed with this handler selected.

If an Error is thrown from within this function, no Fulfillment is created and the CreateFulfillmentError result will be returned.

This allows the handler to intercept state transitions of the created Fulfillment. This works much in the same way as the FulfillmentProcess onTransitionStart method (i.e. returning false or string will be interpreted as an error and prevent the state transition), except that it is only invoked on Fulfillments which were created with this particular FulfillmentHandler.

It can be useful e.g. to intercept Fulfillment cancellations and relay that information to a 3rd-party shipping API.

The function called when creating a new Fulfillment

**Examples:**

Example 1 (ts):
```ts
let shipomatic;export const shipomaticFulfillmentHandler = new FulfillmentHandler({  code: 'ship-o-matic',  description: [{    languageCode: LanguageCode.en,    value: 'Generate tracking codes via the Ship-o-matic API'  }],  args: {    preferredService: {      type: 'string',      ui: {        component: 'select-form-input',        options: [          { value: 'first_class' },          { value: 'priority'},          { value: 'standard' },        ],      },    }  },  init: () => {    // some imaginary shipping service    shipomatic = new ShipomaticClient(API_KEY);  },  createFulfillment: async 
...
```

Example 2 (ts):
```ts
class FulfillmentHandler<T extends ConfigArgs = ConfigArgs> extends ConfigurableOperationDef<T> {    constructor(config: FulfillmentHandlerConfig<T>)}
```

Example 3 (ts):
```ts
interface FulfillmentHandlerConfig<T extends ConfigArgs> extends ConfigurableOperationDefOptions<T> {    createFulfillment: CreateFulfillmentFn<T>;    onFulfillmentTransition?: OnTransitionStartFn<FulfillmentState, FulfillmentTransitionData>;}
```

Example 4 (ts):
```ts
type CreateFulfillmentFn<T extends ConfigArgs> = (    ctx: RequestContext,    orders: Order[],    lines: OrderLineInput[],    args: ConfigArgValues<T>,) => CreateFulfillmentResult | Promise<CreateFulfillmentResult>
```

---

## PermissionDefinition

**URL:** https://docs.vendure.io/reference/typescript-api/auth/permission-definition

**Contents:**
- PermissionDefinition
- PermissionDefinition‚Äã
  - constructor‚Äã
  - Permission‚Äã
- CrudPermissionDefinition‚Äã
  - constructor‚Äã
  - Create‚Äã
  - Read‚Äã
  - Update‚Äã
  - Delete‚Äã

Defines a new Permission with which to control access to GraphQL resolvers & REST controllers. Used in conjunction with the Allow decorator (see example below).

Note: To define CRUD permissions, use the CrudPermissionDefinition.

Returns the permission defined by this definition, for use in the Allow decorator.

Defines a set of CRUD Permissions for the given name, i.e. a name of 'Wishlist' will create 4 Permissions: 'CreateWishlist', 'ReadWishlist', 'UpdateWishlist' & 'DeleteWishlist'.

Returns the 'Create' CRUD permission defined by this definition, for use in the Allow decorator.

Returns the 'Read' CRUD permission defined by this definition, for use in the Allow decorator.

Returns the 'Update' CRUD permission defined by this definition, for use in the Allow decorator.

Returns the 'Delete' CRUD permission defined by this definition, for use in the Allow decorator.

Defines a set of Read-Write Permissions for the given name, i.e. a name of 'DashboardSavedViews' will create 2 Permissions: 'ReadDashboardSavedViews' and 'WriteDashboardSavedViews'.

Returns the 'Read' permission defined by this definition, for use in the Allow decorator.

Returns the 'Write' permission defined by this definition, for use in the Allow decorator.

Configures a PermissionDefinition

The name of the permission. By convention this should be UpperCamelCased.

A description of the permission.

Whether this permission can be assigned to a Role. In general this should be left as the default true except in special cases.

Internal permissions are not exposed via the API and are reserved for special use-cases such at the Owner or Public permissions.

**Examples:**

Example 1 (ts):
```ts
export const sync = new PermissionDefinition({  name: 'SyncInventory',  description: 'Allows syncing stock levels via Admin API'});
```

Example 2 (ts):
```ts
const config: VendureConfig = {  authOptions: {    customPermissions: [sync],  },}
```

Example 3 (ts):
```ts
@Resolver()export class ExternalSyncResolver {  @Allow(sync.Permission)  @Mutation()  syncStockLevels() {    // ...  }}
```

Example 4 (ts):
```ts
class PermissionDefinition {    constructor(config: PermissionDefinitionConfig)    Permission: Permission}
```

---

## BulkAction

**URL:** https://docs.vendure.io/reference/admin-ui-api/bulk-actions/bulk-action

**Contents:**
- BulkAction
- BulkAction‚Äã
  - location‚Äã
  - label‚Äã
  - getTranslationVars‚Äã
  - icon‚Äã
  - iconClass‚Äã
  - onClick‚Äã
  - isVisible‚Äã
  - requiresPermission‚Äã

Configures a bulk action which can be performed on all selected items in a list view.

For a full example, see the registerBulkAction docs.

An optional function that should resolve to a map of translation variables which can be used when translating the label string.

A valid Clarity Icons icon shape, e.g. "cog", "user", "info-standard".

A class to be added to the icon element. Examples:

Defines the logic that executes when the bulk action button is clicked.

A function that determines whether this bulk action item should be displayed in the menu. If not defined, the item will always be displayed.

This function will be invoked each time the selection is changed, so try to avoid expensive code running here.

Control the display of this item based on the user permissions.

A valid location of a list view that supports the bulk actions API.

This is the argument which gets passed to the getTranslationVars and isVisible functions of the BulkAction definition.

An array of the selected items from the list.

The component instance that is hosting the list view. For instance, ProductListComponent. This can be used to call methods on the instance, e.g. calling hostComponent.refresh() to force a list refresh after deleting the selected items.

The Angular Injector which can be used to get service instances which might be needed in the click handler.

This is the argument which gets passed to the onClick function of a BulkAction.

Clears the selection in the active list view.

The click event itself.

**Examples:**

Example 1 (ts):
```ts
interface BulkAction<ItemType = any, ComponentType = any> {    location: BulkActionLocationId;    label: string;    getTranslationVars?: (        context: BulkActionFunctionContext<ItemType, ComponentType>,    ) => Record<string, string | number> | Promise<Record<string, string | number>>;    icon?: string;    iconClass?: string;    onClick: (context: BulkActionClickContext<ItemType, ComponentType>) => void;    isVisible?: (context: BulkActionFunctionContext<ItemType, ComponentType>) => boolean | Promise<boolean>;    requiresPermission?: string | ((userPermissions: string[]) => boolean);}
```

Example 2 (ts):
```ts
import { registerBulkAction, DataService } from '@vendure/admin-ui/core';registerBulkAction({  location: 'product-list',  label: 'Assign to channel',  // Only display this action if there are multiple channels  isVisible: ({ injector }) => injector.get(DataService).client    .userStatus()    .mapSingle(({ userStatus }) => 1 < userStatus.channels.length)    .toPromise(),  // ...});
```

Example 3 (ts):
```ts
registerBulkAction({  // Can be specified as a simple string  requiresPermission: Permission.UpdateProduct,  // Or as a function that returns a boolean if permissions are satisfied  requiresPermission: userPermissions =>    userPermissions.includes(Permission.UpdateCatalog) ||    userPermissions.includes(Permission.UpdateProduct),  // ...})
```

Example 4 (ts):
```ts
type BulkActionLocationId = | 'product-list'    | 'facet-list'    | 'collection-list'    | 'customer-list'    | 'customer-group-list'    | 'customer-group-members-list'    | 'customer-group-members-picker-list'    | 'promotion-list'    | 'seller-list'    | 'channel-list'    | 'administrator-list'    | 'role-list'    | 'shipping-method-list'    | 'stock-location-list'    | 'payment-method-list'    | 'tax-category-list'    | 'tax-rate-list'    | 'zone-list'    | 'zone-members-list'    | string
```

---

## ProductVariantPriceSelectionStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/configuration/product-variant-price-selection-strategy/

**Contents:**
- ProductVariantPriceSelectionStrategy
- ProductVariantPriceSelectionStrategy‚Äã
  - selectPrice‚Äã
- DefaultProductVariantPriceSelectionStrategy‚Äã
  - selectPrice‚Äã

The strategy for selecting the price for a ProductVariant in a given Channel.

This is configured via the catalogOptions.productVariantPriceSelectionStrategy property of your VendureConfig.

The default strategy for selecting the price for a ProductVariant in a given Channel. It first filters all available prices to those which are in the current Channel, and then selects the first price which matches the current currency.

**Examples:**

Example 1 (ts):
```ts
interface ProductVariantPriceSelectionStrategy extends InjectableStrategy {    selectPrice(        ctx: RequestContext,        prices: ProductVariantPrice[],    ): ProductVariantPrice | undefined | Promise<ProductVariantPrice | undefined>;}
```

Example 2 (ts):
```ts
class DefaultProductVariantPriceSelectionStrategy implements ProductVariantPriceSelectionStrategy {    selectPrice(ctx: RequestContext, prices: ProductVariantPrice[]) => ;}
```

---

## Login

**URL:** https://docs.vendure.io/reference/dashboard/extensions-api/login

**Contents:**
- Login
- DashboardLoginExtensions‚Äã
  - logo‚Äã
  - beforeForm‚Äã
  - afterForm‚Äã
- LoginLogoExtension‚Äã
  - component‚Äã
- LoginBeforeFormExtension‚Äã
  - component‚Äã
- LoginAfterFormExtension‚Äã

Defines all available login page extensions.

Custom logo component to replace the default Vendure logo.

Component to render before the login form.

Component to render after the login form.

Defines a custom logo component for the login page.

A React component that will replace the default Vendure logo.

Defines content to display before the login form.

A React component that will be rendered before the login form.

Defines content to display after the login form.

A React component that will be rendered after the login form.

**Examples:**

Example 1 (ts):
```ts
interface DashboardLoginExtensions {    logo?: LoginLogoExtension;    beforeForm?: LoginBeforeFormExtension;    afterForm?: LoginAfterFormExtension;}
```

Example 2 (ts):
```ts
interface LoginLogoExtension {    component: React.ComponentType;}
```

Example 3 (ts):
```ts
interface LoginBeforeFormExtension {    component: React.ComponentType;}
```

Example 4 (ts):
```ts
interface LoginAfterFormExtension {    component: React.ComponentType;}
```

---

## GuestCheckoutStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/guest-checkout-strategy/

**Contents:**
- GuestCheckoutStrategy
- GuestCheckoutStrategy‚Äã
  - setCustomerForOrder‚Äã

A strategy that determines how to deal with guest checkouts - i.e. when a customer checks out without being logged in. For example, a strategy could be used to implement business rules such as:

This is configured via the orderOptions.guestCheckoutStrategy property of your VendureConfig.

This method is called when the setCustomerForOrder mutation is executed. It should return either a Customer object or an ErrorResult.

**Examples:**

Example 1 (ts):
```ts
interface GuestCheckoutStrategy extends InjectableStrategy {    setCustomerForOrder(        ctx: RequestContext,        order: Order,        input: CreateCustomerInput,    ):        | ErrorResultUnion<SetCustomerForOrderResult, Customer>        | Promise<ErrorResultUnion<SetCustomerForOrderResult, Customer>>;}
```

---

## Collection

**URL:** https://docs.vendure.io/reference/typescript-api/entities/collection

**Contents:**
- Collection
- Collection‚Äã
  - constructor‚Äã
  - isRoot‚Äã
  - position‚Äã
  - isPrivate‚Äã
  - name‚Äã
  - description‚Äã
  - slug‚Äã
  - translations‚Äã

A Collection is a grouping of Products based on various configurable criteria.

Extends: VendureEntity

Implements: Translatable, HasCustomFields, ChannelAware, Orderable

**Examples:**

Example 1 (ts):
```ts
class Collection extends VendureEntity implements Translatable, HasCustomFields, ChannelAware, Orderable {    constructor(input?: DeepPartial<Collection>)    @Column({ default: false })    isRoot: boolean;    @Column()    position: number;    @Column({ default: false })    isPrivate: boolean;    name: LocaleString;    description: LocaleString;    slug: LocaleString;    @OneToMany(type => CollectionTranslation, translation => translation.base, { eager: true })    translations: Array<Translation<Collection>>;    @Index()    @ManyToOne(type => Asset, asset => asset.featuredInCollections, { onDel
...
```

---

## OrderItemPriceCalculationStrategy

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-item-price-calculation-strategy/

**Contents:**
- OrderItemPriceCalculationStrategy
- OrderItemPriceCalculationStrategy‚Äã
  - When is the strategy invoked ?‚Äã
  - OrderItemPriceCalculationStrategy vs Promotions‚Äã
  - Example use-cases‚Äã
  - calculateUnitPrice‚Äã

The OrderItemPriceCalculationStrategy defines the listPrice of an OrderLine when adding an item to an Order. By default the DefaultOrderItemPriceCalculationStrategy is used.

This is configured via the orderOptions.orderItemPriceCalculationStrategy property of your VendureConfig.

Both the OrderItemPriceCalculationStrategy and Promotions can be used to alter the price paid for a product.

The main difference is when a Promotion is applied, it adds a discount line to the Order, and the regular price is used for the value of OrderLine.listPrice property, whereas the OrderItemPriceCalculationStrategy actually alters the value of OrderLine.listPrice itself, and does not add any discounts to the Order.

Use OrderItemPriceCalculationStrategy if:

A custom OrderItemPriceCalculationStrategy can be used to implement things like:

Receives the ProductVariant to be added to the Order as well as any OrderLine custom fields and returns the price for a single unit.

Note: if you have any relation type custom fields defined on the OrderLine entity, they will only be passed in to this method if they are set to eager: true. Otherwise, you can use the EntityHydratorto join the missing relations.

Note: the quantity argument was added in v2.0.0

**Examples:**

Example 1 (ts):
```ts
interface OrderItemPriceCalculationStrategy extends InjectableStrategy {    calculateUnitPrice(        ctx: RequestContext,        productVariant: ProductVariant,        orderLineCustomFields: { [key: string]: any },        order: Order,        quantity: number,    ): PriceCalculationResult | Promise<PriceCalculationResult>;}
```

---

## TestConfig

**URL:** https://docs.vendure.io/reference/typescript-api/testing/test-config

**Contents:**
- TestConfig
- testConfig‚Äã
- Logging‚Äã

A VendureConfig object used for e2e tests. This configuration uses sqljs as the database and configures some special settings which are optimized for e2e tests:

By default, the testConfig does not output any log messages. This is most desirable to keep a clean CI output. However, for debugging purposes, it can make it hard to figure out why tests fail.

You can enable default logging behaviour with the environment variable LOG:

**Examples:**

Example 1 (text):
```text
LOG=true yarn e2e
```

---

## OrderInterceptor

**URL:** https://docs.vendure.io/reference/typescript-api/orders/order-interceptor

**Contents:**
- OrderInterceptor
- OrderInterceptor‚Äã
- Example: Min/max order quantity‚Äã
  - willAddItemToOrder‚Äã
  - willAdjustOrderLine‚Äã
  - willRemoveItemFromOrder‚Äã

An OrderInterceptor is a class which can be used to intercept and modify the behavior of order-related operations.

It does this by providing methods which are called whenever the contents of an order are about to get changed. These methods are able to prevent the operation from proceeding by returning a string error message.

Examples of use-cases for an OrderInterceptor include:

This is configured via the orderOptions.orderInterceptors property of your VendureConfig.

OrderInterceptors are executed when the following mutations are called:

Additionally, if you are working directly with the OrderService, the following methods will trigger any registered OrderInterceptors:

When an OrderInterceptor is registered, it will be called in the order in which it was registered. If an interceptor method resolves to a string, the operation will be prevented and the string will be used as the error message.

When multiple interceptors are registered, the first interceptor to resolve to a string will prevent the operation from proceeding.

Errors returned by OrderInterceptors are surfaced to the GraphQL API as an OrderInterceptorError and can be queried like this:

In the above example, the error message returned by the OrderInterceptor would be available in the interceptorError field.

Let's say we want to allow ProductVariants to specify the minimum or maximum amount which may be added to an order. We can define custom fields to store this information and then use this custom field value to prevent an order line from being added to the order if the quantity is below the minimum.

Called when a new item is about to be added to the order, as in the addItemToOrder mutation or the addItemToOrder() / addItemsToOrder() method of the OrderService.

Called when an existing order line is about to be adjusted, as in the adjustOrderLine mutation or the adjustOrderLine() / adjustOrderLines() method of the OrderService.

Called when an item is about to be removed from the order, as in the removeItemFromOrder mutation or the removeItemFromOrder() / removeItemsFromOrder() method of the OrderService.

**Examples:**

Example 1 (graphql):
```graphql
mutation AddItemToOrder($productVariantId: ID!, $quantity: Int!) {  addItemToOrder(productVariantId: $productVariantId, quantity: $quantity) {    ... on Order {      id      code      # ... other Order fields    }    ... on ErrorResult {      errorCode      message    }    ... on OrderInterceptorError {      interceptorError    }  }}
```

Example 2 (ts):
```ts
import {  EntityHydrator,  Injector,  LanguageCode,  Order,  OrderInterceptor,  ProductVariant,  RequestContext,  TranslatorService,  VendurePlugin,  WillAddItemToOrderInput,  WillAdjustOrderLineInput,} from '@vendure/core';declare module '@vendure/core/dist/entity/custom-entity-fields' {  interface CustomProductVariantFields {    minOrderQuantity?: number;    maxOrderQuantity?: number;  }}// This OrderInterceptor enforces minimum and maximum order quantities on ProductVariants.export class MinMaxOrderInterceptor implements OrderInterceptor { private entityHydrator: EntityHydrator; private tra
...
```

Example 3 (ts):
```ts
interface OrderInterceptor extends InjectableStrategy {    willAddItemToOrder?(        ctx: RequestContext,        order: Order,        input: WillAddItemToOrderInput,    ): Promise<void | string> | void | string;    willAdjustOrderLine?(        ctx: RequestContext,        order: Order,        input: WillAdjustOrderLineInput,    ): Promise<void | string> | void | string;    willRemoveItemFromOrder?(        ctx: RequestContext,        order: Order,        orderLine: OrderLine,    ): Promise<void | string> | void | string;}
```

---

## EmailEventHandlerWithAsyncData

**URL:** https://docs.vendure.io/reference/core-plugins/email-plugin/email-event-handler-with-async-data

**Contents:**
- EmailEventHandlerWithAsyncData
- EmailEventHandlerWithAsyncData‚Äã
  - constructor‚Äã

Identical to the EmailEventHandler but with a data property added to the event based on the result of the .loadData() function.

**Examples:**

Example 1 (ts):
```ts
class EmailEventHandlerWithAsyncData<Data, T extends string = string, InputEvent extends EventWithContext = EventWithContext, Event extends EventWithAsyncData<InputEvent, Data> = EventWithAsyncData<InputEvent, Data>> extends EmailEventHandler<T, Event> {    constructor(_loadDataFn: LoadDataFn<InputEvent, Data>, listener: EmailEventListener<T>, event: Type<InputEvent>)}
```

---

## SubscribableJob

**URL:** https://docs.vendure.io/reference/typescript-api/job-queue/subscribable-job

**Contents:**
- SubscribableJob
- SubscribableJob‚Äã
  - constructor‚Äã
  - updates‚Äã

This is a type of Job object that allows you to subscribe to updates to the Job. It is returned by the JobQueue's add() method. Note that the subscription capability is only supported if the JobQueueStrategy implements the InspectableJobQueueStrategy interface (e.g. the SqlJobQueueStrategy does support this).

Returns an Observable stream of updates to the Job. Works by polling the current JobQueueStrategy's findOne() method to obtain updates. If the updates are not subscribed to, then no polling occurs.

Polling interval, timeout and other options may be configured with an options arguments JobUpdateOptions.

**Examples:**

Example 1 (ts):
```ts
class SubscribableJob<T extends JobData<T> = any> extends Job<T> {    constructor(job: Job<T>, jobQueueStrategy: JobQueueStrategy)    updates(options?: JobUpdateOptions) => Observable<JobUpdate<T>>;}
```

---
